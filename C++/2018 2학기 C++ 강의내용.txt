//-----------------------------------------------
// 2018.8.27 월56          월목     (1주 1일)
// 1. 강의소스가 자동으로 저장되면 좋겠다.
//-----------------------------------------------

#include <fstream>
#include <iostream>

void save();		//함수를 부르기 전에 선언하자

int main()
{
	std::cout << "강의를 저장했다." << std::endl;

	save();
}

void save()
{
	// 저장할 파일을 연다
	std::ofstream out("2018 2학기 C++ 강의내용.txt");

	//읽어올 파일을 연다
	std::ifstream in("소스.cpp");

	// 파일에 소스.cpp를 기록한다
	int c;

	while ( (c = in.get()) !=EOF )
		out.put(c);
		// 끝났으면 파일을 닫는다
	in.close();
	out.close();
}//-----------------------------------------------
// 2018.8.27 월56          월목     (1주 2일)
// 1. 강의소스가 자동으로 저장되면 좋겠다.
// 2. 날짜도 기록하자
//-----------------------------------------------

#include <fstream>
#include <iostream>
#include <chrono>
#include <ctime>
#include <string>

void save();		//함수를 부르기 전에 선언하자

int main()
{
	std::cout << "강의를 저장했다." << std::endl;

	save();
}

void save()
{
	// 저장할 파일을 연다. --덧붙여 쓰기 모드로 열어야 한다
	std::ofstream out("2018 2학기 C++ 강의내용.txt", std::ios::app);

	// 읽어올 파일을 연다
	std::ifstream in("소스.cpp");

	// 저장한 날짜도 파일에 기록하자 (495쪽)
	auto tp = std::chrono::system_clock::now();	//현재시간
	auto t = std::chrono::system_clock::to_time_t(tp); 	//시간형태로 변환
	std::string date = ctime(&t);

	std::cout << date << std::endl;

	
	// 파일에 소스.cpp를 기록한다
	int c;

	while ( (c = in.get()) !=EOF )
		out.put(c);
		// 끝났으면 파일을 닫는다
	in.close();
	out.close();
}
-----------------------------------
Thu Aug 30 09:55:39 2018

-----------------------------------
//-----------------------------------------------
// 2018.8.27 월56          월목     (1주 2일)
// 1. 강의소스가 자동으로 저장되면 좋겠다.
// 2. 날짜도 기록하자
//-----------------------------------------------

#include <fstream>
#include <iostream>
#include <chrono>
#include <ctime>
#include <string>

void save();		//함수를 부르기 전에 선언하자

int main()
{
	std::cout << "강의를 저장했다." << std::endl;

	save();
}

void save()
{
	// 저장할 파일을 연다. --덧붙여 쓰기 모드로 열어야 한다
	std::ofstream out("2018 2학기 C++ 강의내용.txt", std::ios::app);

	// 읽어올 파일을 연다
	std::ifstream in("소스.cpp");

	// 저장한 날짜도 파일에 기록하자 (495쪽)
	auto tp = std::chrono::system_clock::now();	//현재시간
	auto t = std::chrono::system_clock::to_time_t(tp); 	//시간형태로 변환
	std::string date = ctime(&t);

	out << "-----------------------------------" << std::endl;
	out << date << std::endl;
	out << "-----------------------------------" << std::endl;

	
	// 파일에 소스.cpp를 기록한다
	int c;

	while ( (c = in.get()) !=EOF )
		out.put(c);
		// 끝났으면 파일을 닫는다
	in.close();
	out.close();
}



----------------------------------------------------------
Thu Aug 30 09:57:46 2018

----------------------------------------------------------
//-----------------------------------------------
// 2018.8.27 월56          월목     (1주 2일)
// 1. 강의소스가 자동으로 저장되면 좋겠다.
// 2. 날짜도 기록하자
//-----------------------------------------------

#include <fstream>
#include <iostream>
#include <chrono>
#include <ctime>
#include <string>

void save();		//함수를 부르기 전에 선언하자

int main()
{
	std::cout << "강의를 저장했다." << std::endl;

	save();
}

void save()
{
	// 저장할 파일을 연다. --덧붙여 쓰기 모드로 열어야 한다
	std::ofstream out("2018 2학기 C++ 강의내용.txt", std::ios::app);

	// 읽어올 파일을 연다
	std::ifstream in("소스.cpp");

	// 저장한 날짜도 파일에 기록하자 (495쪽)
	auto tp = std::chrono::system_clock::now();	//현재시간
	auto t = std::chrono::system_clock::to_time_t(tp); 	//시간형태로 변환
	std::string date = ctime(&t);

	out << "----------------------------------------------------------" << std::endl;
	out << date << std::endl;
	out << "----------------------------------------------------------" << std::endl;

	
	// 파일에 소스.cpp를 기록한다
	int c;

	while ( (c = in.get()) !=EOF )
		out.put(c);
		// 끝났으면 파일을 닫는다
	in.close();
	out.close();
}





-----------------------------------
Thu Aug 30 10:06:43 2018

-----------------------------------
//-----------------------------------------------
// 2018.8.27 월56          월목     (1주 2일)
// 1. 강의소스가 자동으로 저장되면 좋겠다.
// 2. 날짜도 기록하자
// 3. save()의 내용을 매번 저장할 이유는 없다. - save는 다른 파일로
//-----------------------------------------------

#include <fstream>
#include <iostream>
#include <chrono>
#include <ctime>
#include <string>

void save();		//함수를 부르기 전에 선언하자

int main()
{
	std::cout << "강의를 저장했다." << std::endl;

	save();
}




-----------------------------------
Thu Aug 30 10:12:29 2018

-----------------------------------
//-----------------------------------------------
// 2018.8.27 월56          월목     (1주 2일)
// 1. 강의소스가 자동으로 저장되면 좋겠다.
// 2. 날짜도 기록하자
// 3. save()의 내용을 매번 저장할 이유는 없다. - save는 다른 파일로
//-----------------------------------------------

#include <fstream>
#include <iostream>
#include <chrono>
#include <ctime>
#include <string>

void save();		//함수를 부르기 전에 선언하자

int main()
{
	std::cout << "강의를 저장했다." << std::endl;

	save();
}





-----------------------------------
Thu Aug 30 10:18:35 2018

-----------------------------------
//-----------------------------------------------
// 2018.8.27 월56          월목     (1주 2일)
// save()를 파일로 분리하였다.
//-----------------------------------------------

#include "save.h"

int main()
{
	save();
}





-----------------------------------
Thu Aug 30 10:36:22 2018

-----------------------------------
//-----------------------------------------------
// 2018.8.27 월56          월목     (1주 2일)
// save()를 파일로 분리하였다.
//
// 1. 입출력 - cin, cout, cerr, clog
//-----------------------------------------------

#include <iostream>
#include "save.h"

using std::cout;

int main()
{
	cout << "안녕? 난 C++이야 반가워!";
	
	save();
}





-----------------------------------
Thu Aug 30 10:40:39 2018

-----------------------------------
//-----------------------------------------------
// 2018.8.27 월56          월목     (1주 2일)
// save()를 파일로 분리하였다.
//
// 1. 입출력 - cin, cout, cerr, clog
//-----------------------------------------------

#include <iostream>
#include "save.h"

using std::cout;
using std::cin;

int main()
{
	cout << "안녕? 난 C++이야 반가워!";
	char n;
	cin >> n;
	
	save();
}





-----------------------------------
Thu Aug 30 10:47:48 2018

-----------------------------------
//-----------------------------------------------
// 2018.8.27 월56          월목     (1주 2일)
// save()를 파일로 분리하였다.
//
// 1. 입출력 - cin, cout, cerr, clog
//-----------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;

int main()
{
	cout << "안녕? 난 C++이야 반가워!";
	char n;
	cin >> n;
	
	save();
}





-----------------------------------
Thu Aug 30 10:49:27 2018

-----------------------------------
//-----------------------------------------------
// 2018.8.27 월56          월목     (1주 2일)
// save()를 파일로 분리하였다.
//
// 1. 입출력 - cin, cout, cerr, clog
// 2. 구구단
//-----------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;

int main()
{
	cerr << "나도 화면이다.";
	save();
}





-----------------------------------
Thu Aug 30 10:57:06 2018

-----------------------------------
//-----------------------------------------------
// 2018.8.27 월56          월목     (1주 2일)
// save()를 파일로 분리하였다.
//
// 1. 입출력 - cin, cout, cerr, clog
// 2. 구구단
//-----------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;

int main()
{
	//구구단 2단을 화면에 출력합니다.
	for(int i=1; i<=9;++i)  {
		cout << "2 * " << i << "=" << 2 * i << endl;
	}
	save();
}





-----------------------------------
Thu Aug 30 10:58:02 2018

-----------------------------------
//-----------------------------------------------
// 2018.8.27 월56          월목     (1주 2일)
// save()를 파일로 분리하였다.
//
// 1. 입출력 - cin, cout, cerr, clog
// 2. 구구단
//-----------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;

int main()
{
	//구구단 2단을 화면에 출력합니다.
	for(int i=1; i<=9;i++)  {
		cout << "2 * " << i << " = " << 2 * i << endl;
	}
	save();
}





-----------------------------------
Thu Aug 30 11:01:08 2018

-----------------------------------
//-----------------------------------------------
// 2018.8.27 월56          월목     (1주 2일)
// save()를 파일로 분리하였다.
//
// 1. 입출력 - cin, cout, cerr, clog
// 2. 구구단
//-----------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;

int main()
{
	//구구단을 화면에 출력합니다.
	for(int j=2;j<=9;++j){
		for (int i = 1; i <= 9; ++i) {
			cout << j << " * " << i << " = " << j * i << endl;
		}
		cout << endl;
	}
	save();
}





-----------------------------------
Thu Aug 30 11:03:32 2018

-----------------------------------
//-----------------------------------------------
// 2018.8.27 월56          월목     (1주 2일)
// save()를 파일로 분리하였다.
//
// 1. 입출력 - cin, cout, cerr, clog
// 2. 구구단
//-----------------------------------------------

#include <iostream>
#include "save.h"

using namespace std;

int main()
{
	//몇단을 출력할지 물어보고 화면에 출력합니다.

	save();
}





-----------------------------------
Thu Aug 30 11:09:45 2018

-----------------------------------
/*
-----------------------------------------------
 2018.8.27 월56          월목     (1주 2일)

 random number
 자료형, 변수, 메모리
-----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;

int main()
{
	// 임의의 값(random)을 갖는 정수 100개를 만들어 보자
	int a[100];

	// 랜덤값을 생성하려면 엔진과 분포를 이용한다.
	default_random_engine dre;
	uniform_int_distribution<> uid;

	for (int i = 0; i < 100; ++i)
		a[i] = uid( dre );

	for (int i = 0; i < 100; ++i)
		cout << a[i] << "\t";

	// 가장 큰 값을 찾아 화면에 출력해 보자
	save();
}





-----------------------------------
Thu Aug 30 11:10:39 2018

-----------------------------------
/*
-----------------------------------------------
 2018.8.27 월56          월목     (1주 2일)

 random number
 자료형, 변수, 메모리
-----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;

int main()
{
	// 임의의 값(random)을 갖는 정수 100개를 만들어 보자
	int a[100];

	// 랜덤값을 생성하려면 엔진과 분포를 이용한다.
	default_random_engine dre;
	uniform_int_distribution<> uid(0,1000);

	for (int i = 0; i < 100; ++i)
		a[i] = uid( dre );

	for (int i = 0; i < 100; ++i)
		cout << a[i] << "\t";

	// 가장 큰 값을 찾아 화면에 출력해 보자
	save();
}





-----------------------------------
Thu Aug 30 11:12:33 2018

-----------------------------------
/*
-----------------------------------------------
 2018.8.27 월56          월목     (1주 2일)

 random number
 자료형, 변수, 메모리
-----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;

int main()
{
	// 임의의 값(random)을 갖는 정수 100개를 만들어 보자
	int a[100];

	// 랜덤값을 생성하려면 엔진과 분포를 이용한다.
	default_random_engine dre;
	uniform_int_distribution<> uid(0,1000);

	for (int i = 0; i < 100; ++i)
		a[i] = uid( dre );

	for (int i = 0; i < 100; ++i)
		cout << a[i] << "\t";

	// 가장 큰 값을 찾아 화면에 출력해 보자
	save();
}





-----------------------------------
Thu Aug 30 11:14:46 2018

-----------------------------------
/*
-----------------------------------------------
 2018.8.27 월56          월목     (1주 2일)

 random number
 자료형, 변수, 메모리
-----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;

int main()
{
	// 임의의 값(random)을 갖는 정수 100개를 만들어 보자
	int a[100];

	// 랜덤값을 생성하려면 엔진과 분포를 이용한다.
	random_device rd;
	default_random_engine dre( rd() );
	uniform_int_distribution<> uid(0,1000);

	for (int i = 0; i < 100; ++i)
		a[i] = uid( dre );

	for (int i = 0; i < 100; ++i)
		cout << a[i] << "\t";

	// 가장 큰 값을 찾아 화면에 출력해 보자
	save();
}





-----------------------------------
Thu Aug 30 11:14:52 2018

-----------------------------------
/*
-----------------------------------------------
 2018.8.27 월56          월목     (1주 2일)

 random number
 자료형, 변수, 메모리
-----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;

int main()
{
	// 임의의 값(random)을 갖는 정수 100개를 만들어 보자
	int a[100];

	// 랜덤값을 생성하려면 엔진과 분포를 이용한다.
	random_device rd;
	default_random_engine dre( rd() );
	uniform_int_distribution<> uid(0,1000);

	for (int i = 0; i < 100; ++i)
		a[i] = uid( dre );

	for (int i = 0; i < 100; ++i)
		cout << a[i] << "\t";

	// 가장 큰 값을 찾아 화면에 출력해 보자
	save();
}





-----------------------------------
Thu Aug 30 11:20:14 2018

-----------------------------------
/*
-----------------------------------------------
 2018.8.27 월56          월목     (1주 2일)

 random number


 다음시간 - range based for loop,프로그램의 유지보수
 앞으로-자료형, 변수, 메모리
-----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;

int main()
{
	// 임의의 값(random)을 갖는 정수 100개를 만들어 보자
	int a[100];

	// 랜덤값을 생성하려면 엔진과 분포를 이용한다.
	default_random_engine dre;
	uniform_int_distribution<> uid(0,1000);

	for (int i = 0; i < 100; ++i)
		a[i] = uid( dre );

	for (int i = 0; i < 100; ++i)
		cout << a[i] << "\t";

	// 가장 큰 값을 찾아 화면에 출력해 보자
	save();
}





-----------------------------------
Mon Sep  3 13:40:21 2018

-----------------------------------
/*
-----------------------------------------------
 2018.9.3 월56          월목     (1주 2일)

 random number


 다음시간 - range based for loop,프로그램의 유지보수
 앞으로-자료형, 변수, 메모리
-----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;

int main()
{
	// 임의의 값(random)을 갖는 정수 100개를 만들어 보자
	int a[100];

	// 랜덤값을 생성하려면 엔진과 분포를 이용한다.
	default_random_engine dre;
	uniform_int_distribution<> uid(0,1000);

	//for (int i = 0; i < 100; ++i)
		//a[i] = uid(dre);
	// & - c++ reference를 의미함

	for (int d : a)			//범위기반의 for-loop
		d = uid( dre );

	for (int i = 0; i < 100; ++i)
		cout << a[i] << "\t";

	// 가장 큰 값을 찾아 화면에 출력해 보자
	save();
}





-----------------------------------
Mon Sep  3 13:42:11 2018

-----------------------------------
/*
-----------------------------------------------
 2018.9.3 월56          월목     (1주 2일)

 random number


 다음시간 - range based for loop,프로그램의 유지보수
 앞으로-자료형, 변수, 메모리
-----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;

int main()
{
	// 임의의 값(random)을 갖는 정수 n개를 만들어 보자
	int a[100];

	// 랜덤값을 생성하려면 엔진과 분포를 이용한다.
	default_random_engine dre;
	uniform_int_distribution<> uid(0,1000);

	//for (int i = 0; i < 100; ++i)
		//a[i] = uid(dre);
	// & - c++ reference를 의미함

	for (int d : a)			//범위기반의 for-loop
		d = uid( dre );

	for (int d : a)
		cout << d << "\t";

	// 가장 큰 값을 찾아 화면에 출력해 보자


	save();
}





-----------------------------------
Mon Sep  3 13:42:31 2018

-----------------------------------
/*
-----------------------------------------------
 2018.9.3 월56          월목     (1주 2일)

 random number


 다음시간 - range based for loop,프로그램의 유지보수
 앞으로-자료형, 변수, 메모리
-----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;

int main()
{
	// 임의의 값(random)을 갖는 정수 n개를 만들어 보자
	int a[100];

	// 랜덤값을 생성하려면 엔진과 분포를 이용한다.
	default_random_engine dre;
	uniform_int_distribution<> uid(0,1000);

	//for (int i = 0; i < 100; ++i)
		//a[i] = uid(dre);
	// & - c++ reference를 의미함

	for (int &d : a)			//범위기반의 for-loop
		d = uid( dre );

	for (int d : a)
		cout << d << "\t";

	// 가장 큰 값을 찾아 화면에 출력해 보자


	save();
}





-----------------------------------
Mon Sep  3 13:42:55 2018

-----------------------------------
/*
-----------------------------------------------
 2018.9.3 월56          월목     (1주 2일)

 random number


 다음시간 - range based for loop,프로그램의 유지보수
 앞으로-자료형, 변수, 메모리
-----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;

int main()
{
	// 임의의 값(random)을 갖는 정수 n개를 만들어 보자
	int a[10];

	// 랜덤값을 생성하려면 엔진과 분포를 이용한다.
	default_random_engine dre;
	uniform_int_distribution<> uid(0,1000);

	//for (int i = 0; i < 100; ++i)
		//a[i] = uid(dre);
	// & - c++ reference를 의미함

	for (int &d : a)			//범위기반의 for-loop
		d = uid( dre );

	for (int d : a)
		cout << d << "\t";

	// 가장 큰 값을 찾아 화면에 출력해 보자



	save();
}





-----------------------------------
Mon Sep  3 13:53:35 2018

-----------------------------------
/*
-----------------------------------------------
 2018.9.3 월56          월목     (1주 2일)

 random number


 다음시간 - range based for loop,프로그램의 유지보수
 앞으로-자료형, 변수, 메모리
-----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;

int main()
{
	// 임의의 값(random)을 갖는 정수 n개를 만들어 보자
	int a[10];

	// 랜덤값을 생성하려면 엔진과 분포를 이용한다.
	default_random_engine dre;
	uniform_int_distribution<> uid(0,1000);

	//for (int i = 0; i < 100; ++i)
		//a[i] = uid(dre);
	// & - c++ reference를 의미함

	for (int &d : a)			//범위기반의 for-loop
		d = uid( dre );

	for (int d : a)
		cout << d << "\t";

	// 가장 큰 값을 찾아 화면에 출력해 보자 ★
	int max = 0;
	
	for (int d : a)
		if (max < d)
			max = d;

	cout << "최대값은" << max << "입니다" << endl;

	save();
}





-----------------------------------
Mon Sep  3 13:56:56 2018

-----------------------------------
/*
-----------------------------------------------
 2018.9.3 월56          월목     (1주 2일)

 자료형, 변수, 메모리, reference &의 의미
-----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;

int main()
{
	//[문제]a와 b의 값을 서로 교환하여 출력하라
	int a{ 20 }, b{ 18 };

	//여기에 교환하는 코드를 적을 것
	int n;
	n = a;
	a = b;
	b = n;

	cout << a << "," << b << endl;

	save();
}





-----------------------------------
Mon Sep  3 13:58:37 2018

-----------------------------------
/*
-----------------------------------------------
 2018.9.3 월56          월목     (1주 2일)

 자료형, 변수, 메모리, reference &의 의미
-----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;

int main()
{
	//[문제]a와 b의 값을 서로 교환하여 출력하라
	int a{ 20 }, b{ 18 };

	//여기에 교환하는 코드를 적을 것
	int temp{ a };
	a = b;
	b = temp;

	cout << a << "," << b << endl;

	save();
}





-----------------------------------
Mon Sep  3 14:13:43 2018

-----------------------------------
/*
-----------------------------------------------
 2018.9.3 월56          월목     (1주 2일)

 자료형, 변수, 메모리, reference &의 의미
-----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;

void mySwap(int*, int*);

void mySwap(int* x, int* y)
{
	int temp = *x;
	*x = *y;
	*y = temp;
}

int main()
{
	//[문제]a와 b의 값을 서로 교환하여 출력하라
	int a{ 20 }, b{ 18 };

	//여기에 교환하는 함수를 호출하여 문제를 해결하라

	mySwap(&a,&b);

	cout << a << "," << b << endl;

	save();
}





-----------------------------------
Mon Sep  3 14:48:18 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.3 월56          월목     (1주 2일)

 자료형, 변수, 메모리
 reference &의 의미
 
 -----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;

int aaa = 333;			//DATA segment

int main()				//CODE segment
{
	// 변수 - 지역변수, 전역변수 
	//(life time)(memory location)
	int max = 123;		//STACK segment
	save();
}





-----------------------------------
Thu Sep  6 09:44:08 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 reference &의 의미
	-*를 쓰기 쉽게한 것
		&는 변수에 붙인 별명(alias)
	 
 -----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;
void mySwap(int&, int&);

void mySwap(int& x, int& y)
{
	int temp = x;
	x = y;
	y = temp;
}
int main()
{
	int a[]{ 2,4,6,8,10,1,3,5,7,9 };
	//[문제] a를 오름차순 정렬한 후 출력하라
	//for loop를 사용
	for (int i = 0; i < 9; ++i)
		if (a[i] < a[i + 1]) {
			mySwap(a[i], a[i + 1]);
		}

	
	save();
}






-----------------------------------
Thu Sep  6 09:45:20 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 reference &의 의미
	-*를 쓰기 쉽게한 것
		&는 변수에 붙인 별명(alias)
	 
 -----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;
void mySwap(int&, int&);

void mySwap(int& x, int& y)
{
	int temp = x;
	x = y;
	y = temp;
}
int main()
{
	int a[]{ 2,4,6,8,10,1,3,5,7,9 };
	//[문제] a를 오름차순 정렬한 후 출력하라
	//for loop를 사용
	for (int i = 0; i < 9; ++i)
		if (a[i] < a[i + 1]) {
			mySwap(a[i], a[i + 1]);
		}

	for (int d : a)
		cout << d << ' ';
	cout << endl;
	
	save();
}






-----------------------------------
Thu Sep  6 09:45:45 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 reference &의 의미
	-*를 쓰기 쉽게한 것
		&는 변수에 붙인 별명(alias)
	 
 -----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;
void mySwap(int&, int&);

void mySwap(int& x, int& y)
{
	int temp = x;
	x = y;
	y = temp;
}
int main()
{
	int a[]{ 2,4,6,8,10,1,3,5,7,9 };
	//[문제] a를 오름차순 정렬한 후 출력하라
	//for loop를 사용
	for (int i = 0; i < 9; ++i)
		if (a[i] > a[i + 1]) {
			mySwap(a[i], a[i + 1]);
		}

	for (int d : a)
		cout << d << ' ';
	cout << endl;
	
	save();
}






-----------------------------------
Thu Sep  6 09:46:40 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 reference &의 의미
	-*를 쓰기 쉽게한 것
		&는 변수에 붙인 별명(alias)
	 
 -----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;
void mySwap(int&, int&);

void mySwap(int& x, int& y)
{
	int temp = x;
	x = y;
	y = temp;
}
int main()
{
	int a[]{ 2,4,6,8,10,1,3,5,7,9 };
	//[문제] a를 오름차순 정렬한 후 출력하라
	//for loop를 사용

	for (int i = 0; i < 9; ++i)
		if (a[i] > a[i + 1]) {
			mySwap(a[i], a[i + 1]);
		}

	for (int d : a)
		cout << d << ' ';
	cout << endl;
	
	save();
}






-----------------------------------
Thu Sep  6 09:49:50 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 reference &의 의미
	-*를 쓰기 쉽게한 것
		&는 변수에 붙인 별명(alias)
	 
 -----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;
void mySwap(int&, int&);

void mySwap(int& x, int& y)
{
	int temp = x;
	x = y;
	y = temp;
}
int main()
{
	int a[]{ 2,4,6,8,10,1,3,5,7,9 };
	//[문제] a를 오름차순 정렬한 후 출력하라
	//for loop를 사용
	for (int n = 9; n > 0; --n) {
		for (int i = 0; i < n; ++i)
			if (a[i] > a[i + 1]) {
				mySwap(a[i], a[i + 1]);
			}
	}
	for (int d : a)
		cout << d << ' ';
	cout << endl;
	
	save();
}






-----------------------------------
Thu Sep  6 09:51:18 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 reference &의 의미
	-*를 쓰기 쉽게한 것
		&는 변수에 붙인 별명(alias)
	 
 -----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;
void mySwap(int&, int&);

void mySwap(int& x, int& y)
{
	int temp = x;
	x = y;
	y = temp;
}
int main()
{
	int a[]{ 2,4,6,8,10,1,3,5,7,9 };
	//[문제] a를 오름차순 정렬한 후 출력하라
	//for loop를 사용
	for (int n = 0; n < 9; ++n) {
		for (int i = 0; i < 9; ++i)
			if (a[i] > a[i + 1]) {
				mySwap(a[i], a[i + 1]);
			}
	}
	for (int d : a)
		cout << d << ' ';
	cout << endl;
	
	save();
}






-----------------------------------
Thu Sep  6 09:51:43 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 reference &의 의미
	-*를 쓰기 쉽게한 것
		&는 변수에 붙인 별명(alias)
	 
 -----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;
void mySwap(int&, int&);

void mySwap(int& x, int& y)
{
	int temp = x;
	x = y;
	y = temp;
}
int main()
{
	int a[]{ 2,4,6,8,10,1,3,5,7,9 };
	//[문제] a를 오름차순 정렬한 후 출력하라
	//for loop를 사용
	for (int n = 9; n >0; --n) {
		for (int i = 0; i < n; ++i)
			if (a[i] > a[i + 1]) {
				mySwap(a[i], a[i + 1]);
			}
	}
	for (int d : a)
		cout << d << ' ';
	cout << endl;
	
	save();
}






-----------------------------------
Thu Sep  6 09:52:37 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 reference &의 의미
	-*를 쓰기 쉽게한 것
		&는 변수에 붙인 별명(alias)
	 
 -----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;
void mySwap(int&, int&);

void mySwap(int& x, int& y)
{
	int temp = x;
	x = y;
	y = temp;
}
int main()
{
	int a[]{ 2,4,6,8,10,1,3,5,7,9 };
	//[문제] a를 오름차순 정렬한 후 출력하라
	//for loop를 사용
	for (int n = 9; n >0; --n) {
		for (int i = 0; i < n; ++i)
			if (a[i] > a[i + 1]) {
				mySwap(a[i], a[i + 1]);
			}
	}
	for (int d : a)
		cout << d << ' ';
	cout << endl;
	
	save();
}






-----------------------------------
Thu Sep  6 09:53:16 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 reference &의 의미
	-*를 쓰기 쉽게한 것
		&는 변수에 붙인 별명(alias)
	 
 -----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;
void mySwap(int&, int&);

void mySwap(int& x, int& y)
{
	int temp = x;
	x = y;
	y = temp;
}
int main()
{
	int a[]{ 2,4,6,8,10,1,3,5,7,9 };
	//[문제] a를 오름차순 정렬한 후 출력하라
	//for loop를 사용
	for (int d : a)
		cout <<"출력하기전"<< d ;
	cout << endl;

	for (int n = 9; n >0; --n) {
		for (int i = 0; i < n; ++i)
			if (a[i] > a[i + 1]) {
				mySwap(a[i], a[i + 1]);
			}
	}
	for (int d : a)
		cout << d << ' ';
	cout << endl;
	
	save();
}






-----------------------------------
Thu Sep  6 09:53:47 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 reference &의 의미
	-*를 쓰기 쉽게한 것
		&는 변수에 붙인 별명(alias)
	 
 -----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;
void mySwap(int&, int&);

void mySwap(int& x, int& y)
{
	int temp = x;
	x = y;
	y = temp;
}
int main()
{
	int a[]{ 2,4,6,8,10,1,3,5,7,9 };
	//[문제] a를 오름차순 정렬한 후 출력하라
	//for loop를 사용
	cout << "출력하기전";
	for (int d : a)
		cout << d ;
	cout << endl;

	for (int n = 9; n >0; --n) {
		for (int i = 0; i < n; ++i)
			if (a[i] > a[i + 1]) {
				mySwap(a[i], a[i + 1]);
			}
	}
	for (int d : a)
		cout << d << ' ';
	cout << endl;
	
	save();
}






-----------------------------------
Thu Sep  6 09:53:59 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 reference &의 의미
	-*를 쓰기 쉽게한 것
		&는 변수에 붙인 별명(alias)
	 
 -----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;
void mySwap(int&, int&);

void mySwap(int& x, int& y)
{
	int temp = x;
	x = y;
	y = temp;
}
int main()
{
	int a[]{ 2,4,6,8,10,1,3,5,7,9 };
	//[문제] a를 오름차순 정렬한 후 출력하라
	//for loop를 사용
	cout << "출력하기전"<<' ';
	for (int d : a)
		cout << d ;
	cout << endl;

	for (int n = 9; n >0; --n) {
		for (int i = 0; i < n; ++i)
			if (a[i] > a[i + 1]) {
				mySwap(a[i], a[i + 1]);
			}
	}
	for (int d : a)
		cout << d << ' ';
	cout << endl;
	
	save();
}






-----------------------------------
Thu Sep  6 09:58:51 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 reference &의 의미
	-*를 쓰기 쉽게한 것
		&는 변수에 붙인 별명(alias)
	 
 -----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;
void mySwap(int&, int&);

void mySwap(int& x, int& y)
{
	int temp = x;
	x = y;
	y = temp;
}
int main()
{
	int a[]{ 2,4,6,8,10,1,3,5,7,9 };
	//[문제] a를 오름차순 정렬한 후 출력하라
	//for loop를 사용
	cout << "출력하기전"<<endl;
	for (int d : a)
		cout << d ;
	cout << endl;

	for (int n = 9; n >0; --n) {
		for (int i = 0; i < n; ++i)
			if (a[i] > a[i + 1]) {
				mySwap(a[i], a[i + 1]);
			}
	}
	for (int d : a)
		cout << d << ' ';
	cout << endl;
	
	save();
}




-----------------------------------
Thu Sep  6 09:59:33 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 reference &의 의미
	-*를 쓰기 쉽게한 것
		&는 변수에 붙인 별명(alias)
	 
 -----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;
void mySwap(int&, int&);

void mySwap(int& x, int& y)
{
	int temp = x;
	x = y;
	y = temp;
}
int main()
{
	int a[]{ 2,4,6,8,10,1,3,5,7,9 };
	//[문제] a를 오름차순 정렬한 후 출력하라
	//for loop를 사용
	cout << "출력하기전"<<endl;
	for (int d : a)
		cout << d <<' ';
	cout << endl;

	for (int n = 9; n >0; --n) {
		for (int i = 0; i < n; ++i)
			if (a[i] > a[i + 1]) {
				mySwap(a[i], a[i + 1]);
			}
	}
	cout << "정렬한 후 " << endl;
	for (int d : a)
		cout << d << ' ';
	cout << endl;
	
	save();
}






-----------------------------------
Thu Sep  6 10:07:49 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 reference &의 의미
	-*를 쓰기 쉽게한 것
		&는 변수에 붙인 별명(alias)
	 
 -----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;
void mySwap(int&, int&);

void mySwap(int& x, int& y)
{
	int temp = x;
	x = y;
	y = temp;
}
int main()
{
	// [문제] 정수 1000개를 (0~10000까지) 임의의 값으로 설정하자
	// 오름차순으로 정수 1000개를 정렬하라
	// 가장 큰 값을 찾아 화면에 출력하라.
	int a[1000];

	default_random_engine dre;
	uniform_int_distribution<> uid(0, 10000);

	for (int j = 1000 - 1; j > 0; --j) {
		for (int i = 0; i < 1000 - j; ++i) {
			if (a[i] > a[i + 1]) {
				mySwap(a[i], a[i + 1]);
			}
		}
	}
	cout << "오름차순 정렬" << endl;
	for (int d : a) {
		cout << d << ' ';
	}
		cout << "가장 큰 값 : " << a[999] << endl;


	save();
}






-----------------------------------
Thu Sep  6 10:08:33 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 reference &의 의미
	-*를 쓰기 쉽게한 것
		&는 변수에 붙인 별명(alias)
	 
 -----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;
void mySwap(int&, int&);

void mySwap(int& x, int& y)
{
	int temp = x;
	x = y;
	y = temp;
}
int main()
{
	// [문제] 정수 1000개를 (0~10000까지) 임의의 값으로 설정하자
	// 오름차순으로 정수 1000개를 정렬하라
	// 가장 큰 값을 찾아 화면에 출력하라.
	int a[1000];

	default_random_engine dre;
	uniform_int_distribution<> uid(0, 10000);

	for (int i = 0; i < 1000; ++i)
		a[i] = uid(dre);

	for (int j = 1000 - 1; j > 0; --j) {
		for (int i = 0; i < 1000 - j; ++i) {
			if (a[i] > a[i + 1]) {
				mySwap(a[i], a[i + 1]);
			}
		}
	}
	cout << "오름차순 정렬" << endl;
	for (int d : a) {
		cout << d << ' ';
	}
		cout << "가장 큰 값 : " << a[999] << endl;


	save();
}






-----------------------------------
Thu Sep  6 10:09:28 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 reference &의 의미
	-*를 쓰기 쉽게한 것
		&는 변수에 붙인 별명(alias)
	 
 -----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;
void mySwap(int&, int&);

void mySwap(int& x, int& y)
{
	int temp = x;
	x = y;
	y = temp;
}
int main()
{
	// [문제] 정수 1000개를 (0~10000까지) 임의의 값으로 설정하자
	// 오름차순으로 정수 1000개를 정렬하라
	// 가장 큰 값을 찾아 화면에 출력하라.
	int a[1000];

	default_random_engine dre;
	uniform_int_distribution<> uid(0, 10000);

	for (int i = 0; i < 1000; ++i)
		a[i] = uid(dre);

	for (int j = 1000 - 1; j > 0; --j) {
		for (int i = 0; i < 1000 - j; ++i) {
			if (a[i] > a[i + 1]) {
				mySwap(a[i], a[i + 1]);
			}
		}
	}
	cout << "오름차순 정렬" << endl;
	for (int d : a) {
		cout << d << "\t";
	}
		cout << "가장 큰 값 : " << a[999] << endl;


	save();
}






-----------------------------------
Thu Sep  6 10:10:59 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 reference &의 의미
	-*를 쓰기 쉽게한 것
		&는 변수에 붙인 별명(alias)
	 
 -----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;
void mySwap(int&, int&);

void mySwap(int& x, int& y)
{
	int temp = x;
	x = y;
	y = temp;
}
int main()
{
	// [문제] 정수 1000개를 (0~10000까지) 임의의 값으로 설정하자
	// 오름차순으로 정수 1000개를 정렬하라
	// 가장 큰 값을 찾아 화면에 출력하라.
	int a[1000];

	default_random_engine dre;
	uniform_int_distribution<> uid(0, 10000);

	for (int i = 0; i < 1000; ++i)
		a[i] = uid(dre);

	for (int j = 1000 - 1; j > 0; --j) {
		for (int i = 0; i < j; ++i) {
			if (a[i] > a[i + 1]) {
				mySwap(a[i], a[i + 1]);
			}
		}
	}
	cout << "오름차순 정렬" << endl;
	for (int d : a) {
		cout << d << "\t";
	}
	cout << endl;
	cout << "가장 큰 값 : " << a[999] << endl;


	save();
}






-----------------------------------
Thu Sep  6 10:16:02 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 reference &의 의미
	-*를 쓰기 쉽게한 것
		&는 변수에 붙인 별명(alias)
	 
 -----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;
void mySwap(int&, int&);

void mySwap(int& x, int& y)
{
	int temp = x;
	x = y;
	y = temp;
}
int main()
{
	// [문제] 정수 1000개를 (0~10000까지) 임의의 값으로 설정하자
	// 오름차순으로 정수 1000개를 정렬하라
	// 가장 큰 값을 찾아 화면에 출력하라.
	int a[1000];

	default_random_engine dre;
	uniform_int_distribution<> uid(0, 10000);

	for (int& d : a)
		d = uid(dre);

	for (int j = 1000 - 1; j > 0; --j) {
		for (int i = 0; i < j; ++i) {
			if (a[i] > a[i + 1]) {
				mySwap(a[i], a[i + 1]);
			}
		}
	}
	cout << "오름차순 정렬" << endl;
	for (int d : a) {
		cout << d << "\t";
	}
	cout << endl;
	cout << "가장 큰 값 : " << a[999] << endl;


	save();
}






-----------------------------------
Thu Sep  6 10:17:43 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 reference &의 의미
	-*를 쓰기 쉽게한 것
		&는 변수에 붙인 별명(alias)
	 
 -----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;
void mySwap(int&, int&);

void mySwap(int& x, int& y)
{
	int temp = x;
	x = y;
	y = temp;
}

const int NUM{ 1000 };

int main()
{
	// [문제] 정수 1000개를 (0~10000까지) 임의의 값으로 설정하자
	// 오름차순으로 정수 1000개를 정렬하라
	// 가장 큰 값을 찾아 화면에 출력하라.
	int a[NUM];

	default_random_engine dre;
	uniform_int_distribution<> uid(0, 10000);

	for (int& d : a)
		d = uid(dre);

	for (int j = NUM - 1; j > 0; --j) {
		for (int i = 0; i < j; ++i) {
			if (a[i] > a[i + 1]) {
				mySwap(a[i], a[i + 1]);
			}
		}
	}
	cout << "오름차순 정렬" << endl;
	for (int d : a) {
		cout << d << "\t";
	}
	cout << endl;
	cout << "가장 큰 값 : " << a[NUM-1] << endl;


	save();
}






-----------------------------------
Thu Sep  6 10:20:54 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 reference &의 의미
	-*를 쓰기 쉽게한 것
		&는 변수에 붙인 별명(alias)
	 
 -----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;
void mySwap(int&, int&);

void mySwap(int& x, int& y)
{
	int temp = x;
	x = y;
	y = temp;
}

const int NUM{ 1000 };

int main()
{
	// [문제] 정수 1000개를 (0~10000까지) 임의의 값으로 설정하자
	// 오름차순으로 정수 1000개를 정렬하라
	// 가장 큰 값을 찾아 화면에 출력하라.
	int a[NUM];

	default_random_engine dre;
	uniform_int_distribution<> uid(0, 10000);

	for (int d : a)
		d = uid(dre);

	for (int j = NUM - 1; j > 0; --j) {
		for (int i = 0; i < j; ++i) {
			if (a[i] > a[i + 1]) {
				mySwap(a[i], a[i + 1]);
			}
		}
	}
	cout << "오름차순 정렬" << endl;
	for (int d : a) {
		cout << d << "\t";
	}
	cout << endl;
	cout << "가장 큰 값 : " << a[NUM-1] << endl;


	save();
}






-----------------------------------
Thu Sep  6 10:21:02 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 reference &의 의미
	-*를 쓰기 쉽게한 것
		&는 변수에 붙인 별명(alias)
	 
 -----------------------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"

using namespace std;
void mySwap(int&, int&);

void mySwap(int& x, int& y)
{
	int temp = x;
	x = y;
	y = temp;
}

const int NUM{ 1000 };

int main()
{
	// [문제] 정수 1000개를 (0~10000까지) 임의의 값으로 설정하자
	// 오름차순으로 정수 1000개를 정렬하라
	// 가장 큰 값을 찾아 화면에 출력하라.
	int a[NUM];

	default_random_engine dre;
	uniform_int_distribution<> uid(0, 10000);

	for (int& d : a)
		d = uid(dre);

	for (int j = NUM - 1; j > 0; --j) {
		for (int i = 0; i < j; ++i) {
			if (a[i] > a[i + 1]) {
				mySwap(a[i], a[i + 1]);
			}
		}
	}
	cout << "오름차순 정렬" << endl;
	for (int d : a) {
		cout << d << "\t";
	}
	cout << endl;
	cout << "가장 큰 값 : " << a[NUM-1] << endl;


	save();
}






-----------------------------------
Thu Sep  6 10:57:14 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 
 진짜 정렬하는 방법 - quick sort 알고리즘 (358쪽)
  C언어에서는 - qsort();
  C++에서는 - sort();
 -----------------------------------------------
*/

#include <iostream>
#include "save.h"


using namespace std;


int comp(const void*, const void*);

int comp(const void* p, const void* q)
{
	//cosnt - 이주소의 값은 읽기만 가능
	//void - 이 자료형이 뭔지는 니가 알테니 마음대로 변환하라
	int* a = (int*)p;
	int* b = (int*)q;

	//qsort 알고리즘 관찰
	cout << *a << "---" << *b << "비교" << endl;
	if (*a > *b)
		return 1;
	else if (*a == *b)
		return 0;
	else
		return -1;

}



int main()
{
	int a[10]{ 1,3,5,7,9,2,4,6,8,10 };
	//qsort(어떤걸?,몇개?,한개의 크기?,어떻게?);
	
	
	qsort(&a[0],10,4,comp);
	
	save();
}






-----------------------------------
Thu Sep  6 10:59:16 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 
 진짜 정렬하는 방법 - quick sort 알고리즘 (358쪽)
  C언어에서는 - qsort();
  C++에서는 - sort();
 -----------------------------------------------
*/

#include <iostream>
#include "save.h"


using namespace std;


int comp(const void*, const void*);

int comp(const void* p, const void* q)
{
	//cosnt - 이주소의 값은 읽기만 가능
	//void - 이 자료형이 뭔지는 니가 알테니 마음대로 변환하라
	int* a = (int*)p;
	int* b = (int*)q;

	//qsort 알고리즘 관찰
	cout << *a << "---" << *b << "비교" << endl;
	if (*a > *b)
		return 1;
	else if (*a == *b)
		return 0;
	else
		return -1;

}



int main()
{
	int a[10]{ 1,3,5,7,9,2,4,6,8,10 };
	//qsort(어떤걸?,몇개?,한개의 크기?,어떻게?);
	
	//int (*f)(const void*,const void*)= comp; -> comp대신 f 써도 가능
	
	qsort(&a[0],10,4,comp);
	
	for (int d : a) {
		cout << d << "\t" << endl;
	}

	save();
}






-----------------------------------
Thu Sep  6 10:59:35 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 
 진짜 정렬하는 방법 - quick sort 알고리즘 (358쪽)
  C언어에서는 - qsort();
  C++에서는 - sort();
 -----------------------------------------------
*/

#include <iostream>
#include "save.h"


using namespace std;


int comp(const void*, const void*);

int comp(const void* p, const void* q)
{
	//cosnt - 이주소의 값은 읽기만 가능
	//void - 이 자료형이 뭔지는 니가 알테니 마음대로 변환하라
	int* a = (int*)p;
	int* b = (int*)q;

	//qsort 알고리즘 관찰
	cout << *a << "---" << *b << "비교" << endl;
	if (*a > *b)
		return 1;
	else if (*a == *b)
		return 0;
	else
		return -1;

}



int main()
{
	int a[10]{ 1,3,5,7,9,2,4,6,8,10 };
	//qsort(어떤걸?,몇개?,한개의 크기?,어떻게?);
	
	//int (*f)(const void*,const void*)= comp; -> comp대신 f 써도 가능
	
	qsort(&a[0],10,4,comp);
	
	for (int d : a) {
		cout << d << "\t";
	}

	save();
}






-----------------------------------
Thu Sep  6 10:59:49 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 
 진짜 정렬하는 방법 - quick sort 알고리즘 (358쪽)
  C언어에서는 - qsort();
  C++에서는 - sort();
 -----------------------------------------------
*/

#include <iostream>
#include "save.h"


using namespace std;


int comp(const void*, const void*);

int comp(const void* p, const void* q)
{
	//cosnt - 이주소의 값은 읽기만 가능
	//void - 이 자료형이 뭔지는 니가 알테니 마음대로 변환하라
	int* a = (int*)p;
	int* b = (int*)q;

	//qsort 알고리즘 관찰
	cout << *a << "---" << *b << "비교" << endl;
	if (*a > *b)
		return 1;
	else if (*a == *b)
		return 0;
	else
		return -1;

}



int main()
{
	int a[10]{ 1,3,5,7,9,2,4,6,8,10 };
	//qsort(어떤걸?,몇개?,한개의 크기?,어떻게?);
	
	//int (*f)(const void*,const void*)= comp; -> comp대신 f 써도 가능
	
	qsort(&a[0],10,4,comp);
	
	for (int d : a) {
		cout << d << "\t";
	}
	cout << endl;

	save();
}






-----------------------------------
Thu Sep  6 11:03:10 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 
 진짜 정렬하는 방법 - quick sort 알고리즘 (358쪽)
  C언어에서는 - qsort();
  C++에서는 - sort();
 -----------------------------------------------
*/

#include <iostream>
#include "save.h"


using namespace std;


int comp(const void*, const void*);

int comp(const void* p, const void* q)
{
	//cosnt - 이주소의 값은 읽기만 가능
	//void - 이 자료형이 뭔지는 니가 알테니 마음대로 변환하라
	int* a = (int*)p;
	int* b = (int*)q;

	//qsort 알고리즘 관찰
	cout << *a << "---" << *b << "비교" << endl;
	if (*a > *b)
		return 1;
	else if (*a == *b)
		return 0;
	else
		return -1;

}



int main()
{
	char a[] = "quick browm fox jumps over the layz dog";
	
	//qsort(어떤걸?,몇개?,한개의 크기?,어떻게?);
	
	//int (*f)(const void*,const void*)= comp; -> comp대신 f 써도 가능
	
	qsort(&a[0],10,1,comp);
	


	save();
}






-----------------------------------
Thu Sep  6 11:04:11 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 
 진짜 정렬하는 방법 - quick sort 알고리즘 (358쪽)
  C언어에서는 - qsort();
  C++에서는 - sort();
 -----------------------------------------------
*/

#include <iostream>
#include "save.h"


using namespace std;


int comp(const void*, const void*);

int comp(const void* p, const void* q)
{
	//cosnt - 이주소의 값은 읽기만 가능
	//void - 이 자료형이 뭔지는 니가 알테니 마음대로 변환하라
	char* a = (char*)p;
	char* b = (char*)q;

	//qsort 알고리즘 관찰
	cout << *a << "---" << *b << "비교" << endl;
	if (*a > *b)
		return 1;
	else if (*a == *b)
		return 0;
	else
		return -1;

}



int main()
{
	char a[] = "quick browm fox jumps over the layz dog";
	
	//qsort(어떤걸?,몇개?,한개의 크기?,어떻게?);
	
	//int (*f)(const void*,const void*)= comp; -> comp대신 f 써도 가능
	
	qsort(&a[0],10,1,comp);
	


	save();
}






-----------------------------------
Thu Sep  6 11:04:47 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 
 진짜 정렬하는 방법 - quick sort 알고리즘 (358쪽)
  C언어에서는 - qsort();
  C++에서는 - sort();
 -----------------------------------------------
*/

#include <iostream>
#include "save.h"


using namespace std;


int comp(const void*, const void*);

int comp(const void* p, const void* q)
{
	//cosnt - 이주소의 값은 읽기만 가능
	//void - 이 자료형이 뭔지는 니가 알테니 마음대로 변환하라
	char* a = (char*)p;
	char* b = (char*)q;

	//qsort 알고리즘 관찰
	cout << *a << "---" << *b << "비교" << endl;
	if (*a > *b)
		return 1;
	else if (*a == *b)
		return 0;
	else
		return -1;

}



int main()
{
	char a[] = "quick browm fox jumps over the layz dog";
	
	//qsort(어떤걸?,몇개?,한개의 크기?,어떻게?);
	
	//int (*f)(const void*,const void*)= comp; -> comp대신 f 써도 가능
	
	qsort(&a[0],10,1,comp);
	
	for (char d : a)
		cout << d << "\t";

	save();
}






-----------------------------------
Thu Sep  6 11:04:56 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 
 진짜 정렬하는 방법 - quick sort 알고리즘 (358쪽)
  C언어에서는 - qsort();
  C++에서는 - sort();
 -----------------------------------------------
*/

#include <iostream>
#include "save.h"


using namespace std;


int comp(const void*, const void*);

int comp(const void* p, const void* q)
{
	//cosnt - 이주소의 값은 읽기만 가능
	//void - 이 자료형이 뭔지는 니가 알테니 마음대로 변환하라
	char* a = (char*)p;
	char* b = (char*)q;

	//qsort 알고리즘 관찰
	cout << *a << "---" << *b << "비교" << endl;
	if (*a > *b)
		return 1;
	else if (*a == *b)
		return 0;
	else
		return -1;

}



int main()
{
	char a[] = "quick browm fox jumps over the layz dog";
	
	//qsort(어떤걸?,몇개?,한개의 크기?,어떻게?);
	
	//int (*f)(const void*,const void*)= comp; -> comp대신 f 써도 가능
	
	qsort(&a[0],10,1,comp);
	
	for (char d : a)
		cout << d;

	save();
}






-----------------------------------
Thu Sep  6 11:05:47 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 
 진짜 정렬하는 방법 - quick sort 알고리즘 (358쪽)
  C언어에서는 - qsort();
  C++에서는 - sort();
 -----------------------------------------------
*/

#include <iostream>
#include "save.h"


using namespace std;


int comp(const void*, const void*);

int comp(const void* p, const void* q)
{
	//cosnt - 이주소의 값은 읽기만 가능
	//void - 이 자료형이 뭔지는 니가 알테니 마음대로 변환하라
	char* a = (char*)p;
	char* b = (char*)q;

	//qsort 알고리즘 관찰
	cout << *a << "---" << *b << "비교" << endl;
	if (*a > *b)
		return 1;
	else if (*a == *b)
		return 0;
	else
		return -1;

}



int main()
{
	char a[] = "quick browm fox jumps over the layz dog";
	
	//qsort(어떤걸?,몇개?,한개의 크기?,어떻게?);
	
	//int (*f)(const void*,const void*)= comp; -> comp대신 f 써도 가능
	
	qsort(&a[0],39,1,comp);
	
	for (char d : a)
		cout << d;

	save();
}






-----------------------------------
Thu Sep  6 11:06:20 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 
 진짜 정렬하는 방법 - quick sort 알고리즘 (358쪽)
  C언어에서는 - qsort();
  C++에서는 - sort();
 -----------------------------------------------
*/

#include <iostream>
#include "save.h"


using namespace std;


int comp(const void*, const void*);

int comp(const void* p, const void* q)
{
	//cosnt - 이주소의 값은 읽기만 가능
	//void - 이 자료형이 뭔지는 니가 알테니 마음대로 변환하라
	char* a = (char*)p;
	char* b = (char*)q;

	//qsort 알고리즘 관찰
	cout << *a << "---" << *b << "비교" << endl;
	if (*a > *b)
		return 1;
	else if (*a == *b)
		return 0;
	else
		return -1;

}



int main()
{
	char a[] = "quick browm fox jumps over the layz dog";
	
	//qsort(어떤걸?,몇개?,한개의 크기?,어떻게?);
	
	//int (*f)(const void*,const void*)= comp; -> comp대신 f 써도 가능
	
	qsort(&a[0],39,1,comp);
	
	for (char d : a)
		cout << d;

	save();
}






-----------------------------------
Thu Sep  6 11:06:46 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 
 진짜 정렬하는 방법 - quick sort 알고리즘 (358쪽)
  C언어에서는 - qsort();
  C++에서는 - sort();
 -----------------------------------------------
*/

#include <iostream>
#include "save.h"


using namespace std;


int comp(const void*, const void*);

int comp(const void* p, const void* q)
{
	//cosnt - 이주소의 값은 읽기만 가능
	//void - 이 자료형이 뭔지는 니가 알테니 마음대로 변환하라
	char* a = (char*)p;
	char* b = (char*)q;

	//qsort 알고리즘 관찰
	cout << *a << "---" << *b << "비교" << endl;
	if (*a > *b)
		return 1;
	else if (*a == *b)
		return 0;
	else
		return -1;

}



int main()
{
	char a[] = "quick browm fox jumps over the layz dog";
	
	//qsort(어떤걸?,몇개?,한개의 크기?,어떻게?);
	
	//int (*f)(const void*,const void*)= comp; -> comp대신 f 써도 가능
	
	qsort(&a[0],39,1,comp);
	
	for (char d : a)
		cout << d;

	save();
}






-----------------------------------
Mon Sep 10 13:39:04 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 
 진짜 정렬하는 방법 - quick sort 알고리즘 (358쪽)
  C언어에서는 - qsort();
  C++에서는 - sort();
 -----------------------------------------------
*/

#include <iostream>
#include "save.h"


using namespace std;


int comp(const void*, const void*);

int comp(const void* p, const void* q)
{
	//cosnt - 이주소의 값은 읽기만 가능
	//void - 이 자료형이 뭔지는 니가 알테니 마음대로 변환하라
	char* a = (char*)p;
	char* b = (char*)q;

	//qsort 알고리즘 관찰
	cout << *a << "---" << *b << "비교" << endl;
	if (*a > *b)
		return 1;
	else if (*a == *b)
		return 0;
	else
		return -1;

}



int main()
{
	char a[] = "quick browm fox jumps over the layz dog";
	
	//qsort(어떤걸?,몇개?,한개의 크기?,어떻게?);
	
	//int (*f)(const void*,const void*)= comp; -> comp대신 f 써도 가능
	
	qsort(&a[0],39,1,comp);
	
	for (char d : a)
		cout << d;

	save();
}






-----------------------------------
Mon Sep 10 13:39:57 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.6 월56          월목     (2주 2일)
 &,const
 자료형, 변수, 메모리
 
 진짜 정렬하는 방법 - quick sort 알고리즘 (358쪽)
  C언어에서는 - qsort();
  C++에서는 - sort();
 -----------------------------------------------
*/

#include <iostream>
#include "save.h"


using namespace std;


int comp(const void*, const void*);

int comp(const void* p, const void* q)
{
	//cosnt - 이주소의 값은 읽기만 가능
	//void - 이 자료형이 뭔지는 니가 알테니 마음대로 변환하라
	char* a = (char*)p;
	char* b = (char*)q;

	//qsort 알고리즘 관찰
	cout << *a << "---" << *b << "비교" << endl;
	if (*a > *b)
		return 1;
	else if (*a == *b)
		return 0;
	else
		return -1;

}



int main()
{
	char a[] = "quick browm fox jumps over the layz dog";
	
	//qsort(어떤걸?,몇개?,한개의 크기?,어떻게?);
	
	//int (*f)(const void*,const void*)= comp; -> comp대신 f 써도 가능
	
	qsort(a,sizeof(a),1,comp);
	
	for (char d : a)
		cout << d;

	save();
}






-----------------------------------
Mon Sep 10 13:44:52 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.9		         월목     (3주 1일)
 qsort에서 comp 함수는 몇 번이나 불리나?
		(버블소트에서는 몇번이나 불리나?-n의 제곱)
 변수를 선언하고 만드는법
 변수가 저장되는 위치를 확인하자
 변수를 다른 곳에 저장하고 다시 읽어보자

 진짜 정렬하는 방법 - quick sort 알고리즘(358쪽)
 C-qsort();
 C++-sort();
 -----------------------------------------------
*/

#include <iostream>
#include "save.h"


using namespace std;


int comp(const void*, const void*);

int comp(const void* p, const void* q)
{
	//cosnt - 이주소의 값은 읽기만 가능
	//void - 이 자료형이 뭔지는 니가 알테니 마음대로 변환하라
	char* a = (char*)p;
	char* b = (char*)q;

	//qsort 알고리즘 관찰
	cout << *a << "---" << *b << "비교" << endl;
	if (*a > *b)
		return 1;
	else if (*a == *b)
		return 0;
	else
		return -1;

}



int main()
{
	char a[] = "quick browm fox jumps over the layz dog";
	
	//qsort(어떤걸?,몇개?,한개의 크기?,어떻게?);
	
	//int (*f)(const void*,const void*)= comp; -> comp대신 f 써도 가능
	
	qsort(a,sizeof(a),1,comp);
	
	cout << a << endl;

	save();
}






-----------------------------------
Mon Sep 10 13:45:12 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.9		         월목     (3주 1일)
 qsort에서 comp 함수는 몇 번이나 불리나?
		(버블소트에서는 몇번이나 불리나?-n의 제곱)
 변수를 선언하고 만드는법
 변수가 저장되는 위치를 확인하자
 변수를 다른 곳에 저장하고 다시 읽어보자

 진짜 정렬하는 방법 - quick sort 알고리즘(358쪽)
 C-qsort();
 C++-sort();
 -----------------------------------------------
*/

#include <iostream>
#include "save.h"


using namespace std;


int comp(const void*, const void*);

int comp(const void* p, const void* q)
{
	//cosnt - 이주소의 값은 읽기만 가능
	//void - 이 자료형이 뭔지는 니가 알테니 마음대로 변환하라
	char* a = (char*)p;
	char* b = (char*)q;

	//qsort 알고리즘 관찰
	cout << *a << "---" << *b << "비교" << endl;
	if (*a > *b)
		return 1;
	else if (*a == *b)
		return 0;
	else
		return -1;

}



int main()
{
	char a[] = "quick browm fox jumps over the layz dog";
	
	//qsort(어떤걸?,몇개?,한개의 크기?,어떻게?);
	
	//int (*f)(const void*,const void*)= comp; -> comp대신 f 써도 가능
	
	qsort(a,sizeof(a)-1,1,comp);
	
	cout << a << endl;

	save();
}






-----------------------------------
Mon Sep 10 13:48:29 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.9		         월목     (3주 1일)
 qsort에서 comp 함수는 몇 번이나 불리나?
		(버블소트에서는 몇번이나 불리나?-n의 제곱)
 변수를 선언하고 만드는법
 변수가 저장되는 위치를 확인하자
 변수를 다른 곳에 저장하고 다시 읽어보자

 진짜 정렬하는 방법 - quick sort 알고리즘(358쪽)
 C-qsort();
 C++-sort();
 -----------------------------------------------
*/

#include <iostream>
#include "save.h"


using namespace std;


int comp(const void*, const void*);
int comp(const void* p, const void* q)
{
	return *(char*)p - *(char*)q;
}



int main()
{
	char a[] = "quick browm fox jumps over the layz dog";

	//a가 오름차순 정렬되도록 qsort를 완성하라
	qsort(a,sizeof(a)-1,1,comp);
	
	cout << a << endl;

	save();
}






-----------------------------------
Mon Sep 10 13:49:26 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.9		         월목     (3주 1일)
 qsort에서 comp 함수는 몇 번이나 불리나?
		(버블소트에서는 몇번이나 불리나?-n의 제곱)
 변수를 선언하고 만드는법
 변수가 저장되는 위치를 확인하자
 변수를 다른 곳에 저장하고 다시 읽어보자

 진짜 정렬하는 방법 - quick sort 알고리즘(358쪽)
 C-qsort();
 C++-sort();
 -----------------------------------------------
*/

#include <iostream>
#include "save.h"


using namespace std;


int comp(const void*, const void*);
int comp(const void* p, const void* q)
{
	return *(char*)p - *(char*)q;
}



int main()
{
	char a[] = "quick browm fox jumps over the layz dog";

	//a가 오름차순 정렬되도록 qsort를 완성하라
	qsort(a,sizeof(a)-1,1,comp);
	
	cout << a << endl;

	save();
}






-----------------------------------
Mon Sep 10 13:54:48 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.9		         월목     (3주 1일)
 qsort에서 comp 함수는 몇 번이나 불리나?
		(버블소트에서는 몇번이나 불리나?-n의 제곱)
 
 
 변수를 선언하고 만드는법 (161쪽)
 변수가 저장되는 위치를 확인하자
 변수를 다른 곳에 저장하고 다시 읽어보자

 이 아래는 람다를 설명한 후에 하자
 C++에서는 qsort();
 -------------------------------
*/

#include <iostream>
#include "save.h"


using namespace std;

int main()
{
	int a = 10;	//초기화 (initialization)
	// 초기화 - 메모리를 확보함과 동시에 그 메모리의 값을 쓴다
	// RAII (찾아)

	a = 10; //이 문장은 초기화가 아니다(assignment)

	save();
}






-----------------------------------
Mon Sep 10 13:56:37 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.9		         월목     (3주 1일)
 qsort에서 comp 함수는 몇 번이나 불리나?
		(버블소트에서는 몇번이나 불리나?-n의 제곱)
 
 
 변수를 선언하고 만드는법 (161쪽)
 변수가 저장되는 위치를 확인하자
 변수를 다른 곳에 저장하고 다시 읽어보자

 이 아래는 람다를 설명한 후에 하자
 C++에서는 qsort();
 -------------------------------
*/

#include <iostream>
#include "save.h"


using namespace std;

int main()
{
	int a = 10;

	// a가 지역변수이다 - STACK에 만들어진다.

	//STACK이라는 메모리가 뭔지 알아보자 [숙제

	//STACK은 공간이 일정크기로 정해져있다.
	//STACK이라는 공간이 다 사용되면 어떻게 될까?(생각해보자)
	save();
}








-----------------------------------
Mon Sep 10 14:44:13 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.9		         월목     (3주 1일)
 qsort에서 comp 함수는 몇 번이나 불리나?
		(버블소트에서는 몇번이나 불리나?-n의 제곱)
 
 
 변수를 선언하고 만드는법 (161쪽)
 변수가 저장되는 위치를 확인하자
 변수를 다른 곳에 저장하고 다시 읽어보자

 이 아래는 람다를 설명한 후에 하자
 C++에서는 qsort();
 -------------------------------
*/

#include <iostream>
#include "save.h"
using namespace std;

//전역메모리 공간이다.
//실행파일에서 DATA segment라는 이름으로 공간이 잡힌다.

int a[10'0000]; //실행파일 크기가 실제 이만큼 커진다.

void f()
{
	static int i = 0;
	cout << ++i << endl;
	f();
}

int main()
{
	save();
}






-----------------------------------
Mon Sep 10 14:44:25 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.9		         월목     (3주 1일)
 qsort에서 comp 함수는 몇 번이나 불리나?
		(버블소트에서는 몇번이나 불리나?-n의 제곱)
 
 
 변수를 선언하고 만드는법 (161쪽)
 변수가 저장되는 위치를 확인하자
 변수를 다른 곳에 저장하고 다시 읽어보자

 이 아래는 람다를 설명한 후에 하자
 C++에서는 qsort();
 -------------------------------
*/

#include <iostream>
#include "save.h"
using namespace std;

//전역메모리 공간이다.
//실행파일에서 DATA segment라는 이름으로 공간이 잡힌다.

int a[10'0000]; //실행파일 크기가 실제 이만큼 커진다.

int main()
{
	save();
}


-----------------------------------
Mon Sep 10 14:47:19 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.9		         월목     (3주 1일)
 qsort에서 comp 함수는 몇 번이나 불리나?
		(버블소트에서는 몇번이나 불리나?-n의 제곱)
 
 
 변수를 선언하고 만드는법 (161쪽)
 변수가 저장되는 위치를 확인하자
 변수를 다른 곳에 저장하고 다시 읽어보자

 이 아래는 람다를 설명한 후에 하자
 C++에서는 qsort();
 -------------------------------
*/

#include <iostream>
#include "save.h"
using namespace std;

//전역메모리 공간이다.
//실행파일에서 DATA segment라는 이름으로 공간이 잡힌다.
int a[100000] = { 1 };//실행파일 크기가 실제 이만큼 커진다.

int main()
{
	save();
}






-----------------------------------
Thu Sep 13 09:38:16 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.13		         월목     (3주 2일)


 파일 읽고 쓰기
 -------------------------------
*/

#include <fstream>
#include <iostream>
#include <random>
#include "save.h"
using namespace std;




int main()
{
	// 정수 2개를 키보드에서 입력받아 합계를 출력하라
	int a, b;
	
	cin >> a;
	cin >> b;

	cout << a + b << endl;

	save();
}






-----------------------------------
Thu Sep 13 09:40:07 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.13		         월목     (3주 2일)


 파일 읽고 쓰기
 -------------------------------
*/

#include <fstream>
#include <iostream>
#include <random>
#include "save.h"
using namespace std;




int main()
{
	// 정수 2개를 키보드에서 입력받아 합계를 출력하라
	int a, b;
	
	cout << "첫번째 정수를 입력하시오";
	cin >> a;
	cout << "두번째 정수를 입력하시오";
	cin >> b;

	cout <<"합계는 "<< a + b << endl;

	save();
}





-----------------------------------
Thu Sep 13 09:44:18 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.13		         월목     (3주 2일)


 파일 읽고 쓰기
 -------------------------------
*/

#include <fstream>
#include <iostream>
#include <random>
#include "save.h"
using namespace std;




int main()
{
	// 정수 2개를 키보드에서 입력받아 합계를 출력하라
	int a, b;
	
	cout << "정수 두개를 입력하시오 : ";
	cin >> a >> b;

	cout <<"합계는 "<< a + b << endl;

	save();
}






-----------------------------------
Thu Sep 13 09:45:25 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.13		         월목     (3주 2일)


 파일 읽고 쓰기
 -------------------------------
*/

#include <fstream>
#include <iostream>
#include <random>
#include "save.h"
using namespace std;




int main()
{
	// 정수 2개를 키보드에서 입력받아 합계를 출력하라
	int a, b;
	
	cout << "정수 두개를 입력하시오 : ";
	cin >> a >> b;

	cout <<"합계는 "<< a + b << endl;

	save();
}






-----------------------------------
Thu Sep 13 09:46:32 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.13		         월목     (3주 2일)


 파일 읽고 쓰기
 -------------------------------
*/

#include <iostream>
#include <random>
#include "save.h"
using namespace std;




int main()
{
	// 정수 2개를 키보드에서 입력받아 합계를 출력하라
	int a, b;
	
	cout << "정수 두개를 입력하시오 : ";
	cin >> a >> b;

	cout <<"합계는 "<< a + b << endl;

	save();
}






-----------------------------------
Thu Sep 13 10:02:00 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.13		         월목     (3주 2일)


 파일 읽고 쓰기
 -------------------------------
*/

#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;




int main()
{
	// 정수 2개를 연습.txt 파일에서 입력받아 합계를 출력하라
	ifstream in("연습.txt");

	int a, b;
	
	cout << "파일에서 정수 2개를 읽어옵니다" << endl;
	in >> a >> b;
	cout <<"합계는 "<< a + b << endl;

	save();
}






-----------------------------------
Thu Sep 13 10:06:49 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.13		         월목     (3주 2일)


 파일 읽고 쓰기
 -------------------------------
*/

#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;




int main()
{
	//1부터 100까지의 정수 100개를 연습.txt에 저장하세요
	
	for (int i = 1; i <= 100; ++i) {
		cout << i << "\t";
	}


	//ofstream out("연습.txt");
	
	save();
}






-----------------------------------
Thu Sep 13 10:07:16 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.13		         월목     (3주 2일)


 파일 읽고 쓰기
 -------------------------------
*/

#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;




int main()
{
	//1부터 100까지의 정수 100개를 연습.txt에 저장하세요
	
	ofstream out("연습.txt");
	
	for (int i = 1; i <= 100; ++i) {
		out << i << "\t";
	}


	
	
	save();
}






-----------------------------------
Thu Sep 13 10:18:25 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.13		         월목     (3주 2일)


 파일 읽고 쓰기
 -------------------------------
*/

#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;




int main()
{
	//연습.txt 파일에서 정수 100개를 읽어와 합계와 평균값을 출력하라
	ifstream in("연습.txt");
	int a[100];
	
	for (int i = 0; i < 100; ++i) {
		in >> a[i];
	}

	int sum = 0;
	for (int d : a) {
		sum += d;
	}

	cout << " 합계는 " << sum << "평균은" << sum / 100. << endl;

	save();
}






-----------------------------------
Thu Sep 13 10:19:13 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.13		         월목     (3주 2일)


 파일 읽고 쓰기
 -------------------------------
*/

#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;




int main()
{
	//연습.txt 파일에서 정수 100개를 읽어와 합계와 평균값을 출력하라
	ifstream in("연습.txt");
	int sum = 0;

	int d;
	for (int i = 0; i < 100; ++i) {
		in >> d;
		sum += d;
	}

	cout << " 합계는 " << sum << "평균은" << sum / 100. << endl;

	save();
}






-----------------------------------
Thu Sep 13 10:19:24 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.13		         월목     (3주 2일)


 파일 읽고 쓰기
 -------------------------------
*/

#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;




int main()
{
	//연습.txt 파일에서 정수 100개를 읽어와 합계와 평균값을 출력하라
	ifstream in("연습.txt");
	int sum = 0;

	int d;
	for (int i = 0; i < 100; ++i) {
		in >> d;
		sum += d;
	}

	cout << " 합계는 " << sum << "평균은" << sum / 100 << endl;

	save();
}






-----------------------------------
Thu Sep 13 10:19:33 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.13		         월목     (3주 2일)


 파일 읽고 쓰기
 -------------------------------
*/

#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;




int main()
{
	//연습.txt 파일에서 정수 100개를 읽어와 합계와 평균값을 출력하라
	ifstream in("연습.txt");
	int sum = 0;

	int d;
	for (int i = 0; i < 100; ++i) {
		in >> d;
		sum += d;
	}

	cout << " 합계는 " << sum << "평균은" << sum / 100. << endl;

	save();
}






-----------------------------------
Thu Sep 13 10:41:53 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.13		         월목     (3주 2일)


 파일 읽고 쓰기
 -------------------------------
*/
#include <random>
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;




int main()
{
	//연습.txt 파일에 임의의 값을 갖는
	//정수 1000000개를 저장하라.
	//연습.txt 파일을 읽어 가장 큰 값을 화면에 출력하라
	
	ofstream out("연습.txt");
	
	default_random_engine dre;
	uniform_int_distribution<> uid;

	for (int i = 0; i < 1000000; ++i)
		out << uid(dre)<< ' ';


	save();
}




-----------------------------------
Thu Sep 13 10:51:29 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.13		         월목     (3주 2일)


 파일 읽고 쓰기
 -------------------------------
*/
#include <random>
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;




int main()
{
	//연습.txt 파일에 임의의 값을 갖는
	//정수 1000000개를 저장하라.
	//연습.txt 파일을 읽어 가장 큰 값을 화면에 출력하라
	
	ofstream out("연습.txt");
	
	default_random_engine dre;
	uniform_int_distribution<> uid;

	for (int i = 0; i < 1000000; ++i)
		out << uid(dre)<< ' ';

	out.close();

	ifstream in("연습.txt");
	
	
	int d;
	int max = 0;
	for (int i = 0; i < 1000000; ++i) {
		in >> d;
		if (d > max) {
			max = d;
		}
	}

	cout << "최대값은 " << max << endl;
	save();
}






-----------------------------------
Thu Sep 13 11:07:25 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.13		         월목     (3주 2일)


 파일 읽고 쓰기
 다음시간은 동적할당
 -------------------------------
*/
#include <random>
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

int comp(const void*, const void*);

int comp(const void* p, const void* q)
{
	//cosnt - 이주소의 값은 읽기만 가능
	//void - 이 자료형이 뭔지는 니가 알테니 마음대로 변환하라
	int* a = (int*)p;
	int* b = (int*)q;

	//qsort 알고리즘 관찰
	if (*a > *b)
		return 1;
	else if (*a == *b)
		return 0;
	else
		return -1;

}

int a[100'0000];
int main()
{
	// 연습.txt에 정수 백만개가 있다.
	// 이 정수를 오름차순 정렬하여 오름차순.txt 파일에 저장하라

	ifstream in("연습.txt");
	
	for (int i = 0; i < 100'0000; ++i) {
		in >> a[i];
	}

	qsort(a, 100'0000, sizeof(int), comp);

	in.close();

	ofstream out("오름차순.txt");

	for (int i = 0; i < 100'0000; ++i) {
		out << a[i] << ' ';
	}
	cout << "끝" << endl;
	save();
}






-----------------------------------
Thu Sep 13 11:09:53 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.13		         월목     (3주 2일)


 파일 읽고 쓰기
 다음시간은 동적할당
 -------------------------------
*/
#include <random>
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

int comp(const void*, const void*);

int comp(const void* a, const void* b)
{
	return *(int*)a - *(int*)b;
}

int a[100'0000];
int main()
{
	// 연습.txt에 정수 백만개가 있다.
	// 이 정수를 오름차순 정렬하여 오름차순.txt 파일에 저장하라

	ifstream in("연습.txt");
	
	for (int i = 0; i < 100'0000; ++i) {
		in >> a[i];
	}

	qsort(a, 100'0000, sizeof(int), comp);

	in.close();

	ofstream out("오름차순.txt");

	for (int i = 0; i < 100'0000; ++i) {
		out << a[i] << ' ';
	}
	cout << "끝" << endl;
	save();
}






-----------------------------------
Mon Sep 17 13:36:13 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.16		         월목     (4주 1일)



 동적할당 - dynamic allocation

 함수오버로딩, 람다
 -------------------------------
*/
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

int comp(const void*, const void*);

int comp(const void* a, const void* b)
{
	return *(int*)a - *(int*)b;
}

int a[100'0000];
int main()
{
	//[문제] 이 소스.cpp에는 몇개의 #이 있는지 출력하라

	ifstream in("소스.cpp");

	char c;
	while (in >> c) {
		cout << c << ' ';
	}


	save();
}






-----------------------------------
Mon Sep 17 13:37:47 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.16		         월목     (4주 1일)



 동적할당 - dynamic allocation

 함수오버로딩, 람다
 -------------------------------
*/
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

int comp(const void*, const void*);

int comp(const void* a, const void* b)
{
	return *(int*)a - *(int*)b;
}

int a[100'0000];
int main()
{
	//[문제] 이 소스.cpp에는 몇개의 #이 있는지 출력하라

	ifstream in("소스.cpp");

	char c;
	while (in.get(c)) {
		cout << c << ' ';
	}


	save();
}






-----------------------------------
Mon Sep 17 13:38:55 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.16		         월목     (4주 1일)



 동적할당 - dynamic allocation

 함수오버로딩, 람다
 -------------------------------
*/
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

int comp(const void*, const void*);

int comp(const void* a, const void* b)
{
	return *(int*)a - *(int*)b;
}

int a[100'0000];
int main()
{
	//[문제] 이 소스.cpp에는 몇개의 #이 있는지 출력하라

	ifstream in("소스.cpp");

	char c;
	while ( in >> c ) {
		cout << c << ' ';
	}


	save();
}






-----------------------------------
Mon Sep 17 13:39:59 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.16		         월목     (4주 1일)



 동적할당 - dynamic allocation

 함수오버로딩, 람다
 -------------------------------
*/
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

int comp(const void*, const void*);

int comp(const void* a, const void* b)
{
	return *(int*)a - *(int*)b;
}

int a[100'0000];
int main()
{
	//[문제] 이 소스.cpp에는 몇개의 #이 있는지 출력하라

	ifstream in("소스.cpp");

	char c;
	int cnt = 0;
	while ( in >> c ) {
		cnt ++;
		cout << c << ' ';
	}


	save();
}






-----------------------------------
Mon Sep 17 13:40:11 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.16		         월목     (4주 1일)



 동적할당 - dynamic allocation

 함수오버로딩, 람다
 -------------------------------
*/
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

int comp(const void*, const void*);

int comp(const void* a, const void* b)
{
	return *(int*)a - *(int*)b;
}

int a[100'0000];
int main()
{
	//[문제] 이 소스.cpp에는 몇개의 #이 있는지 출력하라

	ifstream in("소스.cpp");

	char c;
	int cnt = 0;
	while ( in >> c ) {
		cnt ++;
		cout << c << ' ';
	}

	cout << cnt;

	save();
}






-----------------------------------
Mon Sep 17 13:40:21 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.16		         월목     (4주 1일)



 동적할당 - dynamic allocation

 함수오버로딩, 람다
 -------------------------------
*/
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

int comp(const void*, const void*);

int comp(const void* a, const void* b)
{
	return *(int*)a - *(int*)b;
}

int a[100'0000];
int main()
{
	//[문제] 이 소스.cpp에는 몇개의 #이 있는지 출력하라

	ifstream in("소스.cpp");

	char c;
	int cnt = 0;
	while ( in >> c ) {
		cnt++;
		cout << c << ' ';
	}

	cout << cnt;

	save();
}






-----------------------------------
Mon Sep 17 13:40:55 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.16		         월목     (4주 1일)



 동적할당 - dynamic allocation

 함수오버로딩, 람다
 -------------------------------
*/
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

int comp(const void*, const void*);

int comp(const void* a, const void* b)
{
	return *(int*)a - *(int*)b;
}

int a[100'0000];
int main()
{
	//[문제] 이 소스.cpp에는 몇개의 #이 있는지 출력하라

	ifstream in("소스.cpp");

	char c;
	int cnt = 0;
	while ( in >> c ) {
		cnt++;
	}

	cout << cnt;

	save();
}






-----------------------------------
Mon Sep 17 13:41:35 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.16		         월목     (4주 1일)



 동적할당 - dynamic allocation

 함수오버로딩, 람다
 -------------------------------
*/
#include <iostream>
#include <fstream>
#include "save.h"
using namespace std;

int comp(const void*, const void*);

int comp(const void* a, const void* b)
{
	return *(int*)a - *(int*)b;
}

int a[100'0000];
int main()
{
	//[문제] 이 소스.cpp에는 몇개의 #이 있는지 출력하라

	ifstream in("소스.cpp");

	char c;
	int cnt = 0;
	while ( in >> c ) {
		if (c == '#') {
			cnt ++;
		}
	}

	cout << cnt;

	save();
}






-----------------------------------
Mon Sep 17 13:55:43 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.16		         월목     (4주 1일)


 CODE segment - 프로그램 코드(함수)가 기록되는 공간
				함수의 이름은 CODE segment의 주소를 의미한다.
 동적할당 - dynamic allocation

 함수오버로딩, 람다
 -------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

void f();
void f(int);
//void f(int&);

void f()
{
	cout << "인자가 없는 함수 입니다." << endl;
}

void f(int)
{
	cout << "int를 인자로 받는 함수입니다" << endl;
}

int main()
{
	f();

	f(1);

	save();
}






-----------------------------------
Mon Sep 17 14:05:29 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.16		         월목     (4주 1일)
 시험 1. 9.27 목12

 CODE segment - 프로그램 코드(함수)가 기록되는 공간
				함수의 이름은 CODE segment의 주소를 의미한다.
 동적할당 - dynamic allocation

 함수오버로딩, 람다
 -------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

void f();
void f(int);
//void f(int&);

void f()
{
	cout << "인자가 없는 함수 입니다." << endl;
}

void f(int)
{
	cout << "int를 인자로 받는 함수입니다" << endl;
}


int main()
{
	int a = 1;
	f();

	f(a);

	save();
}






-----------------------------------
Mon Sep 17 14:53:16 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.16		         월목     (4주 1일)
 시험 1. 9.27 목12
?)
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
 동적할당 - dynamic allocation(왜한다.
	3. 사용이 끝나면 delete로 해제한다.


 다음시간-람다
 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

int main()
{
	//[문제] 정수가 100개 들어갈 공간을 동적으로 확보하고
	//1~100까지 값으로 채워라
	//정수 100개의 합을 출력하라
	
	int* p = new int[100];
	
	for (int i = 1; i <= 100;++i) {
		*p = i;
	}

	save();
}






-----------------------------------
Mon Sep 17 14:54:24 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.16		         월목     (4주 1일)
 시험 1. 9.27 목12
?)
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
 동적할당 - dynamic allocation(왜한다.
	3. 사용이 끝나면 delete로 해제한다.


 다음시간-람다
 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

int main()
{
	//[문제] 정수가 100개 들어갈 공간을 동적으로 확보하고
	//1~100까지 값으로 채워라
	//정수 100개의 합을 출력하라
	
	int* p = new int[100];
	
	for (int i = 1; i <= 100;++i) {
		*p = i;
	}

	cout << *p << endl;
	
	save();
}






-----------------------------------
Mon Sep 17 14:58:59 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.16		         월목     (4주 1일)
 시험 1. 9.27 목12
?)
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
 동적할당 - dynamic allocation(왜한다.
	3. 사용이 끝나면 delete로 해제한다.


 다음시간-람다
 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

int main()
{
	//[문제] 정수가 100개 들어갈 공간을 동적으로 확보하고
	//1~100까지 값으로 채워라
	//정수 100개의 합을 출력하라
	
	int* p = new int[100];
	
	for (int i = 0; i < 100;++i) {
		*(p + i) = i + 1;	//p[i]= i+1
	}
	int sum = 0;
	for (int i = 0; i < 100; ++i) {
		sum += p[i];
	}
	
	save();
}






-----------------------------------
Mon Sep 17 14:59:28 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.16		         월목     (4주 1일)
 시험 1. 9.27 목12
?)
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
 동적할당 - dynamic allocation(왜한다.
	3. 사용이 끝나면 delete로 해제한다.


 다음시간-람다
 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

int main()
{
	//[문제] 정수가 100개 들어갈 공간을 동적으로 확보하고
	//1~100까지 값으로 채워라
	//정수 100개의 합을 출력하라
	
	int* p = new int[100];
	
	for (int i = 0; i < 100;++i) {
		*(p + i) = i + 1;	//p[i]= i+1
	}
	int sum = 0;
	for (int i = 0; i < 100; ++i) {
		sum += p[i];
	}
	
	cout << "합계 : " << sum << endl;

	save();
}






-----------------------------------
Mon Sep 17 15:02:24 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.16		         월목     (4주 1일)
 시험 1. 9.27 목12
?)
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
 동적할당 - dynamic allocation(왜한다.
	3. 사용이 끝나면 delete로 해제한다.


 다음시간-람다
 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

int main()
{
	//[문제] 정수가 100개 들어갈 공간을 동적으로 확보하고
	//1~100까지 값으로 채워라
	//정수 100개의 합을 출력하라
	
	int* p = new int[100];
	
	system("pause");
	for (int i = 0; i < 100;++i) {
		*(p + i) = i + 1;	//p[i]= i+1
	}
	int sum = 0;
	for (int i = 0; i < 100; ++i) {
		sum += p[i];
	}
	
	cout << "합계 : " << sum << endl;

	save();
}






-----------------------------------
Mon Sep 17 15:02:47 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.16		         월목     (4주 1일)
 시험 1. 9.27 목12
?)
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
 동적할당 - dynamic allocation(왜한다.
	3. 사용이 끝나면 delete로 해제한다.


 다음시간-람다
 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

int main()
{
	//[문제] 정수가 100개 들어갈 공간을 동적으로 확보하고
	//1~100까지 값으로 채워라
	//정수 100개의 합을 출력하라
	
	int* p = new int[1000000];
	
	system("pause");
	for (int i = 0; i < 100;++i) {
		*(p + i) = i + 1;	//p[i]= i+1
	}
	int sum = 0;
	for (int i = 0; i < 100; ++i) {
		sum += p[i];
	}
	
	cout << "합계 : " << sum << endl;

	save();
}






-----------------------------------
Mon Sep 17 15:03:46 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.16		         월목     (4주 1일)
 시험 1. 9.27 목12
?)
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
 동적할당 - dynamic allocation(왜한다.
	3. 사용이 끝나면 delete로 해제한다.


 다음시간-람다
 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

int main()
{
	//[문제] 정수가 100개 들어갈 공간을 동적으로 확보하고
	//1~100까지 값으로 채워라
	//정수 100개의 합을 출력하라
	
	int* p = new int[1000000];
	
	system("pause");
	for (int i = 0; i < 100;++i) {
		*(p + i) = i + 1;	//p[i]= i+1
	}
	int sum = 0;
	for (int i = 0; i < 100; ++i) {
		sum += p[i];
	}
	
	cout << "합계 : " << sum << endl;

	delete[] p;

	save();
}






-----------------------------------
Mon Sep 17 15:04:04 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.16		         월목     (4주 1일)
 시험 1. 9.27 목12
?)
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
 동적할당 - dynamic allocation(왜한다.
	3. 사용이 끝나면 delete로 해제한다.


 다음시간-람다
 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

int main()
{
	//[문제] 정수가 100개 들어갈 공간을 동적으로 확보하고
	//1~100까지 값으로 채워라
	//정수 100개의 합을 출력하라
	
	int* p = new int[1000000];
	
	system("pause");
	for (int i = 0; i < 100;++i) {
		*(p + i) = i + 1;	//p[i]= i+1
	}
	int sum = 0;
	for (int i = 0; i < 100; ++i) {
		sum += p[i];
	}
	
	cout << "합계 : " << sum << endl;

	delete[] p;

	save();
}






-----------------------------------
Mon Sep 17 15:15:32 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.16		         월목     (4주 1일)
 시험 1. 9.27 목12
?)
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
 동적할당 - dynamic allocation(왜한다.
	3. 사용이 끝나면 delete로 해제한다.


 다음시간-람다
 -----------------------------------------------
*/
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;

int main()
{
	ofstream out("정수백만개.txt");
	default_random_engine dre;
	uniform_int_distribution<> uid;

	for (int i = 0; i < 10000000; ++i){
		out << uid(dre) << '\n';
	}
	out.close();

	//[문제] 정수가 1000만개가 저장된 정수백만개.txt가 있다.
	//정수를 읽어들여 정렬한 후 오름차순.txt에 저장하라
	//그리고 가장 큰수를 출력하라

	save();
}






-----------------------------------
Mon Sep 17 15:17:02 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.16		         월목     (4주 1일)
 시험 1. 9.27 목12
?)
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
 동적할당 - dynamic allocation(왜한다.
	3. 사용이 끝나면 delete로 해제한다.


 다음시간-람다
 -----------------------------------------------
*/
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;
int comp(const void*, const void*);

int comp(const void* a, const void* b)
{
	return *(int*)a - *(int*)b;
}

int main()
{
	ofstream out("정수백만개.txt");
	default_random_engine dre;
	uniform_int_distribution<> uid;

	for (int i = 0; i < 1000000; ++i){
		out << uid(dre) << '\n';
	}
	out.close();

	//[문제] 정수가 1000만개가 저장된 정수백만개.txt가 있다.
	//정수를 읽어들여 정렬한 후 오름차순.txt에 저장하라
	//그리고 가장 큰수를 출력하라

	save();
}






-----------------------------------
Mon Sep 17 15:22:47 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.16		         월목     (4주 1일)
 시험 1. 9.27 목12
?)
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
 동적할당 - dynamic allocation(왜한다.
	3. 사용이 끝나면 delete로 해제한다.


 다음시간-람다
 -----------------------------------------------
*/
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;
int comp(const void*, const void*);

int comp(const void* a, const void* b)
{
	return *(int*)a - *(int*)b;
}

int main()
{
	ofstream out("정수백만개.txt");
	default_random_engine dre;
	uniform_int_distribution<> uid;

	for (int i = 0; i < 1000000; ++i){
		out << uid(dre) << '\n';
	}
	out.close();

	//[문제] 정수가 1000만개가 저장된 정수백만개.txt가 있다.
	//정수를 읽어들여 정렬한 후 오름차순.txt에 저장하라
	//그리고 가장 큰수를 출력하라

	ifstream in("정수백만개.txt");

	int* p = new int[1000000];
	for (int i = 0; i < 1000000; ++i) {
		in >> p[i];
	}
	ofstream out1("오름차순.txt");
	
	qsort(p,1000000,4,comp);

	save();
}






-----------------------------------
Mon Sep 17 15:23:32 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.16		         월목     (4주 1일)
 시험 1. 9.27 목12
?)
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
 동적할당 - dynamic allocation(왜한다.
	3. 사용이 끝나면 delete로 해제한다.


 다음시간-람다
 -----------------------------------------------
*/
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;
int comp(const void*, const void*);

int comp(const void* a, const void* b)
{
	return *(int*)a - *(int*)b;
}

int main()
{
	ofstream out("정수백만개.txt");
	default_random_engine dre;
	uniform_int_distribution<> uid;

	for (int i = 0; i < 1000000; ++i){
		out << uid(dre) << '\n';
	}
	out.close();

	//[문제] 정수가 1000만개가 저장된 정수백만개.txt가 있다.
	//정수를 읽어들여 정렬한 후 오름차순.txt에 저장하라
	//그리고 가장 큰수를 출력하라

	ifstream in("정수백만개.txt");

	int* p = new int[1000000];
	for (int i = 0; i < 1000000; ++i) {
		in >> p[i];
	}
	ofstream out1("오름차순.txt");
	
	qsort(p,1000000,4,comp);
	cout << "끝" << endl;
	save();
}






-----------------------------------
Mon Sep 17 15:24:51 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.16		         월목     (4주 1일)
 시험 1. 9.27 목12
?)
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
 동적할당 - dynamic allocation(왜한다.
	3. 사용이 끝나면 delete로 해제한다.


 다음시간-람다
 -----------------------------------------------
*/
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;
int comp(const void*, const void*);

int comp(const void* a, const void* b)
{
	return *(int*)a - *(int*)b;
}

int main()
{
	ofstream out("정수백만개.txt");
	default_random_engine dre;
	uniform_int_distribution<> uid;

	for (int i = 0; i < 1000000; ++i){
		out << uid(dre) << '\n';
	}
	out.close();

	//[문제] 정수가 1000만개가 저장된 정수백만개.txt가 있다.
	//정수를 읽어들여 정렬한 후 오름차순.txt에 저장하라
	//그리고 가장 큰수를 출력하라

	ifstream in("정수백만개.txt");

	int* p = new int[1000000];
	for (int i = 0; i < 1000000; ++i) {
		in >> p[i];
	}
	ofstream out1("오름차순.txt");
	
	qsort(p,1000000,4,comp);
	for (int i = 0; i < 1000000; ++i) {
		out1 << p[i];
	}
	cout << "끝" << endl;
	
	delete[] p;
	
	save();
}






-----------------------------------
Thu Sep 20 09:40:37 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.20		         월목     (4주 2일)
 시험 1. 9.27 목12

 
	동적할당 - dynamic allocation(왜한다?)	
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
	3. 사용이 끝나면 delete로 해제한다.


 다음시간-람다
 -----------------------------------------------
*/
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;
int comp(const void*, const void*);

int comp(const void* a, const void* b)
{
	return *(int*)a - *(int*)b;
}

int main()
{
	ofstream out("정수백만개.txt");
	default_random_engine dre;
	uniform_int_distribution<> uid;

	for (int i = 0; i < 1000000; ++i){
		out << uid(dre) << '\n';
	}
	out.close();

	//[문제] 정수가 1000만개가 저장된 정수백만개.txt가 있다.
	//정수를 읽어들여 정렬한 후 오름차순.txt에 저장하라
	//그리고 가장 큰수를 출력하라

	ifstream in("정수백만개.txt");

	int* p = new int[1000000];
	for (int i = 0; i < 1000000; ++i) {
		in >> p[i];
	}
	ofstream out1("오름차순.txt");
	
	qsort(p,1000000,4,comp);
	int max = 0;
	for (int i = 0; i < 1000000; ++i) {
		out1 << p[i];
		if (p[i] > max) {
			max = p[i];
		}
	}
	cout << max << endl;
	
	delete[] p;
	
	save();
}






-----------------------------------
Thu Sep 20 09:42:51 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.20		         월목     (4주 2일)
 시험 1. 9.27 목12

 
	동적할당 - dynamic allocation(왜한다?)	
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
	3. 사용이 끝나면 delete로 해제한다.


 다음시간-람다
 -----------------------------------------------
*/
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;
int comp(const void*, const void*);

int comp(const void* a, const void* b)
{
	return *(int*)a - *(int*)b;
}

int main()
{
	ofstream out("정수백만개.txt");
	default_random_engine dre;
	uniform_int_distribution<> uid;

	for (int i = 0; i < 1000000; ++i){
		out << uid(dre) << '\n';
	}
	out.close();

	//[문제] 정수가 1000만개가 저장된 정수백만개.txt가 있다.
	//정수를 읽어들여 정렬한 후 오름차순.txt에 저장하라
	//그리고 가장 큰수를 출력하라

	ifstream in("정수백만개.txt");

	int* p = new int[1000000];
	for (int i = 0; i < 1000000; ++i) {
		in >> p[i];
	}
	ofstream out1("오름차순.txt");
	
	qsort(p,1000000,4,comp);
	int max = 0;
	for (int i = 0; i < 1000000; ++i) {
		out1 << p[i] << '\n';
		if (p[i] > max) {
			max = p[i];
		}
	}
	cout << max << endl;
	
	delete[] p;
	
	save();
}






-----------------------------------
Thu Sep 20 09:46:19 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.20		         월목     (4주 2일)
 시험 1. 9.27 목12

 
	동적할당 - dynamic allocation(왜한다?)	
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
	3. 사용이 끝나면 delete로 해제한다.


 다음시간-람다
 -----------------------------------------------
*/
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;
int comp(const void*, const void*);

int comp(const void* a, const void* b)
{
	return *(int*)a - *(int*)b;
}

int main()
{
	ofstream out("정수백만개.txt");
	default_random_engine dre;
	uniform_int_distribution<> uid;

	for (int i = 0; i < 1000000; ++i){
		out << uid(dre) << '\n';
	}
	out.close();

	//[문제] 정수가 1000만개가 저장된 정수백만개.txt가 있다.
	//정수를 읽어들여 정렬한 후 오름차순.txt에 저장하라
	//그리고 가장 큰수를 출력하라

	ifstream in("정수백만개.txt");

	int* p = new int[1000000];
	if (p == nullptr) {
		cout << "메모리가 부족합니다.";
		return 0;
	}

	for (int i = 0; i < 1000000; ++i) {
		in >> p[i];
	}
	ofstream out1("오름차순.txt");
	
	qsort(p,1000000,4,comp);
	int max = 0;
	for (int i = 0; i < 1000000; ++i) {
		out1 << p[i] << '\n';
		if (p[i] > max) {
			max = p[i];
		}
	}
	cout << max << endl;
	
	delete[] p;
	
	save();
}






-----------------------------------
Thu Sep 20 09:50:55 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.20		         월목     (4주 2일)
 시험 1. 9.27 목12

 
	동적할당 - dynamic allocation(왜한다?)	
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
	3. 사용이 끝나면 delete로 해제한다.


 다음시간-람다
 -----------------------------------------------
*/
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;
int comp(const void*, const void*);

int comp(const void* a, const void* b)
{
	return *(int*)a - *(int*)b;
}

int main()
{
	ofstream out("정수백만개.txt");
	default_random_engine dre;
	uniform_int_distribution<> uid;

	for (int i = 0; i < 1000000; ++i){
		out << uid(dre) << '\n';
	}
	out.close();

	//[문제] 정수가 1000만개가 저장된 정수백만개.txt가 있다.
	//정수를 읽어들여 정렬한 후 오름차순.txt에 저장하라
	//그리고 가장 큰수를 출력하라

	ifstream in("정수백만개.txt");

	int* p = new int[1000000];
	if (p == nullptr) {
		cout << "메모리가 부족합니다.";
		return 0;
	}

	for (int i = 0; i < 1000000; ++i) {
		in >> p[i];
	}
	ofstream out1("오름차순.txt");
	
	qsort(p,1000000,4,comp);
	int max = 0;
	for (int i = 0; i < 1000000; ++i) {
		out1 << p[i] << '\n';
	}
	cout << "가장 작은 값" << p[0] << endl;
	cout << "가장 큰 값" << p[1000000 - 1] << endl;
	
	delete[] p;
	
	save();
}






-----------------------------------
Thu Sep 20 09:56:21 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.20		         월목     (4주 2일)
 시험 1. 9.27 목12

 
	동적할당 - dynamic allocation(왜한다?)	
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
	3. 사용이 끝나면 delete로 해제한다.


 다음시간-람다
 -----------------------------------------------
*/
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;
int comp(const void*, const void*);

int comp(const void* a, const void* b)
{
	return *(int*)a - *(int*)b;
}

int main()
{	
	cout << "무작위로 수를 정합니다." << endl;
	ofstream out("정수백만개.txt");
	default_random_engine dre;
	uniform_int_distribution<> uid;

	cout << "파일에 기록합니다." << endl;
	
	for (int i = 0; i < 1000000; ++i){
		out << uid(dre) << '\n';
	}
	out.close();

	//[문제] 정수가 1000만개가 저장된 정수백만개.txt가 있다.
	//정수를 읽어들여 정렬한 후 오름차순.txt에 저장하라
	//그리고 가장 큰수를 출력하라

	ifstream in("정수백만개.txt");

	int* p = new int[1000000];
	if (p == nullptr) {
		cout << "메모리가 부족합니다.";
		return 0;
	}
	cout << "파일을 읽어들입니다." << endl;
	for (int i = 0; i < 1000000; ++i) {
		in >> p[i];
	}
	ofstream out1("오름차순.txt");
	
	cout << "정렬을 시작합니다." << endl;

	qsort(p,1000000,4,comp);

	cout << "정렬한 수를 파일에 기록합니다." << endl;
	for (int i = 0; i < 1000000; ++i) {
		out1 << p[i] << '\n';
	}
	cout << "가장 작은 값" << p[0] << endl;
	cout << "가장 큰 값" << p[1000000 - 1] << endl;
	
	delete[] p;
	
	save();
}





-----------------------------------
Thu Sep 20 10:04:41 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.20		         월목     (4주 2일)
 시험 1. 9.27 목12

 
	동적할당 - dynamic allocation(왜한다?)	
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
	3. 사용이 끝나면 delete로 해제한다.

	[문제점]
	?? - 1과 3사이에는 시공간의 틈이 있기 때문
	1.할당한 메모리를 지우지 않는다.
	2.이미 지운 메모리를 한번 더 지운다.

 다음시간-람다
 -----------------------------------------------
*/
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;
int comp(const void*, const void*);

int comp(const void* a, const void* b)
{
	return *(int*)a - *(int*)b;
}

int main()
{	
	cout << "무작위로 수를 정합니다." << endl;
	ofstream out("정수백만개.txt");
	default_random_engine dre;
	uniform_int_distribution<> uid;

	cout << "파일에 기록합니다." << endl;
	
	for (int i = 0; i < 1000000; ++i){
		out << uid(dre) << '\n';
	}
	out.close();

	//[문제] 정수가 1000만개가 저장된 정수백만개.txt가 있다.
	//정수를 읽어들여 정렬한 후 오름차순.txt에 저장하라
	//그리고 가장 큰수를 출력하라

	ifstream in("정수백만개.txt");

	int* p = new int[1000000];
	if (p == nullptr) {
		cout << "메모리가 부족합니다.";
		return 0;
	}
	cout << "파일을 읽어들입니다." << endl;
	for (int i = 0; i < 1000000; ++i) {
		in >> p[i];
	}
	ofstream out1("오름차순.txt");
	
	cout << "정렬을 시작합니다." << endl;

	qsort(p,1000000,4,comp);

	cout << "정렬한 수를 파일에 기록합니다." << endl;
	for (int i = 0; i < 1000000; ++i) {
		out1 << p[i] << '\n';
	}
	cout << "가장 작은 값" << p[0] << endl;
	cout << "가장 큰 값" << p[1000000 - 1] << endl;
	
	delete[] p;
	
	save();
}






-----------------------------------
Thu Sep 20 10:09:53 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.20		         월목     (4주 2일)
 시험 1. 9.27 목12

 
	동적할당 - dynamic allocation(왜한다?)	
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
	3. 사용이 끝나면 delete로 해제한다.

	[문제점]
	?? - 1과 3사이에는 시공간의 틈이 있기 때문
	1.할당한 메모리를 지우지 않는다.
	2.이미 지운 메모리를 한번 더 지운다.
		-복사 생성자(깊은복사)
 다음시간-람다
 -----------------------------------------------
*/
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;
int comp(const void*, const void*);

int comp(const void* a, const void* b)
{
	return *(int*)a - *(int*)b;
}

int main()
{	
	cout << "무작위로 수를 정합니다." << endl;
	ofstream out("정수백만개.txt");
	default_random_engine dre;
	uniform_int_distribution<> uid;

	cout << "파일에 기록합니다." << endl;
	
	for (int i = 0; i < 1000000; ++i){
		out << uid(dre) << '\n';
	}
	out.close();

	//[문제] 정수가 1000만개가 저장된 정수백만개.txt가 있다.
	//정수를 읽어들여 정렬한 후 오름차순.txt에 저장하라
	//그리고 가장 큰수를 출력하라

	ifstream in("정수백만개.txt");

	int* p = new int[1000000];
	if (p == nullptr) {
		cout << "메모리가 부족합니다.";
		return 0;
	}
	cout << "파일을 읽어들입니다." << endl;
	for (int i = 0; i < 1000000; ++i) {
		in >> p[i];
	}
	ofstream out1("오름차순.txt");
	
	cout << "정렬을 시작합니다." << endl;

	qsort(p,1000000,4,comp);

	cout << "정렬한 수를 파일에 기록합니다." << endl;
	for (int i = 0; i < 1000000; ++i) {
		out1 << p[i] << '\n';
	}
	cout << "가장 작은 값" << p[0] << endl;
	cout << "가장 큰 값" << p[1000000 - 1] << endl;
	
	delete[] p;
	
	save();
}






-----------------------------------
Thu Sep 20 10:14:51 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.20		         월목     (4주 2일)
 시험 1. 9.27 목12

 
	동적할당 - dynamic allocation(왜한다?)	
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
	3. 사용이 끝나면 delete로 해제한다.

	[문제점]
	?? - 1과 3사이에는 시공간의 틈이 있기 때문
	1.할당한 메모리를 지우지 않는다.
	2.이미 지운 메모리를 한번 더 지운다.
		-복사 생성자(깊은복사)
 다음시간-람다
 -----------------------------------------------
*/
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;

int main()
{	
	int i = 0;
	while (true) {
		if (new int[10000000] != nullptr)
			break;
		cout << ++i << "번";
	}

	save();
}






-----------------------------------
Thu Sep 20 10:19:15 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.20		         월목     (4주 2일)
 시험 1. 9.27 목12

 
	동적할당 - dynamic allocation(왜한다?)	
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
	3. 사용이 끝나면 delete로 해제한다.

	[문제점]
	?? - 1과 3사이에는 시공간의 틈이 있기 때문
	1.할당한 메모리를 지우지 않는다.
	2.이미 지운 메모리를 한번 더 지운다.
		-복사 생성자(깊은복사)
 다음시간-람다
 -----------------------------------------------
*/
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;

int main()
{	
	cout << numeric_limits<int>::max() << endl;


	save();
}






-----------------------------------
Thu Sep 20 10:48:54 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.20		         월목     (4주 2일)
 시험 1. 9.27 목12

 
	동적할당 - dynamic allocation(왜한다?)	
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
	3. 사용이 끝나면 delete로 해제한다.

	[문제점]
	?? - 1과 3사이에는 시공간의 틈이 있기 때문
	1.할당한 메모리를 지우지 않는다.
	2.이미 지운 메모리를 한번 더 지운다.
		-복사 생성자(깊은복사)
 
 람다(350쪽)


 -----------------------------------------------
*/
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;

int main()
{	

	int a[]{ 1,5,2,3,4 };

	qsort(a, 5, 4, [](const void* a, const void* b) {
		return *(int*)a - *(int*)b;
	});

	save();
}






-----------------------------------
Thu Sep 20 10:49:42 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.20		         월목     (4주 2일)
 시험 1. 9.27 목12

 
	동적할당 - dynamic allocation(왜한다?)	
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
	3. 사용이 끝나면 delete로 해제한다.

	[문제점]
	?? - 1과 3사이에는 시공간의 틈이 있기 때문
	1.할당한 메모리를 지우지 않는다.
	2.이미 지운 메모리를 한번 더 지운다.
		-복사 생성자(깊은복사)
 
 람다(350쪽)


 -----------------------------------------------
*/
#include <iostream>
#include <fstream>
#include <random>
#include "save.h"
using namespace std;

int main()
{	

	int a[]{ 1,5,2,3,4 };

	qsort(a, 5, 4, [](const void* a, const void* b) {
		return *(int*)a - *(int*)b;
	});
	for(int d:a)
	cout << d << ',';
	save();
}






-----------------------------------
Thu Sep 20 10:53:11 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.20		         월목     (4주 2일)
 시험 1. 9.27 목12

 
	동적할당 - dynamic allocation(왜한다?)	
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
	3. 사용이 끝나면 delete로 해제한다.

	[문제점]
	?? - 1과 3사이에는 시공간의 틈이 있기 때문
	1.할당한 메모리를 지우지 않는다.
	2.이미 지운 메모리를 한번 더 지운다.
		-복사 생성자(깊은복사)
 
 람다(350쪽)


 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

int main()
{	

	[]() {cout << "??????????????????????"; } ();   //()를 마지막에 붙히면 한번 람다를 불러옴
	save();
}






-----------------------------------
Thu Sep 20 10:54:31 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.20		         월목     (4주 2일)
 시험 1. 9.27 목12

 
	동적할당 - dynamic allocation(왜한다?)	
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
	3. 사용이 끝나면 delete로 해제한다.

	[문제점]
	?? - 1과 3사이에는 시공간의 틈이 있기 때문
	1.할당한 메모리를 지우지 않는다.
	2.이미 지운 메모리를 한번 더 지운다.
		-복사 생성자(깊은복사)
 
 람다(350쪽)


 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

int main()
{	

	auto f = []() {cout << "??????????????????????"; };
	f();

	save();
}






-----------------------------------
Thu Sep 20 10:57:10 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.20		         월목     (4주 2일)
 시험 1. 9.27 목12

 
	동적할당 - dynamic allocation(왜한다?)	
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
	3. 사용이 끝나면 delete로 해제한다.

	[문제점]
	?? - 1과 3사이에는 시공간의 틈이 있기 때문
	1.할당한 메모리를 지우지 않는다.
	2.이미 지운 메모리를 한번 더 지운다.
		-복사 생성자(깊은복사)
 
 람다(350쪽)


 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

int main()
{	

	[]() -> void {cout << "??????????????????????"; };
	

	save();
}






-----------------------------------
Thu Sep 20 11:03:12 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.20		         월목     (4주 2일)
 시험 1. 9.27 목12

 
	동적할당 - dynamic allocation(왜한다?)	
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
	3. 사용이 끝나면 delete로 해제한다.

	[문제점]
	?? - 1과 3사이에는 시공간의 틈이 있기 때문
	1.할당한 메모리를 지우지 않는다.
	2.이미 지운 메모리를 한번 더 지운다.
		-복사 생성자(깊은복사)
 
 람다(350쪽)


 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

int main()
{	

	//정수 2개를 더한 값을 리턴하는 람다를 선언하고 호출하라
	//결과값은 화면에 출력하라

	int a=5;
	int b=9;
	
	cout << [](int a , int b ) ->int {
		return a + b;
	}(a, b); cout << endl;




	save();
}






-----------------------------------
Thu Sep 20 11:04:01 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.20		         월목     (4주 2일)
 시험 1. 9.27 목12

 
	동적할당 - dynamic allocation(왜한다?)	
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
	3. 사용이 끝나면 delete로 해제한다.

	[문제점]
	?? - 1과 3사이에는 시공간의 틈이 있기 때문
	1.할당한 메모리를 지우지 않는다.
	2.이미 지운 메모리를 한번 더 지운다.
		-복사 생성자(깊은복사)
 
 람다(350쪽)


 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

int main()
{	

	//정수 2개를 더한 값을 리턴하는 람다를 선언하고 호출하라
	//결과값은 화면에 출력하라

	int a=5;
	int b=-5;
	
	cout << [](int a , int b ) ->int {
		return a + b;
	}(a, b); cout << endl;




	save();
}




-----------------------------------
Mon Oct  1 14:04:35 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.20		         월목     (4주 2일)
 시험 1. 9.27 목12

 
	동적할당 - dynamic allocation(왜한다?)	
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
	3. 사용이 끝나면 delete로 해제한다.

	[문제점]
	?? - 1과 3사이에는 시공간의 틈이 있기 때문
	1.할당한 메모리를 지우지 않는다.
	2.이미 지운 메모리를 한번 더 지운다.
		-복사 생성자(깊은복사)
 
 람다(350쪽)


 -----------------------------------------------
*/
#include <iostream>
#include <random>
#include "save.h"


using namespace std;

int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid(0, 999);

	int a[10000];
	for(int& d:a)
		d = uid(dre);
	int cnt[10]{ 0 };
	
	for (int d : a)
		cnt[d]++;

	for (int i = 0; i < 100; ++i)
		cout << i << '\t' << cnt[i] << endl;
	
	save();
}





-----------------------------------
Mon Oct  1 14:05:09 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.9.20		         월목     (4주 2일)
 시험 1. 9.27 목12

 
	동적할당 - dynamic allocation(왜한다?)	
	1. new로 메모리를 확보한다.
	2. 확보한 메모리를 번지로 조작
	3. 사용이 끝나면 delete로 해제한다.

	[문제점]
	?? - 1과 3사이에는 시공간의 틈이 있기 때문
	1.할당한 메모리를 지우지 않는다.
	2.이미 지운 메모리를 한번 더 지운다.
		-복사 생성자(깊은복사)
 
 람다(350쪽)


 -----------------------------------------------
*/
#include <iostream>
#include <random>
#include "save.h"


using namespace std;

int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid(0, 999);

	int a[10000];
	for(int& d:a)
		d = uid(dre);
	int cnt[10]{ 0 };
	
	for (int d : a)
		cnt[d/100]++;

	for (int i = 0; i < 10; ++i)
		cout << cnt[i] << endl;
	
	save();
}





-----------------------------------
Mon Oct  1 14:06:54 2018

-----------------------------------
/*
 -----------------------------------------------
시험 6번문제
 -----------------------------------------------
*/
#include <iostream>
#include <random>
#include "save.h"


using namespace std;

int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid(0, 999);

	int a[10000];
	for(int& d:a)
		d = uid(dre);
	int cnt[10]{ 0 };
	
	for (int d : a)
		cnt[d/100]++;

	for (int i = 0; i < 10; ++i)
		cout << cnt[i] << endl;
	
	save();
}





-----------------------------------
Mon Oct  1 14:38:25 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.1		         월목     (5주 2일)
 

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include "save.h"


using namespace std;

int main()
{
	int n{ 10 };
	//Stack에 int 만큼 메모리를 줘
	//n 이라는 이름으로 읽고 쓰겠어
	//그런데 만들면서 값을 10이라고 만들어줘

	save();
}





-----------------------------------
Mon Oct  1 14:47:59 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.1		         월목     (5주 2일)
 

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

class Dog{
	
};

int main()
{
	Dog n;
	
	cout << sizeof(Dog) << endl;

	save();
}





-----------------------------------
Mon Oct  1 14:49:57 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.1		         월목     (5주 2일)
 

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

class Dog{
	//class의 객체가 차지하는 메모리의 크기는{ 와 } 사이에
	//적어놓은 자료형 크기의 합이다.
	//[문제] 자료형에 따른 클래스의 크기를 관찰해 보라
	long long int a;
};

int main()
{
	Dog n;
	
	cout << sizeof(Dog) << endl;

	save();
}





-----------------------------------
Mon Oct  1 14:50:11 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.1		         월목     (5주 2일)
 

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

class Dog{
	//class의 객체가 차지하는 메모리의 크기는{ 와 } 사이에
	//적어놓은 자료형 크기의 합이다.
	//[문제] 자료형에 따른 클래스의 크기를 관찰해 보라
	long long int a;
	long long int b;
};

int main()
{
	Dog n;
	
	cout << sizeof(Dog) << endl;

	save();
}


-----------------------------------
Mon Oct  1 14:51:02 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.1		         월목     (5주 2일)
 

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

class Dog{
	//class의 객체가 차지하는 메모리의 크기는{ 와 } 사이에
	//적어놓은 자료형 크기의 합이다.
	//[문제] 자료형에 따른 클래스의 크기를 관찰해 보라
	
	char c;
	int a;
	int b;
};
int main()
{
	Dog n;
	
	cout << sizeof(Dog) << endl;

	save();
}





-----------------------------------
Mon Oct  1 14:51:48 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.1		         월목     (5주 2일)
 

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

class Dog{
	//class의 객체가 차지하는 메모리의 크기는{ 와 } 사이에
	//적어놓은 자료형 크기의 합이다.
	//[문제] 자료형에 따른 클래스의 크기를 관찰해 보라
	
	float c;
	int a;
	int b;
};
int main()
{
	Dog n;
	
	cout << sizeof(Dog) << endl;

	save();
}





-----------------------------------
Mon Oct  1 14:52:11 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.1		         월목     (5주 2일)
 

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

class Dog {
	//class의 객체가 차지하는 메모리의 크기는{ 와 } 사이에
	//적어놓은 자료형 크기의 합이다.
	//[문제] 자료형에 따른 클래스의 크기를 관찰해 보라

	float c;
};
int main()
{
	Dog n;
	
	cout << sizeof(Dog) << endl;

	save();
}





-----------------------------------
Mon Oct  1 14:53:02 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.1		         월목     (5주 2일)
 

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

class Dog {
	//class의 객체가 차지하는 메모리의 크기는{ 와 } 사이에
	//적어놓은 자료형 크기의 합이다.
	//[문제] 자료형에 따른 클래스의 크기를 관찰해 보라
	long long int k;
	int kd;
};



int main()
{
	Dog n;
	
	cout << sizeof(Dog) << endl;

	save();
}





-----------------------------------
Mon Oct  1 15:00:40 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.1		         월목     (5주 2일)
 

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

class Dog {
	char a;	//1
	//????	//3
	int b;	//4
};



int main()
{
	Dog n;
	
	cout << sizeof(Dog) << endl;

	save();
}





-----------------------------------
Mon Oct  1 15:07:02 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.1		         월목     (5주 2일)
 

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

class Dog {

private :			//class밖에서는 access할 수 없음!
	int age;		//멤버변수
};



int main()
{
	Dog n;

	//Dog의 age멤버가 private이라 읽을 수 없다.
	cout << n.age << endl;

	save();
}





-----------------------------------
Mon Oct  1 15:08:43 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.1		         월목     (5주 2일)
 

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

class Dog {

public :			//class밖에서는 access할 수 있음!
	int age;		//멤버변수
};



int main()
{
	Dog n;

	//Dog의 age멤버가 private이라 읽을 수 없다.
	cout << n.age << endl;

	save();
}





-----------------------------------
Mon Oct  1 15:11:41 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.1		         월목     (5주 2일)
 

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

struct Dog{
	int age;		//멤버변수
};



int main()
{
	Dog n;

	//struct는 무조건 public
	cout << n.age << endl;

	save();
}





-----------------------------------
Mon Oct  1 15:16:00 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.1		         월목     (5주 2일)
 

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

struct Dog{
	//내가 만든 메모리를 밖에서 맘대로 자유롭게 access하려면 struct를 써서
	//자료형을 만든다.
public :			// struct의 default 접근 지시자
	int age;		// 멤버변수
};



int main()
{
	Dog n;

	//Dog의 age멤버가 private이라 읽을 수 없다.
	cout << n.age << endl;

	save();
}





-----------------------------------
Mon Oct  1 15:17:44 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.1		         월목     (5주 2일)
 

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;


struct Dog{
	//내가 만든 메모리를 밖에서 맘대로 자유롭게 access하려면 struct를 써서
	//자료형을 만든다.
public :			// struct의 default 접근 지시자
	int age;		// 멤버변수
};



int main()
{
	Dog n;

	//Dog의 age멤버가 private이라 읽을 수 없다.
	cout << n.age << endl;

	save();
}





-----------------------------------
Mon Oct  1 15:18:29 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.1		         월목     (5주 2일)
 

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;


class Dog{
	//내가 만든 메모리를 밖에서 맘대로 자유롭게 access하려면 struct를 써서
	//자료형을 만든다.
private:			// class의 default 접근 지시자
	int age;		// 멤버변수
};



int main()
{
	Dog n;

	//Dog의 age멤버가 private이라 읽을 수 없다.
	//cout << n.age << endl;

	save();
}





-----------------------------------
Mon Oct  1 15:20:40 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.1		         월목     (5주 2일)
 

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;


class Dog{
	//내가 만든 메모리를 밖에서 맘대로 자유롭게 access하려면 struct를 써서
	//자료형을 만든다.
private:			// class의 default 접근 지시자
	int age;		// 멤버변수


public:
	int getAge() {
		return age;
	};

};



int main()
{
	Dog n;

	//Dog의 age멤버가 private이라 읽을 수 없다.
	cout << n.getAge() << endl;

	save();
}





-----------------------------------
Thu Oct  4 09:41:00 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나
//3. 자료를 초기화하는 방법
//4. 자료를 정리하는 방법
//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
class Dog {
	string name;
	int age;
};

int main()
{
	Dog a;

	cout << sizeof(a) << endl;
	save();
}





-----------------------------------
Thu Oct  4 09:41:53 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나
//3. 자료를 초기화하는 방법
//4. 자료를 정리하는 방법
//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
class Dog {
	string name;
	int age;
};

int main()
{
	cout << sizeof(Dog) << endl;
	save();
}





-----------------------------------
Thu Oct  4 09:56:51 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나
//3. 자료를 초기화하는 방법
//4. 자료를 정리하는 방법
//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
// 개의 이름과 나이는 값으로 표현할 수 있다.
struct Dog{
	string name = "진돌이";
	int age = 0;
};

int main()
{
	Dog a;
	
	cout << "나이는 - " << a.age << endl;
	cout << "이름은 - " << a.name << endl;

	save();
}





-----------------------------------
Thu Oct  4 09:57:40 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나
//3. 자료를 초기화하는 방법
//4. 자료를 정리하는 방법
//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
// 개의 이름과 나이는 값으로 표현할 수 있다.
struct Dog{
	string name = "진돌이";
	int age = 0;
};

int main()
{
	Dog a;
	a.age = 1;
	cout << "나이는 - " << a.age << endl;
	cout << "이름은 - " << a.name << endl;

	save();
}





-----------------------------------
Thu Oct  4 10:01:54 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나
//3. 자료를 초기화하는 방법
//4. 자료를 정리하는 방법
//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
// 개의 이름과 나이는 값으로 표현할 수 있다.
struct Dog{
	string name = "진돌이";
	int age = 0;
};

int main()
{
	Dog* a = new Dog;
	cout << "나이는 - " << a->age << endl;
	cout << "이름은 - " << a->name << endl;

	save();
}





-----------------------------------
Thu Oct  4 10:02:27 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나
//3. 자료를 초기화하는 방법
//4. 자료를 정리하는 방법
//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
// 개의 이름과 나이는 값으로 표현할 수 있다.
struct Dog{
	string name = "진돌이";
	int age = 0;
};

int main()
{
	Dog* a = new Dog;

	a->age = 10;
	a->name = "댕댕이";

	cout << "나이는 - " << a->age << endl;
	cout << "이름은 - " << a->name << endl;

	save();
}





-----------------------------------
Thu Oct  4 10:05:34 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나
//3. 자료를 초기화하는 방법
//4. 자료를 정리하는 방법
//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
// 개의 이름과 나이는 값으로 표현할 수 있다.
struct Dog{
	string name = "진돌이";
	int age = 0;
};

int main()
{
	//[문제] 개 10마리를 만들고 이름과 나이를 출력하라
	
	Dog a[10];

	for (int i = 0; i < 10; ++i) {
		cout << "나이" << a[i].age << endl;
		cout << "이름" << a[i].name << endl;
	}
	save();
}





-----------------------------------
Thu Oct  4 10:08:34 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나
//3. 자료를 초기화하는 방법
//4. 자료를 정리하는 방법
//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
// 개의 이름과 나이는 값으로 표현할 수 있다.
struct Dog{
	string name = "진돌이";
	int age = 0;
};

int main()
{
	//[문제] 개 10마리를 만들고 이름과 나이를 출력하라
	
	Dog a[10];

	for (Dog d : a) {
		cout << "나이" << d.age << endl;
		cout << "이름" << d.name << endl;
	}
	save();
}





-----------------------------------
Thu Oct  4 10:10:28 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나
//3. 자료를 초기화하는 방법
//4. 자료를 정리하는 방법
//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
// 개의 이름과 나이는 값으로 표현할 수 있다.
struct Dog{
	string name = "진돌이";
	int age = 0;
};

int main()
{
	//[문제] 개 10마리를 만들고 이름과 나이를 출력하라
	
	Dog* a = new Dog[10];

	for (int i = 0; i < 10; ++ i) {
		cout << "나이" << a[i].age << endl;
		cout << "이름" << a[i].name << endl;
	}
	save();
}





-----------------------------------
Thu Oct  4 10:21:24 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나
//3. 자료를 초기화하는 방법
//4. 자료를 정리하는 방법
//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
// 개의 이름과 나이는 값으로 표현할 수 있다.
struct Dog{
	string name = "진돌이";
	int age = 0;

	Dog(int n, string s) : age{ n }, name{ s } {}
};

//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

int main()
{
	Dog a{ 1,"댕댕이" };

	cout << a.age << "-" << a.name << endl;

	save();
}





-----------------------------------
Thu Oct  4 10:39:21 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나
//3. 자료를 초기화하는 방법
//4. 자료를 정리하는 방법
//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
// 개의 이름과 나이는 값으로 표현할 수 있다.
struct Dog{
	string name;
	int age;

	Dog() : age{ 1 }, name{ "진돌이" } {};
	Dog(int n, string s) : age{ n }, name{ s } {}
};

//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

int main()
{
	//[문제]Dog 10마리를 만들고 적당한 이름으로 초기화 하라

	Dog a[10]{ { 1,"한살" }, { 2,"두살" }, {3,"세살"} };
	
	for (int i = 0; i < 10; ++i)
		cout << a[i].name << "-" << a[i].age << endl;

	save();
}





-----------------------------------
Thu Oct  4 10:41:03 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나
//3. 자료를 초기화하는 방법
//4. 자료를 정리하는 방법
//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
// 개의 이름과 나이는 값으로 표현할 수 있다.
struct Dog{
	string name;
	int age;

	Dog() : age{ 1 }, name{ "진돌이" } {}
	Dog(int n, string s = { "이름도 알려줘}" }) : age{ n }, name{ s } {}
};

//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

int main()
{
	//[문제]Dog 10마리를 만들고 적당한 이름으로 초기화 하라

	Dog a[10]{ { 1,"한살" }, { 2,"두살" }, {3,"세살"}, {4} };
	
	for (int i = 0; i < 10; ++i)
		cout << a[i].name << "-" << a[i].age << endl;

	save();
}





-----------------------------------
Thu Oct  4 10:42:20 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나
//3. 자료를 초기화하는 방법
//4. 자료를 정리하는 방법
//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
// 개의 이름과 나이는 값으로 표현할 수 있다.
struct Dog{
	string name;
	int age;

	Dog() : age{ 1 }, name{ "진돌이" } {}
	Dog(int n, string s = { "이름도 알려줘" }) : age{ n }, name{ s } {}
};

//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

int main()
{
	//[문제]Dog 10마리를 HEAP에 만들고 적당한 이름으로 초기화 하라

	Dog* a = new Dog[10]{ { 1,"한살" }, { 2,"두살" }, {3,"세살"}, {4} };
	
	for (int i = 0; i < 10; ++i)
		cout << a[i].name << "-" << a[i].age << endl;

	save();
}





-----------------------------------
Thu Oct  4 10:46:12 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나
//3. 자료를 초기화하는 방법
//4. 자료를 정리하는 방법
//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
// 개의 이름과 나이는 값으로 표현할 수 있다.
struct Dog{
	string name;
	int age;

	Dog() : age{ 1 }, name{ "진돌이" } {}
	Dog(int n, string s = { "이름도 알려줘" }) : age{ n }, name{ s } {}
};

//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class A {
public:
	A() {}
};

int main()
{
	//[문제] A의 생성자를 호출해보자

	A a;
	save();
}





-----------------------------------
Thu Oct  4 10:49:42 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나
//3. 자료를 초기화하는 방법
//4. 자료를 정리하는 방법
//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
// 개의 이름과 나이는 값으로 표현할 수 있다.
struct Dog{
	string name;
	int age;

	Dog() : age{ 1 }, name{ "진돌이" } {}
	Dog(int n, string s = { "이름도 알려줘" }) : age{ n }, name{ s } {}
};

//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class A {
public:
	A() {}
};

int main()
{
	//[문제] A의 생성자를 호출해보자

	A ();
	save();
}





-----------------------------------
Thu Oct  4 10:50:52 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나
//3. 자료를 초기화하는 방법
//4. 자료를 정리하는 방법
//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
// 개의 이름과 나이는 값으로 표현할 수 있다.
struct Dog{
	string name;
	int age;

	Dog() : age{ 1 }, name{ "진돌이" } {}
	Dog(int n, string s = { "이름도 알려줘" }) : age{ n }, name{ s } {}
};

//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class A {
public:
	A() {
		cout << "A의 default 생성자가 호출됨" << endl;
	}
};

int main()
{
	//[문제] A의 생성자를 호출해보자

	A a;
	save();
}





-----------------------------------
Thu Oct  4 10:51:05 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나
//3. 자료를 초기화하는 방법
//4. 자료를 정리하는 방법
//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
// 개의 이름과 나이는 값으로 표현할 수 있다.
struct Dog{
	string name;
	int age;

	Dog() : age{ 1 }, name{ "진돌이" } {}
	Dog(int n, string s = { "이름도 알려줘" }) : age{ n }, name{ s } {}
};

//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class A {
public:
	A() {
		cout << "A의 default 생성자가 호출됨" << endl;
	}
};

int main()
{
	//[문제] A의 생성자를 호출해보자

	A a;
	A();
	save();
}





-----------------------------------
Thu Oct  4 10:51:34 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나
//3. 자료를 초기화하는 방법
//4. 자료를 정리하는 방법
//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
// 개의 이름과 나이는 값으로 표현할 수 있다.
struct Dog{
	string name;
	int age;

	Dog() : age{ 1 }, name{ "진돌이" } {}
	Dog(int n, string s = { "이름도 알려줘" }) : age{ n }, name{ s } {}
};

//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class A {
public:
	A() {
		cout << "A의 default 생성자가 호출됨" << endl;
	}
};

int main()
{
	//[문제] A의 생성자를 호출해보자

	A a;
	A();
	new A;
	save();
}





-----------------------------------
Thu Oct  4 10:51:54 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나
//3. 자료를 초기화하는 방법
//4. 자료를 정리하는 방법
//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
// 개의 이름과 나이는 값으로 표현할 수 있다.
struct Dog{
	string name;
	int age;

	Dog() : age{ 1 }, name{ "진돌이" } {}
	Dog(int n, string s = { "이름도 알려줘" }) : age{ n }, name{ s } {}
};

//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class A {
public:
	A() {
		cout << "A의 default 생성자가 호출됨" << endl;
	}
};

int main()
{
	//[문제] A의 생성자를 호출해보자

	A a;
	A();
	new A;
	new A();
	save();
}





-----------------------------------
Thu Oct  4 11:00:30 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나

//3. 자료를 초기화하는 방법
//		-생성자 함수를 만들어 초기화 한다.

//4. 자료를 정리하는 방법
//		-소멸자(destructor, dtor) 함수를 만들어 정리한다.
//		소멸자: 메모리를 삭제하는 것이 절대 아니다.
//				메모리가 사라지기 직전에 호출되는 함수이다.

//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
// 개의 이름과 나이는 값으로 표현할 수 있다.
struct Dog{
	string name;
	int age;

	Dog() : age{ 1 }, name{ "진돌이" } {}
	Dog(int n, string s = { "이름도 알려줘" }) : age{ n }, name{ s } {}
};

//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class A {
public:
	A() {
		cout << "A의 default 생성자가 호출됨" << endl;
	}
	~A(){
		cout << "이 함수는 객체가 소멸되기 직전에 호출됨" << endl;
	}
};

int main()
{
	//[문제] A의 생성자를 호출해보자

	A a;
	A();
	new A;
	new A();
	save();
}





-----------------------------------
Thu Oct  4 11:01:05 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나

//3. 자료를 초기화하는 방법
//		-생성자 함수를 만들어 초기화 한다.

//4. 자료를 정리하는 방법
//		-소멸자(destructor, dtor) 함수를 만들어 정리한다.
//		소멸자: 메모리를 삭제하는 것이 절대 아니다.
//				메모리가 사라지기 직전에 호출되는 함수이다.

//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
// 개의 이름과 나이는 값으로 표현할 수 있다.
struct Dog{
	string name;
	int age;

	Dog() : age{ 1 }, name{ "진돌이" } {}
	Dog(int n, string s = { "이름도 알려줘" }) : age{ n }, name{ s } {}
};

//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class A {
public:
	A() {
		cout << "A의 default 생성자가 호출됨" << endl;
	}
	~A(){
		cout << "이 함수는 객체가 소멸되기 직전에 호출됨" << endl;
	}
};

int main()
{
	//[문제] A의 생성자를 호출해보자

	A a;
	A();
	new A;
	new A();
	save();
}





-----------------------------------
Thu Oct  4 11:01:27 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나

//3. 자료를 초기화하는 방법
//		-생성자 함수를 만들어 초기화 한다.

//4. 자료를 정리하는 방법
//		-소멸자(destructor, dtor) 함수를 만들어 정리한다.
//		소멸자: 메모리를 삭제하는 것이 절대 아니다.
//				메모리가 사라지기 직전에 호출되는 함수이다.

//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
// 개의 이름과 나이는 값으로 표현할 수 있다.
struct Dog{
	string name;
	int age;

	Dog() : age{ 1 }, name{ "진돌이" } {}
	Dog(int n, string s = { "이름도 알려줘" }) : age{ n }, name{ s } {}
};

//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class A {
public:
	A() {
		cout << "A의 default 생성자가 호출됨" << endl;
	}
	~A(){
		cout << "이 함수는 객체가 소멸되기 직전에 호출됨" << endl;
	}
};

int main()
{
	//[문제] A의 생성자를 호출해보자

	A a;
	//A();
	//new A;
	//new A();
	save();
}





-----------------------------------
Thu Oct  4 11:01:34 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나

//3. 자료를 초기화하는 방법
//		-생성자 함수를 만들어 초기화 한다.

//4. 자료를 정리하는 방법
//		-소멸자(destructor, dtor) 함수를 만들어 정리한다.
//		소멸자: 메모리를 삭제하는 것이 절대 아니다.
//				메모리가 사라지기 직전에 호출되는 함수이다.

//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
// 개의 이름과 나이는 값으로 표현할 수 있다.
struct Dog{
	string name;
	int age;

	Dog() : age{ 1 }, name{ "진돌이" } {}
	Dog(int n, string s = { "이름도 알려줘" }) : age{ n }, name{ s } {}
};

//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class A {
public:
	A() {
		cout << "A의 default 생성자가 호출됨" << endl;
	}
	~A(){
		cout << "이 함수는 객체가 소멸되기 직전에 호출됨" << endl;
	}
};

int main()
{
	//[문제] A의 생성자를 호출해보자

	A a;
	A();
	//new A;
	//new A();
	save();
}





-----------------------------------
Thu Oct  4 11:01:46 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나

//3. 자료를 초기화하는 방법
//		-생성자 함수를 만들어 초기화 한다.

//4. 자료를 정리하는 방법
//		-소멸자(destructor, dtor) 함수를 만들어 정리한다.
//		소멸자: 메모리를 삭제하는 것이 절대 아니다.
//				메모리가 사라지기 직전에 호출되는 함수이다.

//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
// 개의 이름과 나이는 값으로 표현할 수 있다.
struct Dog{
	string name;
	int age;

	Dog() : age{ 1 }, name{ "진돌이" } {}
	Dog(int n, string s = { "이름도 알려줘" }) : age{ n }, name{ s } {}
};

//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class A {
public:
	A() {
		cout << "A의 default 생성자가 호출됨" << endl;
	}
	~A(){
		cout << "이 함수는 객체가 소멸되기 직전에 호출됨" << endl;
	}
};

int main()
{
	//[문제] A의 생성자를 호출해보자

	//A a;
	//A();
	new A;
	//new A();
	save();
}





-----------------------------------
Thu Oct  4 11:01:52 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나

//3. 자료를 초기화하는 방법
//		-생성자 함수를 만들어 초기화 한다.

//4. 자료를 정리하는 방법
//		-소멸자(destructor, dtor) 함수를 만들어 정리한다.
//		소멸자: 메모리를 삭제하는 것이 절대 아니다.
//				메모리가 사라지기 직전에 호출되는 함수이다.

//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
// 개의 이름과 나이는 값으로 표현할 수 있다.
struct Dog{
	string name;
	int age;

	Dog() : age{ 1 }, name{ "진돌이" } {}
	Dog(int n, string s = { "이름도 알려줘" }) : age{ n }, name{ s } {}
};

//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class A {
public:
	A() {
		cout << "A의 default 생성자가 호출됨" << endl;
	}
	~A(){
		cout << "이 함수는 객체가 소멸되기 직전에 호출됨" << endl;
	}
};

int main()
{
	//[문제] A의 생성자를 호출해보자

	//A a;
	//A();
	new A;
	new A();
	save();
}





-----------------------------------
Thu Oct  4 11:01:59 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나

//3. 자료를 초기화하는 방법
//		-생성자 함수를 만들어 초기화 한다.

//4. 자료를 정리하는 방법
//		-소멸자(destructor, dtor) 함수를 만들어 정리한다.
//		소멸자: 메모리를 삭제하는 것이 절대 아니다.
//				메모리가 사라지기 직전에 호출되는 함수이다.

//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
// 개의 이름과 나이는 값으로 표현할 수 있다.
struct Dog{
	string name;
	int age;

	Dog() : age{ 1 }, name{ "진돌이" } {}
	Dog(int n, string s = { "이름도 알려줘" }) : age{ n }, name{ s } {}
};

//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class A {
public:
	A() {
		cout << "A의 default 생성자가 호출됨" << endl;
	}
	~A(){
		cout << "이 함수는 객체가 소멸되기 직전에 호출됨" << endl;
	}
};

int main()
{
	//[문제] A의 생성자를 호출해보자

	A a;
	A();
	new A;
	new A();
	save();
}





-----------------------------------
Thu Oct  4 11:02:54 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나

//3. 자료를 초기화하는 방법
//		-생성자 함수를 만들어 초기화 한다.

//4. 자료를 정리하는 방법
//		-소멸자(destructor, dtor) 함수를 만들어 정리한다.
//		소멸자: 메모리를 삭제하는 것이 절대 아니다.
//				메모리가 사라지기 직전에 호출되는 함수이다.

//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
// 개의 이름과 나이는 값으로 표현할 수 있다.
struct Dog{
	string name;
	int age;

	Dog() : age{ 1 }, name{ "진돌이" } {}
	Dog(int n, string s = { "이름도 알려줘" }) : age{ n }, name{ s } {}
};

//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class A {
public:
	A() {
		cout << "A의 default 생성자가 호출됨" << endl;
	}
	~A(){
		cout << "이 함수는 객체가 소멸되기 직전에 호출됨" << endl;
	}
};

int main()
{
	//[문제] A의 생성자를 호출해보자
	cout << "메인시작" << endl;
	A a;
	save();
	cout << "메인 끝" << endl;

}





-----------------------------------
Thu Oct  4 11:03:21 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나

//3. 자료를 초기화하는 방법
//		-생성자 함수를 만들어 초기화 한다.

//4. 자료를 정리하는 방법
//		-소멸자(destructor, dtor) 함수를 만들어 정리한다.
//		소멸자: 메모리를 삭제하는 것이 절대 아니다.
//				메모리가 사라지기 직전에 호출되는 함수이다.

//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
// 개의 이름과 나이는 값으로 표현할 수 있다.
struct Dog{
	string name;
	int age;

	Dog() : age{ 1 }, name{ "진돌이" } {}
	Dog(int n, string s = { "이름도 알려줘" }) : age{ n }, name{ s } {}
};

//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class A {
public:
	A() {
		cout << "A의 default 생성자가 호출됨" << endl;
	}
	~A(){
		cout << "이 함수는 객체가 소멸되기 직전에 호출됨" << endl;
	}
};

int main()
{
	//[문제] A의 생성자를 호출해보자
	cout << "메인시작" << endl;
	A a;
	A();
	save();
	cout << "메인 끝" << endl;

}





-----------------------------------
Thu Oct  4 11:03:40 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나

//3. 자료를 초기화하는 방법
//		-생성자 함수를 만들어 초기화 한다.

//4. 자료를 정리하는 방법
//		-소멸자(destructor, dtor) 함수를 만들어 정리한다.
//		소멸자: 메모리를 삭제하는 것이 절대 아니다.
//				메모리가 사라지기 직전에 호출되는 함수이다.

//5. 기본자료형(POD)과 같은 방법으로 사용하려면?

// 개를 이름과 나이로 표현해보자
// 개의 이름과 나이는 값으로 표현할 수 있다.
struct Dog{
	string name;
	int age;

	Dog() : age{ 1 }, name{ "진돌이" } {}
	Dog(int n, string s = { "이름도 알려줘" }) : age{ n }, name{ s } {}
};

//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class A {
public:
	A() {
		cout << "A의 default 생성자가 호출됨" << endl;
	}
	~A(){
		cout << "이 함수는 객체가 소멸되기 직전에 호출됨" << endl;
	}
};

int main()
{
	//[문제] A의 생성자를 호출해보자
	cout << "메인시작" << endl;
	
	{A a; }
	save();
	cout << "메인 끝" << endl;

}





-----------------------------------
Thu Oct  4 11:07:49 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나

//3. 자료를 초기화하는 방법
//		-생성자 함수를 만들어 초기화 한다.

//4. 자료를 정리하는 방법
//		-소멸자(destructor, dtor) 함수를 만들어 정리한다.
//		소멸자: 메모리를 삭제하는 것이 절대 아니다.
//				메모리가 사라지기 직전에 호출되는 함수이다.

//5. 기본자료형(POD)과 같은 방법으로 사용하려면?


//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class Dog {
public:
	int age;
	Dog() {
		age = 1;
		cout << age << endl;
	}
	~Dog(){
		age = 2;
		cout << age << endl;
	}
};

//[문제] 나이가 다른 개 5마리를 만들어라
//생성자와 소멸자에 나이를 화면 출력하여 관찰하라 
int main()
{
	Dog a[5];

	save();
}





-----------------------------------
Thu Oct  4 11:13:07 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나

//3. 자료를 초기화하는 방법
//		-생성자 함수를 만들어 초기화 한다.

//4. 자료를 정리하는 방법
//		-소멸자(destructor, dtor) 함수를 만들어 정리한다.
//		소멸자: 메모리를 삭제하는 것이 절대 아니다.
//				메모리가 사라지기 직전에 호출되는 함수이다.

//5. 기본자료형(POD)과 같은 방법으로 사용하려면?


//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class Dog {
public:
	int age;

	Dog() : age{ 1 } {}
	Dog(int n) {
		cout <<"생성 나이는 - " <<age << endl;
	}
	~Dog(){
		++age;
		cout <<"소멸 나이는 - " << age << endl;
	}
};

//[문제] 나이가 다른 개 5마리를 만들어라
//생성자와 소멸자에 나이를 화면 출력하여 관찰하라 
int main()
{
	Dog a[5]{ {1},{3},{5},{7},{9} };

	save();
}





-----------------------------------
Thu Oct  4 11:16:09 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나

//3. 자료를 초기화하는 방법
//		-생성자 함수를 만들어 초기화 한다.

//4. 자료를 정리하는 방법
//		-소멸자(destructor, dtor) 함수를 만들어 정리한다.
//		소멸자: 메모리를 삭제하는 것이 절대 아니다.
//				메모리가 사라지기 직전에 호출되는 함수이다.

//5. 기본자료형(POD)과 같은 방법으로 사용하려면?


//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class Dog {
public:
	int age;

	Dog() : age{ 1 } {}

	Dog(int n) :age{ n } {
		cout << "생성 나이는 - " << age << endl;
	} 
	~Dog(){
		++age;
		cout <<"소멸 나이는 - " << age << endl;
	}
};

//[문제] 나이가 다른 개 5마리를 만들어라
//생성자와 소멸자에 나이를 화면 출력하여 관찰하라 
int main()
{
	Dog a[5]{ {1},{3},{5},{7},{9} };

	save();
}





-----------------------------------
Thu Oct  4 11:16:32 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나

//3. 자료를 초기화하는 방법
//		-생성자 함수를 만들어 초기화 한다.

//4. 자료를 정리하는 방법
//		-소멸자(destructor, dtor) 함수를 만들어 정리한다.
//		소멸자: 메모리를 삭제하는 것이 절대 아니다.
//				메모리가 사라지기 직전에 호출되는 함수이다.

//5. 기본자료형(POD)과 같은 방법으로 사용하려면?


//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class Dog {
public:
	int age;

	Dog() : age{ 1 } {}

	Dog(int n) :age{ n } {
		cout << "생성 나이는 - " << age << endl;
	} 
	~Dog(){
		++age;
		cout <<"소멸 나이는 - " << age << endl;
	}
};

//[문제] 나이가 다른 개 5마리를 만들어라
//생성자와 소멸자에 나이를 화면 출력하여 관찰하라 
int main()
{
	Dog a[5]{ {1},{3},{5},{7},{9} };

	save();
}





-----------------------------------
Thu Oct  4 11:16:52 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나

//3. 자료를 초기화하는 방법
//		-생성자 함수를 만들어 초기화 한다.

//4. 자료를 정리하는 방법
//		-소멸자(destructor, dtor) 함수를 만들어 정리한다.
//		소멸자: 메모리를 삭제하는 것이 절대 아니다.
//				메모리가 사라지기 직전에 호출되는 함수이다.

//5. 기본자료형(POD)과 같은 방법으로 사용하려면?


//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class Dog {
public:
	int age;

	Dog() : age{ 1 } {}

	Dog(int n) :age{ n } {
		cout << "생성 나이는 - " << age << endl;
	} 
	~Dog(){
		age;
		cout <<"소멸 나이는 - " << age << endl;
	}
};

//[문제] 나이가 다른 개 5마리를 만들어라
//생성자와 소멸자에 나이를 화면 출력하여 관찰하라 
int main()
{
	Dog a[5]{ {1},{3},{5},{7},{9} };

	save();
}





-----------------------------------
Thu Oct  4 11:17:00 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나

//3. 자료를 초기화하는 방법
//		-생성자 함수를 만들어 초기화 한다.

//4. 자료를 정리하는 방법
//		-소멸자(destructor, dtor) 함수를 만들어 정리한다.
//		소멸자: 메모리를 삭제하는 것이 절대 아니다.
//				메모리가 사라지기 직전에 호출되는 함수이다.

//5. 기본자료형(POD)과 같은 방법으로 사용하려면?


//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class Dog {
public:
	int age;

	Dog() : age{ 1 } {}

	Dog(int n) :age{ n } {
		cout << "생성 나이는 - " << age << endl;
	} 
	~Dog(){
		age;
		cout <<"소멸 나이는 - " << age << endl;
	}
};

//[문제] 나이가 다른 개 5마리를 만들어라
//생성자와 소멸자에 나이를 화면 출력하여 관찰하라 
int main()
{
	Dog a[5]{ {1},{3},{5},{7},{9} };

	save();
}





-----------------------------------
Thu Oct  4 11:18:11 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나

//3. 자료를 초기화하는 방법
//		-생성자 함수를 만들어 초기화 한다.

//4. 자료를 정리하는 방법
//		-소멸자(destructor, dtor) 함수를 만들어 정리한다.
//		소멸자: 메모리를 삭제하는 것이 절대 아니다.
//				메모리가 사라지기 직전에 호출되는 함수이다.

//5. 기본자료형(POD)과 같은 방법으로 사용하려면?


//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class Dog {
public:
	int age;

	Dog() : age{ 1 } {}

	Dog(int n) :age{ n } {
		cout << "생성 나이는 - " << age << endl;
	} 
	~Dog(){
		age;
		cout <<"소멸 나이는 - " << age << endl;
	}
};

//[문제] 나이가 다른 개 5마리를 만들어라
//생성자와 소멸자에 나이를 화면 출력하여 관찰하라 
int main()
{
	new Dog[5]{ {1},{3},{5},{7},{9} };

	save();
}





-----------------------------------
Thu Oct  4 11:18:26 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.4		         월목     (6주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나

//3. 자료를 초기화하는 방법
//		-생성자 함수를 만들어 초기화 한다.

//4. 자료를 정리하는 방법
//		-소멸자(destructor, dtor) 함수를 만들어 정리한다.
//		소멸자: 메모리를 삭제하는 것이 절대 아니다.
//				메모리가 사라지기 직전에 호출되는 함수이다.

//5. 기본자료형(POD)과 같은 방법으로 사용하려면?


//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class Dog {
public:
	int age;

	Dog() : age{ 1 } {}

	Dog(int n) :age{ n } {
		cout << "생성 나이는 - " << age << endl;
	} 
	~Dog(){
		age;
		cout <<"소멸 나이는 - " << age << endl;
	}
};

//[문제] 나이가 다른 개 5마리를 만들어라
//생성자와 소멸자에 나이를 화면 출력하여 관찰하라 
int main()
{
	Dog* a = new Dog[5]{ {1},{3},{5},{7},{9} };

	save();
}





-----------------------------------
Mon Oct  8 13:42:19 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나

//3. 자료를 초기화하는 방법
//		-생성자 함수를 만들어 초기화 한다.

//4. 자료를 정리하는 방법
//		-소멸자(destructor, dtor) 함수를 만들어 정리한다.
//		소멸자: 메모리를 삭제하는 것이 절대 아니다.
//				메모리가 사라지기 직전에 호출되는 함수이다.

//5. 기본자료형(POD)과 같은 방법으로 사용하려면?


//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class Dog {

	int age;
public:
	Dog(int n) : age(n) {
		cout << age << "살 Dog 생성" << endl;
	};
	~Dog(){
		cout << age << "살 Dog 소멸" << endl;
	}
};

//[문제] 나이가 다른 개 5마리를 만들어라
//생성자와 소멸자에 나이를 화면 출력하여 관찰하라 
int main()
{
	Dog(5);

	save();
}





-----------------------------------
Mon Oct  8 13:42:36 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나

//3. 자료를 초기화하는 방법
//		-생성자 함수를 만들어 초기화 한다.

//4. 자료를 정리하는 방법
//		-소멸자(destructor, dtor) 함수를 만들어 정리한다.
//		소멸자: 메모리를 삭제하는 것이 절대 아니다.
//				메모리가 사라지기 직전에 호출되는 함수이다.

//5. 기본자료형(POD)과 같은 방법으로 사용하려면?


//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class Dog {

	int age;
public:
	Dog(int n) : age(n) {
		cout << age << "살 Dog 생성" << endl;
	};
	~Dog(){
		cout << age << "살 Dog 소멸" << endl;
	}
};


int main()
{
	Dog(5);
	Dog(3);


	save();
}





-----------------------------------
Mon Oct  8 13:43:28 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나

//3. 자료를 초기화하는 방법
//		-생성자 함수를 만들어 초기화 한다.

//4. 자료를 정리하는 방법
//		-소멸자(destructor, dtor) 함수를 만들어 정리한다.
//		소멸자: 메모리를 삭제하는 것이 절대 아니다.
//				메모리가 사라지기 직전에 호출되는 함수이다.

//5. 기본자료형(POD)과 같은 방법으로 사용하려면?


//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class Dog {

	int age;
public:
	Dog(int n) : age(n) {
		cout << age << "살 Dog 생성" << endl;
	};
	~Dog(){
		cout << age << "살 Dog 소멸" << endl;
	}
};


int main()
{
	Dog a(5);
	Dog(3);


	save();
}





-----------------------------------
Mon Oct  8 13:43:49 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나

//3. 자료를 초기화하는 방법
//		-생성자 함수를 만들어 초기화 한다.

//4. 자료를 정리하는 방법
//		-소멸자(destructor, dtor) 함수를 만들어 정리한다.
//		소멸자: 메모리를 삭제하는 것이 절대 아니다.
//				메모리가 사라지기 직전에 호출되는 함수이다.

//5. 기본자료형(POD)과 같은 방법으로 사용하려면?


//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class Dog {

	int age;
public:
	Dog(int n) : age(n) {
		cout << age << "살 Dog 생성" << endl;
	};
	~Dog(){
		cout << age << "살 Dog 소멸" << endl;
	}
};


int main()
{
	Dog a(5);
	Dog b(3);


	save();
}





-----------------------------------
Mon Oct  8 13:44:56 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나

//3. 자료를 초기화하는 방법
//		-생성자 함수를 만들어 초기화 한다.

//4. 자료를 정리하는 방법
//		-소멸자(destructor, dtor) 함수를 만들어 정리한다.
//		소멸자: 메모리를 삭제하는 것이 절대 아니다.
//				메모리가 사라지기 직전에 호출되는 함수이다.

//5. 기본자료형(POD)과 같은 방법으로 사용하려면?


//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class Dog {

	int age;
public:
	Dog(int n) : age(n) {
		cout << age << "살 Dog 생성" << endl;
	};
	~Dog(){
		cout << age << "살 Dog 소멸" << endl;
	}
};


int main()
{
	Dog d[5]{ 1,2,3,4,5 };


	save();
}





-----------------------------------
Mon Oct  8 13:45:44 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나

//3. 자료를 초기화하는 방법
//		-생성자 함수를 만들어 초기화 한다.

//4. 자료를 정리하는 방법
//		-소멸자(destructor, dtor) 함수를 만들어 정리한다.
//		소멸자: 메모리를 삭제하는 것이 절대 아니다.
//				메모리가 사라지기 직전에 호출되는 함수이다.

//5. 기본자료형(POD)과 같은 방법으로 사용하려면?


//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class Dog {

	int age;
public:
	Dog(int n) : age(n) {
		cout << age << "살 Dog 생성" << endl;
	};
	~Dog(){
		cout << age << "살 Dog 소멸" << endl;
	}
};


int main()
{
	Dog d[5]{ 1,2,3,4,5 };


	save();

	cout << "메인 끝" << endl;
}





-----------------------------------
Mon Oct  8 13:46:24 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)
 
 10.10 과제

 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)
 
 [숙제] : C++ 클래스를 읽어보자
 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//class
//1.왜 필요한가
//		-더 큰 데이터가 필요하다.
//		-데이터와 함께 행동도 프로그램하고 싶다.
//2. 어떻게 만드나

//3. 자료를 초기화하는 방법
//		-생성자 함수를 만들어 초기화 한다.

//4. 자료를 정리하는 방법
//		-소멸자(destructor, dtor) 함수를 만들어 정리한다.
//		소멸자: 메모리를 삭제하는 것이 절대 아니다.
//				메모리가 사라지기 직전에 호출되는 함수이다.

//5. 기본자료형(POD)과 같은 방법으로 사용하려면?


//개를 만들때 메모리를 내가 원하는 대로 write하고 싶다.
//객체가 만들어질때 원하는 값을 전달받아 메모리를 초기화 할 수 있다.
//-->	이런 동작은 특별한 함수를 사용하면 가능하다.
//		이함수의 이름은 생성자(creator , ctor)라고 부른다.
//		생성자 함수의 이름은 클래스의 이름과 같다.
//		생성자 함수는 리턴하지 않는다.

class Dog {

	int age;
public:
	Dog(int n) : age(n) {
		cout << age << "살 Dog 생성" << endl;
	};
	~Dog(){
		cout << age << "살 Dog 소멸" << endl;
	}
};


int main()
{
	{
		Dog d[5]{ 1,2,3,4,5 };

	}
	save();

	cout << "메인 끝" << endl;
}





-----------------------------------
Mon Oct  8 13:55:59 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	string name;
	int age;
public:
	Dog() : age(0), name("무명") {};
	Dog(int n, string s) : age(n), name(s) {
		cout << age << "살" << name << "생성" << endl;
	}
	~Dog(){
		cout << age << "살" << name << "소멸" << endl;
	}
};


int main()
{
 	Dog a(5, "시월");		//5살, 시월
	Dog b;					//0살, 무명
	save();
}





-----------------------------------
Mon Oct  8 13:56:21 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	string name;
	int age;
public:
	Dog() : age(0), name("무명") {};
	Dog(int n, string s) : age(n), name(s) {
		cout << age << "살" << name << "생성" << endl;
	}
	~Dog(){
		cout << age << "살" << name << "소멸" << endl;
	}
};


int main()
{
 	Dog a(5, "시월");		//5살, 시월
	Dog b;					//0살, 무명
	save();
}





-----------------------------------
Mon Oct  8 13:56:44 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	string name;
	int age;
public:
	Dog() : age(0), name("무명") {};
	Dog(int n, string s) : age(n), name(s) {
		cout << age << "살" << name << "생성" << endl;
	}
	~Dog(){
		cout << age << "살" << name << "소멸" << endl;
	}
};


int main()
{
 	Dog a(5, "시월");		//5살, 시월
	Dog b;					//0살, 무명
	save();
}





-----------------------------------
Mon Oct  8 13:57:37 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	string name;
	int age;
public:
	Dog() : age(0), name("무명") {
		cout << age << "살" << name << "생성" << endl;
	};
	Dog(int n, string s) : age(n), name(s) {
		cout << age << "살" << name << "생성" << endl;
	}
	~Dog(){
		cout << age << "살" << name << "소멸" << endl;
	}
};


int main()
{
 	Dog a(5, "시월");		//5살, 시월
	Dog b;					//0살, 무명
	save();
}





-----------------------------------
Mon Oct  8 14:05:14 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	string name;
	int age;
public:
	Dog() : age(0), name("무명") {
		cout << age << "살" << name << "생성" << endl;
	};
	Dog(int n, string s) : age(n), name(s) {
		cout << age << "살" << name << "생성" << endl;
		cout << this << endl;
	}
	~Dog(){
		cout << age << "살" << name << "소멸" << endl;
	}
};


int main()
{
 	Dog a(5, "시월");		//5살, 시월
	Dog b;					//0살, 무명
	save();
}





-----------------------------------
Mon Oct  8 14:05:28 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	string name;
	int age;
public:
	Dog() : age(0), name("무명") {
		cout << age << "살" << name << "생성" << endl;
		cout << this << endl;
	};
	Dog(int n, string s) : age(n), name(s) {
		cout << age << "살" << name << "생성" << endl;
		cout << this << endl;
	}
	~Dog(){
		cout << age << "살" << name << "소멸" << endl;
	}
};


int main()
{
 	Dog a(5, "시월");		//5살, 시월
	Dog b;					//0살, 무명
	save();
}





-----------------------------------
Mon Oct  8 14:13:55 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	string name;
	int age;
public:
	Dog() : age(0), name("무명") {
		cout << age << "살" << name << "생성" << endl;
	};
	Dog(int n, string s) : age(n), name(s) {
		cout << age << "살" << name << "생성" << endl;
	}
	~Dog(){
		cout << age << "살" << name << "소멸" << endl;
	}
};

// 개 1마리를 동적할당 하라. 이름은 "dynamic",나이는 3살
int main()
{
	Dog *p = new Dog(3,"dynamic");
	save();
}





-----------------------------------
Mon Oct  8 14:15:58 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	string name;
	int age;
public:
	Dog() : age(0), name("무명") {
		cout << age << "살" << name << "생성" << endl;
	};
	Dog(int n, string s) : age(n), name(s) {
		cout << age << "살" << name << "생성" << endl;
	}
	~Dog(){
		cout << age << "살" << name << "소멸" << endl;
	}
};

// 개 1마리를 동적할당 하라. 이름은 "dynamic",나이는 3살
int main()
{
	Dog *p = new Dog (3,"dynamic");

	delete p;
	save();
}





-----------------------------------
Mon Oct  8 14:17:27 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	string name;
	int age;
public:
	Dog() : age(0), name("무명") {
		cout << age << "살" << name << "생성" << endl;
	};
	Dog(int n, string s) : age(n), name(s) {
		cout << age << "살" << name << "생성" << endl;
	}
	~Dog(){
		cout << age << "살" << name << "소멸" << endl;
	}
};
	Dog *p = new Dog (3,"dynamic");
// 개 1마리를 동적할당 하라. 이름은 "dynamic",나이는 3살
int main()
{


	delete p;
	save();
}





-----------------------------------
Mon Oct  8 14:17:34 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	string name;
	int age;
public:
	Dog() : age(0), name("무명") {
		cout << age << "살" << name << "생성" << endl;
	};
	Dog(int n, string s) : age(n), name(s) {
		cout << age << "살" << name << "생성" << endl;
	}
	~Dog(){
		cout << age << "살" << name << "소멸" << endl;
	}
};
	Dog *p = new Dog (3,"dynamic");
// 개 1마리를 동적할당 하라. 이름은 "dynamic",나이는 3살
int main()
{


	delete p;
	save();
}





-----------------------------------
Mon Oct  8 14:20:11 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	string name;
	int age;
public:
	Dog() : age(0), name("무명") {
		cout << age << "살" << name << "생성" << endl;
	};
	Dog(int n, string s) : age(n), name(s) {
		cout << age << "살" << name << "생성" << endl;
	}
	~Dog(){
		cout << age << "살" << name << "소멸" << endl;
	}
};
Dog *p = new Dog (3,"전역dynamic");
// 개 1마리를 동적할당 하라. 이름은 "dynamic",나이는 3살
int main()
{
	Dog *p = new Dog(3, "지역dynamic");

	delete p;	//지역
	delete ::p;	//전역
	save();
}





-----------------------------------
Mon Oct  8 14:35:49 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	int age;
	string name;
public:
	Dog() : age(0), name("무명") {
		cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		cout << (void*)this << "생성자 - " << age << "살, 이름 : " << name << endl;
	}
};
	
Dog* p = new Dog(1, "동적");
// 개 1마리를 동적할당 하라. 이름은 "dynamic",나이는 3살
int main()
{
	new Dog(3,"동적");
	save();
}





-----------------------------------
Mon Oct  8 14:36:48 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	int age;
	string name;
public:
	Dog() : age(0), name("무명") {
		cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		cout << (void*)this << "생성자 - " << age << "살, 이름 : " << name << endl;
	}
};


Dog* p = new Dog(1, "동적");
Dog d(10, "전역");
// 개 1마리를 동적할당 하라. 이름은 "dynamic",나이는 3살
int main()
{
	new Dog(3,"동적");

	Dog(5, "스택");
	save();
}





-----------------------------------
Mon Oct  8 14:39:10 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	int age;
	string name;
public:
	Dog() : age(0), name("무명") {
		cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		cout << (void*)this << "생성자 - " << age << "살, 이름 : " << name << endl;
	}
	~Dog(){
		cout << (void*)this << "소멸자 - " << age << "살, 이름 : " << name << endl;
	}
};


Dog* p = new Dog(1, "동적");
Dog d(10, "전역");
// 개 1마리를 동적할당 하라. 이름은 "dynamic",나이는 3살
int main()
{
	Dog* p = new Dog(3,"동적");

	Dog(5, "스택");
	delete p;
	delete ::p;
	save();
}





-----------------------------------
Mon Oct  8 14:39:28 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	int age;
	string name;
public:
	Dog() : age(0), name("무명") {
		cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		cout << (void*)this << "생성자 - " << age << "살, 이름 : " << name << endl;
	}
	~Dog(){
		cout << (void*)this << "소멸자 - " << age << "살, 이름 : " << name << endl;
	}
};


Dog* p = new Dog(1, "동적");
Dog d(10, "전역");
// 개 1마리를 동적할당 하라. 이름은 "dynamic",나이는 3살
int main()
{
	Dog* p = new Dog(3,"동적");

	Dog(5, "스택");
	delete ::p;
	delete p;
	save();
}





-----------------------------------
Mon Oct  8 14:45:20 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	int age;
	string name;
public:
	Dog() : age(0), name("무명") {
		cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		cout << (void*)this << "생성자 - " << age << "살, 이름 : " << name << endl;
	}
	~Dog(){
		cout << (void*)this << "소멸자 - " << age << "살, 이름 : " << name << endl;
	}
};


Dog* p = new Dog(1, "동적");
Dog d(10, "전역");
// 개 1마리를 동적할당 하라. 이름은 "dynamic",나이는 3살
int main()
{
	Dog* p = new Dog(3,"동적2");

	Dog(5, "스택");
	delete ::p;
	delete p;
	save();
}





-----------------------------------
Mon Oct  8 14:50:46 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	int age;
	string name;
public:
	Dog() : age(0), name("무명") {
		cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		cout << (void*)this << "생성자 - " << age << "살, 이름 : " << name << endl;
	}
	~Dog(){
		cout << (void*)this << "소멸자 - " << age << "살, 이름 : " << name << endl;
	}
};


Dog* p = new Dog(1, "동적");
Dog d(10, "전역");
// 개 1마리를 동적할당 하라. 이름은 "dynamic",나이는 3살
int main()
{
	Dog* p = new Dog(3,"동적2");

	Dog(5, "스택");
	delete ::p;
	delete p;
	save();
}





-----------------------------------
Mon Oct  8 14:58:26 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	int age;
	string name;
public:
	Dog() : age(0), name("무명") {
		cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		cout << (void*)this << "생성자 - " << age << "살, 이름 : " << name << endl;
	}
	~Dog(){
		cout << (void*)this << "소멸자 - " << age << "살, 이름 : " << name << endl;
	}
};



// 개 1마리를 동적할당 하라. 이름은 "dynamic",나이는 3살
int main()
{
	Dog* p = new Dog(3,"동적2");
	
	cout << p <<endl;

	delete p;
	save();
}





-----------------------------------
Mon Oct  8 14:59:58 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	int age;
	string name;
public:
	Dog() : age(0), name("무명") {
		cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		cout << (void*)this << " 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	~Dog(){
		cout << (void*)this << " 소멸자 - " << age << "살, 이름 : " << name << endl;
	}
};



// 개 1마리를 동적할당 하라. 이름은 "dynamic",나이는 3살
int main()
{
	Dog* p = new Dog(3,"동적2");
	
	cout << p <<endl; //p에 기록된 주소
	cout << &p << endl; //p 자신의 주소
	delete p;
	save();
}





-----------------------------------
Mon Oct  8 15:06:39 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	
public:
	int age;
	string name;
	Dog() : age(0), name("무명") {
		cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		cout << (void*)this << " 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	~Dog(){
		cout << (void*)this << " 소멸자 - " << age << "살, 이름 : " << name << endl;
	}
};

auto show(Dog);
auto show(Dog d) {
	cout << d.age << "살, 이름" << d.name << endl;
}

// Dog를 인자로 받아 이름과 나이를 출력하는 함수 show()를 선언ㄴ하고 정의해 보자.
int main()
{
	Dog a(1, "성공");
	show(a);
	save();
}





-----------------------------------
Mon Oct  8 15:07:35 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	
public:
	int age;
	string name;
	Dog() : age(0), name("무명") {
		//cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		//cout << (void*)this << " 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	~Dog(){
		//cout << (void*)this << " 소멸자 - " << age << "살, 이름 : " << name << endl;
	}
};

auto show(Dog);
auto show(Dog d) {
	cout << d.age << "살, 이름" << d.name << endl;
}

// Dog를 인자로 받아 이름과 나이를 출력하는 함수 show()를 선언ㄴ하고 정의해 보자.
int main()
{
	Dog a(1, "성공");
	show(a);
	save();
}





-----------------------------------
Mon Oct  8 15:07:42 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	
public:
	int age;
	string name;
	Dog() : age(0), name("무명") {
		//cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		//cout << (void*)this << " 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	~Dog(){
		cout << (void*)this << " 소멸자 - " << age << "살, 이름 : " << name << endl;
	}
};

auto show(Dog);
auto show(Dog d) {
	cout << d.age << "살, 이름" << d.name << endl;
}

// Dog를 인자로 받아 이름과 나이를 출력하는 함수 show()를 선언ㄴ하고 정의해 보자.
int main()
{
	Dog a(1, "성공");
	show(a);
	save();
}





-----------------------------------
Mon Oct  8 15:12:38 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	int age;
	string name;
public:
	
	int getAge() {
		return age;
	}

	auto getName() {
		return name;
	}

	Dog() : age(0), name("무명") {
		cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		cout << (void*)this << " 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	~Dog(){
		cout << (void*)this << " 소멸자 - " << age << "살, 이름 : " << name << endl;
	}
};


void show(Dog);
void show(Dog d) {
	cout << d.getName() << ", "  << d.getAge() << endl;
}

// Dog를 인자로 받아 이름과 나이를 출력하는 함수 show()를 선언ㄴ하고 정의해 보자.
int main()
{
	Dog a(1, "성공");
	show(a);
	save();
}





-----------------------------------
Mon Oct  8 15:12:50 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	int age;
	string name;
public:
	
	int getAge() {
		return age;
	}

	auto getName() {
		return name;
	}

	Dog() : age(0), name("무명") {
		//cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		//cout << (void*)this << " 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	~Dog(){
		//cout << (void*)this << " 소멸자 - " << age << "살, 이름 : " << name << endl;
	}
};


void show(Dog);
void show(Dog d) {
	cout << d.getName() << ", "  << d.getAge() << endl;
}

// Dog를 인자로 받아 이름과 나이를 출력하는 함수 show()를 선언ㄴ하고 정의해 보자.
int main()
{
	Dog a(1, "성공");
	show(a);
	save();
}





-----------------------------------
Mon Oct  8 15:14:33 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	int age;
	string name;
public:
	
	int getAge() {
		return age;
	}

	auto getName() {
		return name;
	}

	Dog() : age(0), name("무명") {
		cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		cout << (void*)this << " 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	~Dog(){
		cout << (void*)this << " 소멸자 - " << age << "살, 이름 : " << name << endl;
	}
};


void show(Dog);
void show(Dog d) {
	cout << d.getName() << ", "  << d.getAge() << "살" << endl;
}

// Dog를 인자로 받아 이름과 나이를 출력하는 함수 show()를 선언ㄴ하고 정의해 보자.
int main()
{
	Dog a(1, "성공");
	show(a);
	save();
}





-----------------------------------
Mon Oct  8 15:18:48 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.8		         월목     (7주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	int age;
	string name;
public:
	//다음시간에 정식 표기법
	int getAge() const{		//const를 사용해서 읽기는 가능하지만 쓰기 불가
		return age;
	}

	string getName() const{
		return name;
	}

	Dog() : age(0), name("무명") {
		cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		cout << (void*)this << " 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	~Dog(){
		cout << (void*)this << " 소멸자 - " << age << "살, 이름 : " << name << endl;
	}
};


void show(Dog);
void show(Dog d) {
	cout << d.getName() << ", "  << d.getAge() << "살" << endl;
}

// Dog를 인자로 받아 이름과 나이를 출력하는 함수 show()를 선언ㄴ하고 정의해 보자.
int main()
{
	Dog a(1, "성공");
	show(a);
	save();
}





-----------------------------------
Thu Oct 11 09:45:34 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (7주 2일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	int age;
	string name;
public:
	//다음시간에 정식 표기법
	int getAge() const{		//const를 사용해서 읽기는 가능하지만 쓰기 불가
		return age;
	}

	string getName() const{
		return name;
	}

	Dog() : age(0), name("무명") {
		cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		cout << (void*)this << " 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	~Dog(){
		cout << (void*)this << " 소멸자 - " << age << "살, 이름 : " << name << endl;
	}
};


void show(Dog);
void show(Dog d) {
	cout << d.getName() << ", "  << d.getAge() << "살" << endl;
}

// Dog를 인자로 받아 이름과 나이를 출력하는 함수 show()를 선언ㄴ하고 정의해 보자.
int main()
{
	Dog a(1, "성공");
	cout << "show start" << endl;
	show(a);
	cout << "shwo end" << endl;
	save();
}





-----------------------------------
Thu Oct 11 09:45:47 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (7주 2일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	int age;
	string name;
public:
	//다음시간에 정식 표기법
	int getAge() const{		//const를 사용해서 읽기는 가능하지만 쓰기 불가
		return age;
	}

	string getName() const{
		return name;
	}

	Dog() : age(0), name("무명") {
		cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		cout << (void*)this << " 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	~Dog(){
		cout << (void*)this << " 소멸자 - " << age << "살, 이름 : " << name << endl;
	}
};


void show(Dog);
void show(Dog d) {
	cout << d.getName() << ", "  << d.getAge() << "살" << endl;
}

// Dog를 인자로 받아 이름과 나이를 출력하는 함수 show()를 선언ㄴ하고 정의해 보자.
int main()
{
	Dog a(1, "성공");
	cout << "show start" << endl;
	show(a);
	cout << "show end" << endl;
	save();
}





-----------------------------------
Thu Oct 11 09:46:56 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (7주 2일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
class Dog {
	int age;
	string name;
public:
	//다음시간에 정식 표기법
	int getAge() const{		//const를 사용해서 읽기는 가능하지만 쓰기 불가
		return age;
	}

	string getName() const{
		return name;
	}

	Dog() : age(0), name("무명") {
		cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		cout << (void*)this << " 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	~Dog(){
		cout << (void*)this << " 소멸자 - " << age << "살, 이름 : " << name << endl;
	}
};


void show(Dog);
void show(Dog d) {
	cout << d.getName() << ", "  << d.getAge() << "살" << endl;
}

// Dog를 인자로 받아 이름과 나이를 출력하는 함수 show()를 선언하고 정의해 보자.
int main()
{
	Dog a(1, "성공");
	cout << "show start" << endl;
	show(a);
	cout << "show end" << endl;
	save();
}





-----------------------------------
Thu Oct 11 09:58:31 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (7주 2일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.
/*
class Dog {
	int age;
	string name;
public:
	//다음시간에 정식 표기법
	int getAge() const {		//const를 사용해서 읽기는 가능하지만 쓰기 불가
		return age;
	}

	string getName() const {
		return name;
	}

	Dog() : age(0), name("무명") {
		cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		cout << (void*)this << " 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	~Dog() {
		cout << (void*)this << " 소멸자 - " << age << "살, 이름 : " << name << endl;
	}
};*/


//정식 표기
class Dog {
	int age;
	string name;
public:
	//다음시간에 정식 표기법
	int getAge() const;

	string getName() const;

	Dog(); 
	Dog(int n, string s);
	~Dog(); 
};
Dog::Dog() : age(0), name("무명") {
	cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
}
Dog::Dog(int n,string s) : age(n), name(s) {
	cout << (void*)this << " 생성자 - " << age << "살, 이름 : " << name << endl;
}
Dog::~Dog() {
	cout << (void*)this << " 소멸자 - " << age << "살, 이름 : " << name << endl;
}
int Dog::getAge()const {
	return age;
}
string Dog::getName()const {
	return name;
}

void show(Dog);
void show(Dog d) {
	cout << d.getName() << ", "  << d.getAge() << "살" << endl;
}

// Dog를 인자로 받아 이름과 나이를 출력하는 함수 show()를 선언하고 정의해 보자.
int main()
{
	Dog a(1, "성공");
	cout << "show start" << endl;
	show(a);
	cout << "show end" << endl;
	save();
}





-----------------------------------
Thu Oct 11 09:59:36 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (7주 2일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.

class Dog {
	int age;
	string name;
public:
	//다음시간에 정식 표기법
	//int Dog::getAge() const { }
	int getAge() const {		//const를 사용해서 읽기는 가능하지만 쓰기 불가
		return age;
	}

	string getName() const {
		return name;
	}

	Dog() : age(0), name("무명") {
		cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		cout << (void*)this << " 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	~Dog() {
		cout << (void*)this << " 소멸자 - " << age << "살, 이름 : " << name << endl;
	}
};


void show(Dog);
void show(Dog d) {
	cout << d.getName() << ", "  << d.getAge() << "살" << endl;
}

// Dog를 인자로 받아 이름과 나이를 출력하는 함수 show()를 선언하고 정의해 보자.
int main()
{
	Dog a(1, "성공");
	cout << "show start" << endl;
	show(a);
	cout << "show end" << endl;
	save();
}





-----------------------------------
Thu Oct 11 10:29:01 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (7주 2일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.

class Dog {
	int age;
	string name;
public:
	//다음시간에 정식 표기법
	//int Dog::getAge() const { }
	int getAge() const {		//const를 사용해서 읽기는 가능하지만 쓰기 불가
		return age;
	}

	string getName() const {
		return name;
	}

	Dog() : age(0), name("무명") {
		cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		cout << (void*)this << " 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	~Dog() {
		cout << (void*)this << " 소멸자 - " << age << "살, 이름 : " << name << endl;
	}
};


void show(Dog&);
void show(Dog &d) {
	cout << d.getName() << ", "  << d.getAge() << "살" << endl;
}

// Dog를 인자로 받아 이름과 나이를 출력하는 함수 show()를 선언하고 정의해 보자.
int main()
{
	Dog a ;

	show(a);

	save();
}





-----------------------------------
Thu Oct 11 11:07:20 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (7주 2일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.

class Dog {
	int age;
	string name;
public:
	//다음시간에 정식 표기법
	//int Dog::getAge() const { }
	int getAge() const {		//const를 사용해서 읽기는 가능하지만 쓰기 불가
		return age;
	}

	string getName() const {
		return name;
	}
	int setAge(int n) {
		age = n;
		return age;
	}

	Dog() : age(0), name("무명") {
		//cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		cout << (void*)this << " 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	~Dog() {
	//	cout << (void*)this << " 소멸자 - " << age << "살, 이름 : " << name << endl;
	}
};


void show(Dog&);
void show(Dog& d) {
	cout << d.getName() << ", "  << d.getAge() << "살" << endl;
}

// Dog를 인자로 받아 이름과 나이를 출력하는 함수 show()를 선언하고 정의해 보자.
int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid(0,10);
	//[문제] 개 10000마리를 만들어라
	//나이를 uid(dre)를 사용하여 값을 할당하라

	Dog a[10000];
	for (int i=0; i < 10000; ++i){
		a[i].setAge(uid(dre));
	}
	//qsort를 사용하여 나이 오름차순으로 정렬하라
	qsort(a, 10000, sizeof(Dog), [](const void* a, const void* b) {
		return ((Dog*)a)->getAge() - ((Dog*)b)->getAge();
	});
	//show()를 사용하여 결과를 출력하라.
	int cnt;
	for (int i = 0; i < 10000; ++i) {
		//show(a[i]);
		if (a[i].getAge() == 10) {
			++cnt;
		}
	}

	save();
}





-----------------------------------
Thu Oct 11 11:07:31 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (7주 2일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.

class Dog {
	int age;
	string name;
public:
	//다음시간에 정식 표기법
	//int Dog::getAge() const { }
	int getAge() const {		//const를 사용해서 읽기는 가능하지만 쓰기 불가
		return age;
	}

	string getName() const {
		return name;
	}
	int setAge(int n) {
		age = n;
		return age;
	}

	Dog() : age(0), name("무명") {
		//cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		cout << (void*)this << " 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	~Dog() {
	//	cout << (void*)this << " 소멸자 - " << age << "살, 이름 : " << name << endl;
	}
};


void show(Dog&);
void show(Dog& d) {
	cout << d.getName() << ", "  << d.getAge() << "살" << endl;
}

// Dog를 인자로 받아 이름과 나이를 출력하는 함수 show()를 선언하고 정의해 보자.
int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid(0,10);
	//[문제] 개 10000마리를 만들어라
	//나이를 uid(dre)를 사용하여 값을 할당하라

	Dog a[10000];
	for (int i=0; i < 10000; ++i){
		a[i].setAge(uid(dre));
	}
	//qsort를 사용하여 나이 오름차순으로 정렬하라
	qsort(a, 10000, sizeof(Dog), [](const void* a, const void* b) {
		return ((Dog*)a)->getAge() - ((Dog*)b)->getAge();
	});
	//show()를 사용하여 결과를 출력하라.
	int cnt=0;
	for (int i = 0; i < 10000; ++i) {
		//show(a[i]);
		if (a[i].getAge() == 10) {
			++cnt;
		}
	}

	save();
}





-----------------------------------
Thu Oct 11 11:07:47 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (7주 2일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.

class Dog {
	int age;
	string name;
public:
	//다음시간에 정식 표기법
	//int Dog::getAge() const { }
	int getAge() const {		//const를 사용해서 읽기는 가능하지만 쓰기 불가
		return age;
	}

	string getName() const {
		return name;
	}
	int setAge(int n) {
		age = n;
		return age;
	}

	Dog() : age(0), name("무명") {
		//cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		cout << (void*)this << " 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	~Dog() {
	//	cout << (void*)this << " 소멸자 - " << age << "살, 이름 : " << name << endl;
	}
};


void show(Dog&);
void show(Dog& d) {
	cout << d.getName() << ", "  << d.getAge() << "살" << endl;
}

// Dog를 인자로 받아 이름과 나이를 출력하는 함수 show()를 선언하고 정의해 보자.
int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid(0,10);
	//[문제] 개 10000마리를 만들어라
	//나이를 uid(dre)를 사용하여 값을 할당하라

	Dog a[10000];
	for (int i=0; i < 10000; ++i){
		a[i].setAge(uid(dre));
	}
	//qsort를 사용하여 나이 오름차순으로 정렬하라
	qsort(a, 10000, sizeof(Dog), [](const void* a, const void* b) {
		return ((Dog*)a)->getAge() - ((Dog*)b)->getAge();
	});
	//show()를 사용하여 결과를 출력하라.
	int cnt=0;
	for (int i = 0; i < 10000; ++i) {
		//show(a[i]);
		if (a[i].getAge() == 10) {
			++cnt;
		}
	}
	cout << cnt << endl;

	save();
}





-----------------------------------
Thu Oct 11 11:08:07 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (7주 2일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.

class Dog {
	int age;
	string name;
public:
	//다음시간에 정식 표기법
	//int Dog::getAge() const { }
	int getAge() const {		//const를 사용해서 읽기는 가능하지만 쓰기 불가
		return age;
	}

	string getName() const {
		return name;
	}
	int setAge(int n) {
		age = n;
		return age;
	}

	Dog() : age(0), name("무명") {
		//cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		cout << (void*)this << " 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	~Dog() {
	//	cout << (void*)this << " 소멸자 - " << age << "살, 이름 : " << name << endl;
	}
};


void show(Dog&);
void show(Dog& d) {
	cout << d.getName() << ", "  << d.getAge() << "살" << endl;
}

// Dog를 인자로 받아 이름과 나이를 출력하는 함수 show()를 선언하고 정의해 보자.
int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid(0,100);
	//[문제] 개 10000마리를 만들어라
	//나이를 uid(dre)를 사용하여 값을 할당하라

	Dog a[10000];
	for (int i=0; i < 10000; ++i){
		a[i].setAge(uid(dre));
	}
	//qsort를 사용하여 나이 오름차순으로 정렬하라
	qsort(a, 10000, sizeof(Dog), [](const void* a, const void* b) {
		return ((Dog*)a)->getAge() - ((Dog*)b)->getAge();
	});
	//show()를 사용하여 결과를 출력하라.
	int cnt=0;
	for (int i = 0; i < 10000; ++i) {
		//show(a[i]);
		if (a[i].getAge() == 10) {
			++cnt;
		}
	}
	cout << cnt << endl;

	save();
}





-----------------------------------
Thu Oct 11 11:10:27 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (7주 2일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.

class Dog {
	int age;
	string name;
public:
	//다음시간에 정식 표기법
	//int Dog::getAge() const { }
	int getAge() const {		//const를 사용해서 읽기는 가능하지만 쓰기 불가
		return age;
	}

	string getName() const {
		return name;
	}
	int setAge(int n) {
		age = n;
		return age;
	}

	Dog() : age(0), name("무명") {
		//cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		cout << (void*)this << " 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	~Dog() {
	//	cout << (void*)this << " 소멸자 - " << age << "살, 이름 : " << name << endl;
	}
};


void show(Dog&);
void show(Dog& d) {
	cout << d.getName() << ", "  << d.getAge() << "살" << endl;
}

// Dog를 인자로 받아 이름과 나이를 출력하는 함수 show()를 선언하고 정의해 보자.
int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid(0,100);
	//[문제] 개 10000마리를 만들어라
	//나이를 uid(dre)를 사용하여 값을 할당하라

	Dog a[10000];
	for (int i=0; i < 10000; ++i){
		a[i].setAge(uid(dre));
	}
	//qsort를 사용하여 나이 오름차순으로 정렬하라
	qsort(a, 10000, sizeof(Dog), [](const void* a, const void* b) {
		return ((Dog*)a)->getAge() - ((Dog*)b)->getAge();
	});
	//show()를 사용하여 결과를 출력하라.
	int n10,n11;
	for (int i = 0; i < 10000; ++i) {
		if (a[i].getAge() == 10) {
			n10 = i;
		}
	}
	for (int i = 0; i < 10000; ++i) {
		if (a[i].getAge() == 11) {
			n11 = i;
		}
	}
	cout << n11 - n10 << endl;

	save();
}





-----------------------------------
Thu Oct 11 11:12:05 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (7주 2일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.

class Dog {
	int age;
	string name;
public:
	//다음시간에 정식 표기법
	//int Dog::getAge() const { }
	int getAge() const {		//const를 사용해서 읽기는 가능하지만 쓰기 불가
		return age;
	}

	string getName() const {
		return name;
	}
	int setAge(int n) {
		age = n;
		return age;
	}

	Dog() : age(0), name("무명") {
		//cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		cout << (void*)this << " 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	~Dog() {
	//	cout << (void*)this << " 소멸자 - " << age << "살, 이름 : " << name << endl;
	}
};


void show(Dog&);
void show(Dog& d) {
	cout << d.getName() << ", "  << d.getAge() << "살" << endl;
}

// Dog를 인자로 받아 이름과 나이를 출력하는 함수 show()를 선언하고 정의해 보자.
int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid(0,100);
	//[문제] 개 10000마리를 만들어라
	//나이를 uid(dre)를 사용하여 값을 할당하라

	Dog a[10000];
	for (int i=0; i < 10000; ++i){
		a[i].setAge(uid(dre));
	}
	//qsort를 사용하여 나이 오름차순으로 정렬하라
	qsort(a, 10000, sizeof(Dog), [](const void* a, const void* b) {
		return ((Dog*)a)->getAge() - ((Dog*)b)->getAge();
	});
	//show()를 사용하여 결과를 출력하라.
	int n10,n11;
	for (int i = 0; i < 10000; ++i) {
		if (a[i].getAge() == 10) {
			n10 = i;
			break;
		}
	}
	for (int i = 0; i < 10000; ++i) {
		if (a[i].getAge() == 11) {
			n11 = i;
			break;
		}
	}
	cout << n11 - n10 << endl;

	save();
}





-----------------------------------
Mon Oct 15 13:35:18 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.

class Dog {
	int age;
	string name;
public:
	//다음시간에 정식 표기법
	//int Dog::getAge() const { }
	int getAge() const {		//const를 사용해서 읽기는 가능하지만 쓰기 불가
		return age;
	}

	string getName() const {
		return name;
	}
	int setAge(int n) {
		age = n;
		return age;
	}

	Dog() : age(0), name("무명") {
		//cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		cout << (void*)this << " 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	~Dog() {
	//	cout << (void*)this << " 소멸자 - " << age << "살, 이름 : " << name << endl;
	}
};


void show(Dog&);
void show(Dog& d) {
	cout << d.getName() << ", "  << d.getAge() << "살" << endl;
}

// Dog를 인자로 받아 이름과 나이를 출력하는 함수 show()를 선언하고 정의해 보자.
int main()
{
	default_random_engine dre;
	uniform_int_distribution<> uid(0,100);
	//[문제] 개 10000마리를 만들어라
	//나이를 uid(dre)를 사용하여 값을 할당하라

	Dog a[10000];
	for (int i=0; i < 10000; ++i){
		a[i].setAge(uid(dre));
	}
	//qsort를 사용하여 나이 오름차순으로 정렬하라
	qsort(a, 10000, sizeof(Dog), [](const void* a, const void* b) {
		return ((Dog*)a)->getAge() - ((Dog*)b)->getAge();
	});
	//show()를 사용하여 결과를 출력하라.
	int n10,n11;
	for (int i = 0; i < 10000; ++i) {
		if (a[i].getAge() == 10) {
			n10 = i;
			break;
		}
	}
	for (int i = 0; i < 10000; ++i) {
		if (a[i].getAge() == 11) {
			n11 = i;
			break;
		}
	}
	cout << n11 - n10 << endl;

	save();
}





-----------------------------------
Mon Oct 15 13:38:51 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.

class Dog {
	int age;
	string name;
public:
	//다음시간에 정식 표기법
	//int Dog::getAge() const { }
	int getAge() const {		//const를 사용해서 읽기는 가능하지만 쓰기 불가
		return age;
	}

	string getName() const {
		return name;
	}
	int setAge(int n) {
		age = n;
		return age;
	}

	Dog() : age(0), name("무명") {
		//cout << (void*)this << "default 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	Dog(int n, string s) : age(n), name(s) {
		cout << (void*)this << " 생성자 - " << age << "살, 이름 : " << name << endl;
	}
	~Dog() {
	//	cout << (void*)this << " 소멸자 - " << age << "살, 이름 : " << name << endl;
	}
};


void show(Dog&);
void show(Dog& d) {
	cout << d.getName() << ", "  << d.getAge() << "살" << endl;
}

// Dog를 인자로 받아 이름과 나이를 출력하는 함수 show()를 선언하고 정의해 보자.
int main()
{
	int a = 10;	// a를 생성하고 10으로 초기화
	int b = a;	// a를 복사하여 b를 생성


	save();
}





-----------------------------------
Mon Oct 15 13:48:29 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.

class Dog {
	int n;
public:
	Dog() : n(0) {
		cout << "생성 - " << n << endl;
	}
	Dog(int a) : n(a) {
		cout << "생성 - " << n << endl;
	}
	~Dog(){
		cout << "소멸 - " << n << endl;
	}
	int GetN() {
		return n;
	}
};

void show(Dog&);

void show(Dog& a) {
	cout << a.GetN() << endl;
}
// [문제] 객체의 생성/소멸을 관찰하는 클래스를 만들어라
// 다음 main()이 문제없이 실행되도록 하자
// class Dog는 멤버변수로 int n; 만을 갖는다.

int main()
{
	Dog a;			// n = 0 이 되도록 초기화 하라
	Dog b(10);		// n = 10으로 초기화
	
	show(a);		// a의 멤버변수값을 출력한다.
	show(b);		// b의 멤버변수값을 출력한다.
	
	save();

}





-----------------------------------
Mon Oct 15 13:48:58 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.

class Dog {
	int n;
public:
	Dog() : n(0) {
		cout << "생성 - " << n << endl;
	}
	Dog(int a) : n(a) {
		cout << "생성 - " << n << endl;
	}
	~Dog(){
		cout << "소멸 - " << n << endl;
	}
	int GetN() {
		return n;
	}
};

void show(Dog&);

void show(Dog& a) {
	cout << a.GetN() << endl;
}
// [문제] 객체의 생성/소멸을 관찰하는 클래스를 만들어라
// 다음 main()이 문제없이 실행되도록 하자
// class Dog는 멤버변수로 int n; 만을 갖는다.

int main()
{
	Dog a;			// n = 0 이 되도록 초기화 하라
	Dog b(10);		// n = 10으로 초기화
	
	show(a);		// a의 멤버변수값을 출력한다.
	show(b);		// b의 멤버변수값을 출력한다.
	
	save();

}





-----------------------------------
Mon Oct 15 13:52:12 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.

class Dog {
	int n;
public:
	Dog() : n(0) {
		cout << "생성 - " << n << endl;
	}
	Dog(int n) : n(n) {
		cout << "생성 - " << n << endl;
	}
	~Dog(){
		cout << "소멸 - " << n << endl;
	}
	int GetN() {
		return n;
	}
};

void show(Dog&);

void show(Dog& a) {
	cout << a.GetN() << endl;
}
// [문제] 객체의 생성/소멸을 관찰하는 클래스를 만들어라
// 다음 main()이 문제없이 실행되도록 하자
// class Dog는 멤버변수로 int n; 만을 갖는다.

int main()
{
	Dog a;			// n = 0 이 되도록 초기화 하라
	Dog b(10);		// n = 10으로 초기화
	
	show(a);		// a의 멤버변수값을 출력한다.
	show(b);		// b의 멤버변수값을 출력한다.
	
	save();

}





-----------------------------------
Mon Oct 15 13:53:33 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.

class Dog {
	int n;
public:
	Dog() : n(0) {
		cout << "default 생성 - " << n << endl;
	}
	Dog(int n) : n(n) {
		cout << "생성 - " << n << endl;
	}
	~Dog(){
		cout << "소멸 - " << n << endl;
	}
	int GetN() {
		return n;
	}
};

void show(Dog&);

void show(Dog& a) {
	cout << a.GetN() << endl;
}
// [문제] 객체의 생성/소멸을 관찰하는 클래스를 만들어라
// 다음 main()이 문제없이 실행되도록 하자
// class Dog는 멤버변수로 int n; 만을 갖는다.

int main()
{
	Dog a;			// n = 0 이 되도록 초기화 하라
	Dog b(10);		// n = 10으로 초기화
	
	show(a);		// a의 멤버변수값을 출력한다.
	show(b);		// b의 멤버변수값을 출력한다.
	
	save();

}





-----------------------------------
Mon Oct 15 13:55:33 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.

class Dog {
	int n;
public:
	Dog() : n(0) {
		cout << "default 생성 - " << n << endl;
	}
	Dog(int n) : n(n) {
		cout << "생성 - " << n << endl;
	}
	~Dog(){
		cout << "소멸 - " << n << endl;
	}
	int GetN() const {
		return n;
	}
};

void show(Dog&);

void show(Dog& a) {
	cout << a.GetN() << endl;
}
// [문제] 객체의 생성/소멸을 관찰하는 클래스를 만들어라
// 다음 main()이 문제없이 실행되도록 하자
// class Dog는 멤버변수로 int n; 만을 갖는다.

int main()
{
	Dog a;			// n = 0 이 되도록 초기화 하라
	Dog b(10);		// n = 10으로 초기화
	
	show(a);		// a의 멤버변수값을 출력한다.
	show(b);		// b의 멤버변수값을 출력한다.
	
	save();

}





-----------------------------------
Mon Oct 15 14:04:13 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.

class Dog {
	int n;
public:
	Dog() : n(0) {
		cout << "default 생성 - " << n << endl;
	}
	Dog(int n) : n(n) {
		cout << "생성 - " << n << endl;
	}

	Dog(const Dog& other) {
		cout << "복사 생성 " << other.n << endl;
	}

	~Dog(){
		cout << "소멸 - " << n << endl;
	}
	int GetN() const {
		return n;
	}
};
// 함수에 전달되는 Dog는 복사생성되는 객체이다.
// 우리는 복사생성되는 객체에 특별한 동작을 할 수 있다.
// (메모리에 복사생성된 후 - 복사생성자 라는 함수를 통해서)
void show(Dog&);

void show(Dog& a) {
	cout << a.GetN() << endl;
}
// [문제] 객체의 생성/소멸을 관찰하는 클래스를 만들어라
// 다음 main()이 문제없이 실행되도록 하자
// class Dog는 멤버변수로 int n; 만을 갖는다.

int main()
{
	Dog a;			// n = 0 이 되도록 초기화 하라
	Dog b(10);		// n = 10으로 초기화
	
	show(a);		// a의 멤버변수값을 출력한다.
	show(b);		// b의 멤버변수값을 출력한다.
	
	save();

}





-----------------------------------
Mon Oct 15 14:04:24 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.

class Dog {
	int n;
public:
	Dog() : n(0) {
		cout << "default 생성 - " << n << endl;
	}
	Dog(int n) : n(n) {
		cout << "생성 - " << n << endl;
	}

	Dog(const Dog& other) {
		cout << "복사 생성 " << other.n << endl;
	}

	~Dog(){
		cout << "소멸 - " << n << endl;
	}
	int GetN() const {
		return n;
	}
};
// 함수에 전달되는 Dog는 복사생성되는 객체이다.
// 우리는 복사생성되는 객체에 특별한 동작을 할 수 있다.
// (메모리에 복사생성된 후 - 복사생성자 라는 함수를 통해서)
void show(Dog);

void show(Dog a) {
	cout << a.GetN() << endl;
}
// [문제] 객체의 생성/소멸을 관찰하는 클래스를 만들어라
// 다음 main()이 문제없이 실행되도록 하자
// class Dog는 멤버변수로 int n; 만을 갖는다.

int main()
{
	Dog a;			// n = 0 이 되도록 초기화 하라
	Dog b(10);		// n = 10으로 초기화
	
	show(a);		// a의 멤버변수값을 출력한다.
	show(b);		// b의 멤버변수값을 출력한다.
	
	save();

}





-----------------------------------
Mon Oct 15 14:06:00 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.

class Dog {
	int n;
public:
	Dog() : n(0) {
		cout << "default 생성 - " << n << endl;
	}
	Dog(int n) : n(n) {
		cout << "생성 - " << n << endl;
	}

	//Dog(const Dog& other) {
		//cout << "복사 생성 " << other.n << endl;
	//}

	~Dog(){
		cout << "소멸 - " << n << endl;
	}
	int GetN() const {
		return n;
	}
};
// 함수에 전달되는 Dog는 복사생성되는 객체이다.
// 우리는 복사생성되는 객체에 특별한 동작을 할 수 있다.
// (메모리에 복사생성된 후 - 복사생성자 라는 함수를 통해서)
void show(Dog);

void show(Dog a) {
	cout << a.GetN() << endl;
}
// [문제] 객체의 생성/소멸을 관찰하는 클래스를 만들어라
// 다음 main()이 문제없이 실행되도록 하자
// class Dog는 멤버변수로 int n; 만을 갖는다.

int main()
{
	Dog a;			// n = 0 이 되도록 초기화 하라
	Dog b(10);		// n = 10으로 초기화
	
	show(a);		// a의 멤버변수값을 출력한다.
	show(b);		// b의 멤버변수값을 출력한다.
	
	save();

}





-----------------------------------
Mon Oct 15 14:06:20 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

//이름(string)과 나이(int)를 갖는 Dog를 만들자.
//생성과 소멸시 관찰 메시지를 출력하도록 하자.

class Dog {
	int n;
public:
	Dog() : n(0) {
		cout << "default 생성 - " << n << endl;
	}
	Dog(int n) : n(n) {
		cout << "생성 - " << n << endl;
	}

	Dog(const Dog& other) {
		cout << "복사 생성 " << n << endl;
	}

	~Dog(){
		cout << "소멸 - " << n << endl;
	}
	int GetN() const {
		return n;
	}
};
// 함수에 전달되는 Dog는 복사생성되는 객체이다.
// 우리는 복사생성되는 객체에 특별한 동작을 할 수 있다.
// (메모리에 복사생성된 후 - 복사생성자 라는 함수를 통해서)
void show(Dog);

void show(Dog a) {
	cout << a.GetN() << endl;
}
// [문제] 객체의 생성/소멸을 관찰하는 클래스를 만들어라
// 다음 main()이 문제없이 실행되도록 하자
// class Dog는 멤버변수로 int n; 만을 갖는다.

int main()
{
	Dog a;			// n = 0 이 되도록 초기화 하라
	Dog b(10);		// n = 10으로 초기화
	
	show(a);		// a의 멤버변수값을 출력한다.
	show(b);		// b의 멤버변수값을 출력한다.
	
	save();

}





-----------------------------------
Mon Oct 15 15:01:35 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;


// [문제] 객체의 생성/소멸을 관찰하는 클래스를 만들어라
// 다음 main()이 문제없이 실행되도록 하자
class Test {
	int n;
	int* p = new int[n];
public:
	Test(int a) : n(a) {
		for (int i = 0; i < n; ++i) {
			p[i] = n;
		}
		cout << "생성 완료" << endl;
	}
	void show() {
		for (int i = 0; i < n; ++i) {
			cout << i + 1 << "번째" << p[i] << endl;
		}
	}
	~Test() {
		delete[] p;
	}
	Test(const Test& a) : n(a.n) {
		for (int i = 0; i < a.n; ++i) {
			p[i] = a.n;
			cout << "생성완료" << endl;
		}
	}
};
	// Test는 인자로 전달된 n만큼의 정수를 HEAP에 생성한다.
	// 정수 메모리의 값은 모두 n으로 할당한다.
	// 예) n=100 이라면 100개의 정수를 HEAP에 생성(new int[100})
	int main()
	{
		Test a(200);		//200개의 int를 HEAP에 생성 값은 200;
		a.show();			//200개의 값 200을 화면 출력
		Test b(a);
		b.show();

		save();
	}





-----------------------------------
Mon Oct 15 15:02:03 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;


// [문제] 객체의 생성/소멸을 관찰하는 클래스를 만들어라
// 다음 main()이 문제없이 실행되도록 하자
class Test {
	int n;
	int* p = new int[n];
public:
	Test(int a) : n(a) {
		for (int i = 0; i < n; ++i) {
			p[i] = n;
		}
		cout << "생성 완료" << endl;
	}
	void show() {
		for (int i = 0; i < n; ++i) {
			cout << i + 1 << "번째" << p[i] << endl;
		}
	}
	~Test() {
		delete[] p;
	}
	Test(const Test& a) : n(a.n) {
		for (int i = 0; i < a.n; ++i) {
			p[i] = a.n;
			}
		cout << "생성완료" << endl;
	}
};
	// Test는 인자로 전달된 n만큼의 정수를 HEAP에 생성한다.
	// 정수 메모리의 값은 모두 n으로 할당한다.
	// 예) n=100 이라면 100개의 정수를 HEAP에 생성(new int[100})
	int main()
	{
		Test a(200);		//200개의 int를 HEAP에 생성 값은 200;
		a.show();			//200개의 값 200을 화면 출력
		Test b(a);
		b.show();

		save();
	}





-----------------------------------
Mon Oct 15 15:02:48 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;


// [문제] 객체의 생성/소멸을 관찰하는 클래스를 만들어라
// 다음 main()이 문제없이 실행되도록 하자
class Test {
	int n;
	int* p = new int[n];
public:
	Test(int a) : n(a) {
		for (int i = 0; i < n; ++i) {
			p[i] = n;
		}
		cout << "생성 완료" << endl;
	}
	void show() {
		for (int i = 0; i < n; ++i) {
			cout << i + 1 << "번째" << p[i] << endl;
		}
	}
	~Test() {
		delete[] p;
	}
	Test(const Test& a) : n(a.n) {
		for (int i = 0; i < a.n; ++i) {
			p[i] = a.n;
			}
		cout << "생성완료" << endl;
	}
};
	// Test는 인자로 전달된 n만큼의 정수를 HEAP에 생성한다.
	// 정수 메모리의 값은 모두 n으로 할당한다.
	// 예) n=100 이라면 100개의 정수를 HEAP에 생성(new int[100})
	int main()
	{
		Test a(100);		//200개의 int를 HEAP에 생성 값은 200;
		a.show();			//200개의 값 200을 화면 출력
		Test b(a);
		b.show();

		save();
	}





-----------------------------------
Mon Oct 15 15:02:57 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;


// [문제] 객체의 생성/소멸을 관찰하는 클래스를 만들어라
// 다음 main()이 문제없이 실행되도록 하자
class Test {
	int n;
	int* p = new int[n];
public:
	Test(int a) : n(a) {
		for (int i = 0; i < n; ++i) {
			p[i] = n;
		}
		cout << "생성 완료" << endl;
	}
	void show() {
		for (int i = 0; i < n; ++i) {
			cout << i + 1 << "번째" << p[i] << endl;
		}
	}
	~Test() {
		delete[] p;
	}
	Test(const Test& a) : n(a.n) {
		for (int i = 0; i < a.n; ++i) {
			p[i] = a.n;
			}
		cout << "생성완료" << endl;
	}
};
	// Test는 인자로 전달된 n만큼의 정수를 HEAP에 생성한다.
	// 정수 메모리의 값은 모두 n으로 할당한다.
	// 예) n=100 이라면 100개의 정수를 HEAP에 생성(new int[100})
	int main()
	{
		Test a(200);		//200개의 int를 HEAP에 생성 값은 200;
		a.show();			//200개의 값 200을 화면 출력
		Test b(a);
		b.show();

		save();
	}





-----------------------------------
Mon Oct 15 15:16:14 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;


// [문제] 객체의 생성/소멸을 관찰하는 클래스를 만들어라
// 다음 main()이 문제없이 실행되도록 하자
class Test {
	int n;
	int* p;
public:
	Test(int a) : n(a) {
		p = new int[n];
		for (int i = 0; i < n; ++i) {
			p[i] = n;
		}
		cout << "생성 완료" << endl;
	}
	void show() {
		for (int i = 0; i < n; ++i) {
			cout << i + 1 << "번째" << p[i] << endl;
		}
		cout << "출력완료" << endl;
	}
	~Test() {
		delete[] p;
		cout << "삭제 완료" << endl;
	}
	Test(const Test& a) : n(a.n) {
		p = new int[a.n];
		for (int i = 0; i < a.n; ++i) {
			p[i] = a.n;
			}
		cout << "생성완료" << endl;
	}
};
	// Test는 인자로 전달된 n만큼의 정수를 HEAP에 생성한다.
	// 정수 메모리의 값은 모두 n으로 할당한다.
	// 예) n=100 이라면 100개의 정수를 HEAP에 생성(new int[100})
	int main()
	{
		Test a(200);		//200개의 int를 HEAP에 생성 값은 200;
		a.show();			//200개의 값 200을 화면 출력
		Test b(a);
		b.show();

		cout << "ㅇㅋ?" << endl;
		save();
	}





-----------------------------------
Mon Oct 15 15:25:41 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;


// [문제] 객체의 생성/소멸을 관찰하는 클래스를 만들어라
// 다음 main()이 문제없이 실행되도록 하자
class Test {
	int n;
	int* p;
public:
	Test(int a) : n(a) {
		p = new int[n];
		for (int i = 0; i < n; ++i) {
			p[i] = n;
		}
		cout << "생성 완료" << endl;
	}
	void show() {
		for (int i = 0; i < n; ++i) {
			cout << i + 1 << "번째" << p[i] << endl;
		}
		cout << "출력완료" << endl;
	}
	~Test() {
		delete[] p;
		cout << "삭제 완료" << endl;
	}
	Test(const Test& a) : n(a.n) {
		p = new int[a.n];
		for (int i = 0; i < a.n; ++i) {
			p[i] = a.n;
			}
		cout << "생성완료" << endl;
	}
};
	// Test는 인자로 전달된 n만큼의 정수를 HEAP에 생성한다.
	// 정수 메모리의 값은 모두 n으로 할당한다.
	// 예) n=100 이라면 100개의 정수를 HEAP에 생성(new int[100})
	int main()
	{
		Test a(200);		//200개의 int를 HEAP에 생성 값은 200;
		a.show();			//200개의 값 200을 화면 출력
		Test b(a);
		b.show();

		cout << "ㅇㅋ?" << endl;
		save();
	}





-----------------------------------
Thu Oct 18 09:32:15 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 2일)


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;


// [문제] 객체의 생성/소멸을 관찰하는 클래스를 만들어라
// 다음 main()이 문제없이 실행되도록 하자
class Test {
	int n;
	int* p;
public:
	Test(int a) : n(a) {
		p = new int[n];
		for (int i = 0; i < n; ++i) {
			p[i] = i+1;
		}
		cout << "생성 완료" << endl;
	}
	void show() {
		for (int i = 0; i < n; ++i) {
			cout << i + 1 << "번째" << p[i] << endl;
		}
		cout << "출력완료" << endl;
	}
	~Test() {
		delete[] p;
		cout << "삭제 완료" << endl;
	}
	Test(const Test& a) : n(a.n) {
		p = new int[a.n];
		for (int i = 0; i < a.n; ++i) {
			p[i] = i+1;
			}
		cout << "생성완료" << endl;
	}
};
	// Test는 인자로 전달된 n만큼의 정수를 HEAP에 생성한다.
	// 정수 메모리의 값을 모두 1~n까지의 값으로 할당한다. (1,2,3,4,5 .... n)
	// 예) n=100 이라면 100개의 정수를 HEAP에 생성(new int[100})
	int main()
	{
		Test a(200);		//200개의 int를 HEAP에 생성 값은 200;
		a.show();			//200개의 값 200을 화면 출력
		Test b(a);
		b.show();

		cout << "ㅇㅋ?" << endl;
		save();
	}





-----------------------------------
Thu Oct 18 09:50:04 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid;

class X {
	int n;
	int* p;
public:
	X(int a) : n(a) {
		p = new int[n];
		cout << "메모리 할당 완료" << endl;

		for (int i = 0; i < n; ++i) {
			p[i] = uid(dre);
		}
		cout << "값 할당 완료" << endl;

		cout << "생성 완료" << endl;
	}
	X(const X& b) : n(b.n) {
		p = new int[b.n];
		cout << "메모리 할당 완료" << endl;
		for (int i = 0; i < b.n; ++i) {
			p[i] = uid(dre);
		}
		cout << "값 할당 완료" << endl;

		cout << "생성 완료" << endl;
		
	}
	void show() {
		for (int i = 0; i < n; ++i) {
			cout << i + 1 << "번째 - " << p[i] << endl;
		}
	}
};
	// HEAP에서 자원을 할당하는 클래스
	// class X는 생성자의 인자로 정수를 받아 그 만큼 정수메모리를 할당한다.
	// 정수메모리는 임의의 값으로 채워보자.
	// main()이 실행되도록 X를 프로그램 해보자
	// 생성/소멸 관찰
	int main()
	{
		X a(20);	//20개의 int를 할당한다.
					//20개의 정수값은 uid(dre)로 채워라
		a.show();	//20개의 정수의 값을 출력한다.
		X b = a;	//b를 a와 같게 생성한다.(복사생성)
		b.show();	//b를 출력 a와 동일해야한다.
		save();
	}





-----------------------------------
Thu Oct 18 09:51:32 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid;

class X {
	int n;
	int* p;
public:
	X(int a) : n(a) {
		p = new int[n];
		cout << "메모리 할당 완료" << endl;

		for (int i = 0; i < n; ++i) {
			p[i] = uid(dre);
		}
		cout << "값 할당 완료" << endl;

		cout << "생성 완료" << endl;
	}
	X(const X& b) : n(b.n) {
		p = new int[b.n];
		cout << "메모리 할당 완료" << endl;
		for (int i = 0; i < b.n; ++i) {
			p[i] = b.p[i];
		}
		cout << "값 할당 완료" << endl;

		cout << "생성 완료" << endl;
		
	}
	void show() {
		for (int i = 0; i < n; ++i) {
			cout << i + 1 << "번째 - " << p[i] << endl;
		}
	}
	~X() {
		delete[] p;
		cout << "소멸" << endl;
	}
};
	// HEAP에서 자원을 할당하는 클래스
	// class X는 생성자의 인자로 정수를 받아 그 만큼 정수메모리를 할당한다.
	// 정수메모리는 임의의 값으로 채워보자.
	// main()이 실행되도록 X를 프로그램 해보자
	// 생성/소멸 관찰
	int main()
	{
		X a(20);	//20개의 int를 할당한다.
					//20개의 정수값은 uid(dre)로 채워라
		a.show();	//20개의 정수의 값을 출력한다.
		X b = a;	//b를 a와 같게 생성한다.(복사생성)
		b.show();	//b를 출력 a와 동일해야한다.
		save();
	}





-----------------------------------
Thu Oct 18 09:51:47 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid;

class X {
	int n;
	int* p;
public:
	X(int a) : n(a) {
		p = new int[n];
		cout << "메모리 할당 완료" << endl;

		for (int i = 0; i < n; ++i) {
			p[i] = uid(dre);
		}
		cout << "값 할당 완료" << endl;

		cout << "생성 완료" << endl;
	}
	X(const X& b) : n(b.n) {
		p = new int[b.n];
		cout << "메모리 할당 완료" << endl;
		for (int i = 0; i < b.n; ++i) {
			p[i] = b.p[i];
		}
		cout << "값 할당 완료" << endl;

		cout << "생성 완료" << endl;
		
	}
	void show() {
		for (int i = 0; i < n; ++i) {
			cout << i + 1 << "번째 - " << p[i] << endl;
		}
	}
	~X() {
		delete[] p;
		cout << "소멸" << endl;
	}
};
	// HEAP에서 자원을 할당하는 클래스
	// class X는 생성자의 인자로 정수를 받아 그 만큼 정수메모리를 할당한다.
	// 정수메모리는 임의의 값으로 채워보자.
	// main()이 실행되도록 X를 프로그램 해보자
	// 생성/소멸 관찰
	int main()
	{
		X a(20);	//20개의 int를 할당한다.
					//20개의 정수값은 uid(dre)로 채워라
		a.show();	//20개의 정수의 값을 출력한다.
		X b = a;	//b를 a와 같게 생성한다.(복사생성)
		b.show();	//b를 출력 a와 동일해야한다.
		save();
	}





-----------------------------------
Thu Oct 18 10:02:06 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid;

class X {
	int n;
	int* p;
public:
	X(int a) : n(a) {
		p = new int[n];
		cout << "메모리 할당 완료" << endl;

		for (int i = 0; i < n; ++i) {
			p[i] = uid(dre);
		}
		cout << "값 할당 완료" << endl;

		cout << "생성 완료" << endl;
	}
	X(const X& b) : n(b.n) {
		p = new int[b.n];
		cout << "메모리 할당 완료" << endl;
		for (int i = 0; i < b.n; ++i) {
			p[i] = b.p[i];
		}
		cout << "값 할당 완료" << endl;

		cout << "생성 완료" << endl;
		
	}
	void show() {
		for (int i = 0; i < n; ++i) {
			cout << i + 1 << "번째 - " << p[i] << endl;
		}
	}
	~X() {
		delete[] p;
		cout << "소멸" << endl;
	}
	int getInt() {

		for(int i = 0;i<n;++i)
			return p[i];
	}
};

int isSame(X& a, X& b);
int isSame(X& a, X& b) {
	if (a.getInt() == b.getInt())
		return 1;
	else
	{
		return 0;
	}
}

	// HEAP에서 자원을 할당하는 클래스
	// class X는 생성자의 인자로 정수를 받아 그 만큼 정수메모리를 할당한다.
	// 정수메모리는 임의의 값으로 채워보자.
	// main()이 실행되도록 X를 프로그램 해보자
	// 생성/소멸 관찰
	int main()
	{
		X a(20);	//20개의 int를 할당한다.
					//20개의 정수값은 uid(dre)로 채워라
		a.show();	//20개의 정수의 값을 출력한다.
		X b = a;	//b를 a와 같게 생성한다.(복사생성)
		b.show();	//b를 출력 a와 동일해야한다.
		
		if (isSame(a, b)) {
			cout << "a와 b가 동일" << endl;
		}
		else {
			cout << "불일치" << endl;
		}
		
		save();
	}





-----------------------------------
Thu Oct 18 10:02:38 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid;

class X {
	int n;
	int* p;
public:
	X(int a) : n(a) {
		p = new int[n];
		cout << "메모리 할당 완료" << endl;

		for (int i = 0; i < n; ++i) {
			p[i] = uid(dre);
		}
		cout << "값 할당 완료" << endl;

		cout << "생성 완료" << endl;
	}
	X(const X& b) : n(b.n) {
		p = new int[b.n];
		cout << "메모리 할당 완료" << endl;
		for (int i = 0; i < b.n; ++i) {
			//p[i] = b.p[i];
			p[i] = b.n;
		}
		cout << "값 할당 완료" << endl;

		cout << "생성 완료" << endl;
		
	}
	void show() {
		for (int i = 0; i < n; ++i) {
			cout << i + 1 << "번째 - " << p[i] << endl;
		}
	}
	~X() {
		delete[] p;
		cout << "소멸" << endl;
	}
	int getInt() {

		for(int i = 0;i<n;++i)
			return p[i];
	}
};

int isSame(X& a, X& b);
int isSame(X& a, X& b) {
	if (a.getInt() == b.getInt())
		return 1;
	else
	{
		return 0;
	}
}

	// HEAP에서 자원을 할당하는 클래스
	// class X는 생성자의 인자로 정수를 받아 그 만큼 정수메모리를 할당한다.
	// 정수메모리는 임의의 값으로 채워보자.
	// main()이 실행되도록 X를 프로그램 해보자
	// 생성/소멸 관찰
	int main()
	{
		X a(20);	//20개의 int를 할당한다.
					//20개의 정수값은 uid(dre)로 채워라
		a.show();	//20개의 정수의 값을 출력한다.
		X b = a;	//b를 a와 같게 생성한다.(복사생성)
		b.show();	//b를 출력 a와 동일해야한다.
		
		if (isSame(a, b)) {
			cout << "a와 b가 동일" << endl;
		}
		else {
			cout << "불일치" << endl;
		}
		
		save();
	}





-----------------------------------
Thu Oct 18 10:02:52 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid;

class X {
	int n;
	int* p;
public:
	X(int a) : n(a) {
		p = new int[n];
		cout << "메모리 할당 완료" << endl;

		for (int i = 0; i < n; ++i) {
			p[i] = uid(dre);
		}
		cout << "값 할당 완료" << endl;

		cout << "생성 완료" << endl;
	}
	X(const X& b) : n(b.n) {
		p = new int[b.n];
		cout << "메모리 할당 완료" << endl;
		for (int i = 0; i < b.n; ++i) {
			p[i] = b.p[i];
		}
		cout << "값 할당 완료" << endl;

		cout << "생성 완료" << endl;
		
	}
	void show() {
		for (int i = 0; i < n; ++i) {
			cout << i + 1 << "번째 - " << p[i] << endl;
		}
	}
	~X() {
		delete[] p;
		cout << "소멸" << endl;
	}
	int getInt() {

		for(int i = 0;i<n;++i)
			return p[i];
	}
};

int isSame(X& a, X& b);
int isSame(X& a, X& b) {
	if (a.getInt() == b.getInt())
		return 1;
	else
	{
		return 0;
	}
}

	// HEAP에서 자원을 할당하는 클래스
	// class X는 생성자의 인자로 정수를 받아 그 만큼 정수메모리를 할당한다.
	// 정수메모리는 임의의 값으로 채워보자.
	// main()이 실행되도록 X를 프로그램 해보자
	// 생성/소멸 관찰
	int main()
	{
		X a(20);	//20개의 int를 할당한다.
					//20개의 정수값은 uid(dre)로 채워라
		a.show();	//20개의 정수의 값을 출력한다.
		X b = a;	//b를 a와 같게 생성한다.(복사생성)
		b.show();	//b를 출력 a와 동일해야한다.
		
		if (isSame(a, b)) {
			cout << "a와 b가 동일" << endl;
		}
		else {
			cout << "불일치" << endl;
		}
		
		save();
	}





-----------------------------------
Thu Oct 18 10:03:32 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid;

class X {
	int n;
	int* p;
public:
	X(int a) : n(a) {
		p = new int[n];
		cout << "메모리 할당 완료" << endl;

		for (int i = 0; i < n; ++i) {
			p[i] = uid(dre);
		}
		cout << "값 할당 완료" << endl;

		cout << "생성 완료" << endl;
	}
	X(const X& b) : n(b.n) {
		p = new int[b.n];
		cout << "메모리 할당 완료" << endl;
		for (int i = 0; i < b.n; ++i) {
			p[i] = b.p[i];
		}
		cout << "값 할당 완료" << endl;

		cout << "생성 완료" << endl;
		
	}
	void show() {
		for (int i = 0; i < n; ++i) {
			cout << i + 1 << "번째 - " << p[i] << endl;
		}
	}
	~X() {
		delete[] p;
		cout << "소멸" << endl;
	}
	int getInt() {

		for(int i = 0;i<n;++i)
			return p[i];
	}
};

int isSame(X& a, X& b);
int isSame(X& a, X& b) {
	if (a.getInt() == b.getInt()) {
		return 1;
	}
	else{
		return 0;
	}
}

	// HEAP에서 자원을 할당하는 클래스
	// class X는 생성자의 인자로 정수를 받아 그 만큼 정수메모리를 할당한다.
	// 정수메모리는 임의의 값으로 채워보자.
	// main()이 실행되도록 X를 프로그램 해보자
	// 생성/소멸 관찰
	int main()
	{
		X a(20);	//20개의 int를 할당한다.
					//20개의 정수값은 uid(dre)로 채워라
		a.show();	//20개의 정수의 값을 출력한다.
		X b = a;	//b를 a와 같게 생성한다.(복사생성)
		b.show();	//b를 출력 a와 동일해야한다.
		
		if (isSame(a, b)) {
			cout << "a와 b가 동일" << endl;
		}
		else {
			cout << "불일치" << endl;
		}
		
		save();
	}





-----------------------------------
Thu Oct 18 10:06:56 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid;

class X {
	int n;
	int* p;
public:
	X(int a) : n(a) {
		p = new int[n];
		cout << "메모리 할당 완료" << endl;

		for (int i = 0; i < n; ++i) {
			p[i] = uid(dre);
		}
		cout << "값 할당 완료" << endl;

		cout << "생성 완료" << endl;
	}
	X(const X& b) : n(b.n) {
		p = new int[b.n];
		cout << "메모리 할당 완료" << endl;
		for (int i = 0; i < b.n; ++i) {
			p[i] = b.p[i];
		}
		cout << "값 할당 완료" << endl;

		cout << "생성 완료" << endl;
		
	}
	void show() {
		for (int i = 0; i < n; ++i) {
			cout << i + 1 << "번째 - " << p[i] << endl;
		}
	}
	~X() {
		delete[] p;
		cout << "소멸 완료" << endl;
	}
	int getInt() {

		for(int i = 0;i<n;++i)
			return p[i];
	}
};

int isSame(X& a, X& b);
int isSame(X& a, X& b) {
	if (a.getInt() == b.getInt()) {
		return 1;
	}
	else{
		return 0;
	}
}

	// HEAP에서 자원을 할당하는 클래스
	// class X는 생성자의 인자로 정수를 받아 그 만큼 정수메모리를 할당한다.
	// 정수메모리는 임의의 값으로 채워보자.
	// main()이 실행되도록 X를 프로그램 해보자
	// 생성/소멸 관찰
	int main()
	{
		X a(20);	//20개의 int를 할당한다.
					//20개의 정수값은 uid(dre)로 채워라
		a.show();	//20개의 정수의 값을 출력한다.
		X b = a;	//b를 a와 같게 생성한다.(복사생성)
		b.show();	//b를 출력 a와 동일해야한다.
		
		if (isSame(a, b)) {
			cout << "a와 b가 동일" << endl;
		}
		else {
			cout << "불일치" << endl;
		}
		
		save();
	}





-----------------------------------
Thu Oct 18 10:08:13 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid(1,100);

class X {
	int n;
	int* p;
public:
	X(int a) : n(a) {
		p = new int[n];
		cout << "메모리 할당 완료" << endl;

		for (int i = 0; i < n; ++i) {
			p[i] = uid(dre);
		}
		cout << "값 할당 완료" << endl;

		cout << "생성 완료" << endl;
	}
	X(const X& b) : n(b.n) {
		p = new int[b.n];
		cout << "메모리 할당 완료" << endl;
		for (int i = 0; i < b.n; ++i) {
			p[i] = b.p[i];
		}
		cout << "값 할당 완료" << endl;

		cout << "생성 완료" << endl;
		
	}
	void show() {
		for (int i = 0; i < n; ++i) {
			cout << i + 1 << "번째 - " << p[i] << endl;
		}
	}
	~X() {
		delete[] p;
		cout << "소멸 완료" << endl;
	}
	int getInt() {

		for(int i = 0;i<n;++i)
			return p[i];
	}
};

int isSame(X& a, X& b);
int isSame(X& a, X& b) {
	if (a.getInt() == b.getInt()) {
		return 1;
	}
	else{
		return 0;
	}
}

	// HEAP에서 자원을 할당하는 클래스
	// class X는 생성자의 인자로 정수를 받아 그 만큼 정수메모리를 할당한다.
	// 정수메모리는 임의의 값으로 채워보자.
	// main()이 실행되도록 X를 프로그램 해보자
	// 생성/소멸 관찰
	int main()
	{
		X a(20);	//20개의 int를 할당한다.
					//20개의 정수값은 uid(dre)로 채워라
		a.show();	//20개의 정수의 값을 출력한다.
		X b = a;	//b를 a와 같게 생성한다.(복사생성)
		b.show();	//b를 출력 a와 동일해야한다.
		
		if (isSame(a, b)) {
			cout << "a와 b가 동일" << endl;
		}
		else {
			cout << "불일치" << endl;
		}
		
		save();
	}





-----------------------------------
Thu Oct 18 10:13:57 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid(1,100);

class X {
	int n;
	int* p;
public:
	X(int a) : n(a) {
		if (n <= 0) {
			cout << "양의 정수만 가능합니다." << endl;
		}
		else {
			p = new int[n];
			cout << "메모리 할당 완료" << endl;

			for (int i = 0; i < n; ++i) {
				p[i] = uid(dre);
			}
			cout << "값 할당 완료" << endl;

			cout << "생성 완료" << endl;
		}
	}
	X(const X& b) : n(b.n) {
		p = new int[b.n];
		cout << "메모리 할당 완료" << endl;
		for (int i = 0; i < b.n; ++i) {
			p[i] = b.p[i];
		}
		cout << "값 할당 완료" << endl;

		cout << "생성 완료" << endl;
		
	}
	void show() const{
		for (int i = 0; i < n; ++i) {
			cout << i + 1 << "번째 - " << p[i] << endl;
		}
	}
	~X() {
		delete[] p;
		cout << "소멸 완료" << endl;
	}
	int getInt() {

		for(int i = 0;i<n;++i)
			return p[i];
	}
};

int isSame(X& a, X& b);
int isSame(X& a, X& b) {
	if (a.getInt() == b.getInt()) {
		return 1;
	}
	else{
		return 0;
	}
}

	// HEAP에서 자원을 할당하는 클래스
	// class X는 생성자의 인자로 정수를 받아 그 만큼 정수메모리를 할당한다.
	// 정수메모리는 임의의 값으로 채워보자.
	// main()이 실행되도록 X를 프로그램 해보자
	// 생성/소멸 관찰
	int main()
	{
		X a(-1);	//20개의 int를 할당한다.
					//20개의 정수값은 uid(dre)로 채워라
		//a.show();	//20개의 정수의 값을 출력한다.
		//X b = a;	//b를 a와 같게 생성한다.(복사생성)
		//b.show();	//b를 출력 a와 동일해야한다.
	/*	
		if (isSame(a, b)) {
			cout << "a와 b가 동일" << endl;
		}
		else {
			cout << "불일치" << endl;
		}
		*/
		save();
	}





-----------------------------------
Thu Oct 18 10:16:02 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid(1,100);

class X {
	int n;
	int* p;
public:
	X(int a) : n(a) {
		if (n <= 0) {
			cout << "양의 정수만 가능합니다." << endl;
			n = 0;
		}
		else {
			p = new int[n];
			cout << "메모리 할당 완료" << endl;

			for (int i = 0; i < n; ++i) {
				p[i] = uid(dre);
			}
			cout << "값 할당 완료" << endl;

			cout << "생성 완료" << endl;
		}
	}
	X(const X& b) : n(b.n) {
		p = new int[b.n];
		cout << "메모리 할당 완료" << endl;
		for (int i = 0; i < b.n; ++i) {
			p[i] = b.p[i];
		}
		cout << "값 할당 완료" << endl;

		cout << "생성 완료" << endl;
		
	}
	void show() const{
		for (int i = 0; i < n; ++i) {
			cout << i + 1 << "번째 - " << p[i] << endl;
		}
	}
	~X() {
		if (n == 0) {
			delete[] p;
		}
		else {
			cout << "소멸 완료" << endl;
		}
	}
	int getInt() {

		for(int i = 0;i<n;++i)
			return p[i];
	}
};

int isSame(X& a, X& b);
int isSame(X& a, X& b) {
	if (a.getInt() == b.getInt()) {
		return 1;
	}
	else{
		return 0;
	}
}

	// HEAP에서 자원을 할당하는 클래스
	// class X는 생성자의 인자로 정수를 받아 그 만큼 정수메모리를 할당한다.
	// 정수메모리는 임의의 값으로 채워보자.
	// main()이 실행되도록 X를 프로그램 해보자
	// 생성/소멸 관찰
	int main()
	{
		X a(-1);	//20개의 int를 할당한다.
					//20개의 정수값은 uid(dre)로 채워라
		//a.show();	//20개의 정수의 값을 출력한다.
		//X b = a;	//b를 a와 같게 생성한다.(복사생성)
		//b.show();	//b를 출력 a와 동일해야한다.
	
		//if (isSame(a, b)) {
		//	cout << "a와 b가 동일" << endl;
		//}
		//else {
		//	cout << "불일치" << endl;
		//}
		//
		save();
	}





-----------------------------------
Thu Oct 18 10:16:31 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid(1,100);

class X {
	int n;
	int* p;
public:
	X(int a) : n(a) {
		if (n <= 0) {
			cout << "양의 정수만 가능합니다." << endl;
			n = 0;
		}
		else {
			p = new int[n];
			cout << "메모리 할당 완료" << endl;

			for (int i = 0; i < n; ++i) {
				p[i] = uid(dre);
			}
			cout << "값 할당 완료" << endl;

			cout << "생성 완료" << endl;
		}
	}
	X(const X& b) : n(b.n) {
		p = new int[b.n];
		cout << "메모리 할당 완료" << endl;
		for (int i = 0; i < b.n; ++i) {
			p[i] = b.p[i];
		}
		cout << "값 할당 완료" << endl;

		cout << "생성 완료" << endl;
		
	}
	void show() const{
		for (int i = 0; i < n; ++i) {
			cout << i + 1 << "번째 - " << p[i] << endl;
		}
	}
	~X() {
		if (n != 0) {
			delete[] p;
		}
		else {
			cout << "소멸 완료" << endl;
		}
	}
	int getInt() {

		for(int i = 0;i<n;++i)
			return p[i];
	}
};

int isSame(X& a, X& b);
int isSame(X& a, X& b) {
	if (a.getInt() == b.getInt()) {
		return 1;
	}
	else{
		return 0;
	}
}

	// HEAP에서 자원을 할당하는 클래스
	// class X는 생성자의 인자로 정수를 받아 그 만큼 정수메모리를 할당한다.
	// 정수메모리는 임의의 값으로 채워보자.
	// main()이 실행되도록 X를 프로그램 해보자
	// 생성/소멸 관찰
	int main()
	{
		X a(-1);	//20개의 int를 할당한다.
					//20개의 정수값은 uid(dre)로 채워라
		//a.show();	//20개의 정수의 값을 출력한다.
		//X b = a;	//b를 a와 같게 생성한다.(복사생성)
		//b.show();	//b를 출력 a와 동일해야한다.
	
		//if (isSame(a, b)) {
		//	cout << "a와 b가 동일" << endl;
		//}
		//else {
		//	cout << "불일치" << endl;
		//}
		//
		save();
	}





-----------------------------------
Thu Oct 18 10:16:48 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid(1,100);

class X {
	int n;
	int* p;
public:
	X(int a) : n(a) {
		if (n <= 0) {
			cout << "양의 정수만 가능합니다." << endl;
			n = 0;
		}
		else {
			p = new int[n];
			cout << "메모리 할당 완료" << endl;

			for (int i = 0; i < n; ++i) {
				p[i] = uid(dre);
			}
			cout << "값 할당 완료" << endl;

			cout << "생성 완료" << endl;
		}
	}
	X(const X& b) : n(b.n) {
		p = new int[b.n];
		cout << "메모리 할당 완료" << endl;
		for (int i = 0; i < b.n; ++i) {
			p[i] = b.p[i];
		}
		cout << "값 할당 완료" << endl;

		cout << "생성 완료" << endl;
		
	}
	void show() const{
		for (int i = 0; i < n; ++i) {
			cout << i + 1 << "번째 - " << p[i] << endl;
		}
	}
	~X() {
		if (n != 0) {
			delete[] p;
		}
		else {
			cout << "소멸 완료" << endl;
		}
	}
	int getInt() {

		for(int i = 0;i<n;++i)
			return p[i];
	}
};

int isSame(X& a, X& b);
int isSame(X& a, X& b) {
	if (a.getInt() == b.getInt()) {
		return 1;
	}
	else{
		return 0;
	}
}

	// HEAP에서 자원을 할당하는 클래스
	// class X는 생성자의 인자로 정수를 받아 그 만큼 정수메모리를 할당한다.
	// 정수메모리는 임의의 값으로 채워보자.
	// main()이 실행되도록 X를 프로그램 해보자
	// 생성/소멸 관찰
	int main()
	{
		X a(20);	//20개의 int를 할당한다.
					//20개의 정수값은 uid(dre)로 채워라
		a.show();	//20개의 정수의 값을 출력한다.
		X b = a;	//b를 a와 같게 생성한다.(복사생성)
		b.show();	//b를 출력 a와 동일해야한다.
	
		if (isSame(a, b)) {
			cout << "a와 b가 동일" << endl;
		}
		else {
			cout << "불일치" << endl;
		}
		
		save();
	}





-----------------------------------
Thu Oct 18 10:18:25 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid(1,100);

class X {
	int n;
	int* p;
public:
	X(int a) : n(a) {
		if (n <= 0) {
			cout << "양의 정수만 가능합니다." << endl;
			n = 0;
		}
		else {
			p = new int[n];
			cout << "메모리 할당 완료" << endl;

			for (int i = 0; i < n; ++i) {
				p[i] = uid(dre);
			}
			cout << "값 할당 완료" << endl;

			cout << "생성 완료" << endl;
		}
	}
	X(const X& b) : n(b.n) {
		p = new int[b.n];
		cout << "메모리 할당 완료" << endl;
		//아래의 과정을 deep copy라고 한다.
		for (int i = 0; i < b.n; ++i) {
			p[i] = b.p[i];
		}
		cout << "복사 완료" << endl;

		cout << "생성 완료" << endl;
		
	}
	void show() const{
		for (int i = 0; i < n; ++i) {
			cout << i + 1 << "번째 - " << p[i] << endl;
		}
	}
	~X() {
		if (n != 0) {
			delete[] p;
		}
		else {
			cout << "소멸 완료" << endl;
		}
	}
	int getInt() {

		for(int i = 0;i<n;++i)
			return p[i];
	}
};

int isSame(X& a, X& b);
int isSame(X& a, X& b) {
	if (a.getInt() == b.getInt()) {
		return 1;
	}
	else{
		return 0;
	}
}

	// HEAP에서 자원을 할당하는 클래스
	// class X는 생성자의 인자로 정수를 받아 그 만큼 정수메모리를 할당한다.
	// 정수메모리는 임의의 값으로 채워보자.
	// main()이 실행되도록 X를 프로그램 해보자
	// 생성/소멸 관찰
	int main()
	{
		X a(20);	//20개의 int를 할당한다.
					//20개의 정수값은 uid(dre)로 채워라
		a.show();	//20개의 정수의 값을 출력한다.
		X b = a;	//b를 a와 같게 생성한다.(복사생성)
		b.show();	//b를 출력 a와 동일해야한다.
	
		if (isSame(a, b)) {
			cout << "a와 b가 동일" << endl;
		}
		else {
			cout << "불일치" << endl;
		}
		
		save();
	}





-----------------------------------
Thu Oct 18 10:31:46 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid(1,100);

class X {
	int n;
	int* p;
public:
	X(int a) : n(a) {
		if (n <= 0) {
			cout << "양의 정수만 가능합니다." << endl;
			n = 0;
		}
		else {
			p = new int[n];
			cout << "메모리 할당 완료" << endl;

			for (int i = 0; i < n; ++i) {
				p[i] = uid(dre);
			}
			cout << "값 할당 완료" << endl;

			cout << "생성 완료" << endl;
		}
	}
	X(const X& b) : n(b.n) {
		p = new int[b.n];
		cout << "메모리 할당 완료" << endl;
		//아래의 과정을 deep copy라고 한다.
		for (int i = 0; i < b.n; ++i) {
			p[i] = b.p[i];
		}
		cout << "복사 완료" << endl;

		cout << "생성 완료" << endl;
		
	}
	void show() const{
		for (int i = 0; i < n; ++i) {
			cout << i + 1 << "번째 - " << p[i] << endl;
		}
	}
	~X() {
		if (n != 0) {
			delete[] p;
		}
		else {
			cout << "소멸 완료" << endl; 
		}
	}
	int getInt() {

		for(int i = 0;i<n;++i)
			return p[i];
	}
};

int isSame(X& a, X& b);
int isSame(X& a, X& b) {
	if (a.getInt() == b.getInt()) {
		return 1;
	}
	else{
		return 0;
	}
}

	// HEAP에서 자원을 할당하는 클래스
	// class X는 생성자의 인자로 정수를 받아 그 만큼 정수메모리를 할당한다.
	// 정수메모리는 임의의 값으로 채워보자.
	// main()이 실행되도록 X를 프로그램 해보자
	// 생성/소멸 관찰
	int main()
	{
		X a(20);	//20개의 int를 할당한다.
					//20개의 정수값은 uid(dre)로 채워라
		a.show();	//20개의 정수의 값을 출력한다.
		X b = a;	//b를 a와 같게 생성한다.(복사생성)
		b.show();	//b를 출력 a와 동일해야한다.
	
		if (isSame(a, b)) {
			cout << "a와 b가 동일" << endl;
		}
		else {
			cout << "불일치" << endl;
		}
		
		save();
	}





-----------------------------------
Thu Oct 18 10:39:58 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid(1,100);

class X {
	int n;
	int* p;
public:
	X(int a) : n(a) {
		if (n <= 0) {
			cout << "양의 정수만 가능합니다." << endl;
			n = 0;
		}
		else {
			p = new int[n];
			cout << "메모리 할당 완료" << endl;

			for (int i = 0; i < n; ++i) {
				p[i] = uid(dre);
			}
			cout << "값 할당 완료" << endl;

			cout << "생성 완료" << endl;
		}
	}
	X(const X& b) : n(b.n) {
		p = new int[b.n];
		cout << "메모리 할당 완료" << endl;
		//아래의 과정을 deep copy라고 한다.
		for (int i = 0; i < b.n; ++i) {
			p[i] = b.p[i];
		}
		cout << "복사 완료" << endl;

		cout << "생성 완료" << endl;
		
	}
	void show() const{
		for (int i = 0; i < n; ++i) {
			cout << i + 1 << "번째 - " << p[i] << endl;
		}
	}
	~X() {
		if (n != 0) {
			delete[] p;
		}
		else {
			cout << "소멸 완료" << endl; 
		}
	}
	int getN() const;
	int* getP() const;
};

int X::getN() const{
	return n;
}
int* X::getP() const {
	return p;
}
bool isSame(X& a, X& b);
bool isSame(X& a, X& b) {
	if (a.getN() == b.getN()) {
		return false;
	}
	for (int i = 0; i < a.getN(); ++i) {
		if (a.getP() != b.getP())
			return false;
	}
}

	// HEAP에서 자원을 할당하는 클래스
	// class X는 생성자의 인자로 정수를 받아 그 만큼 정수메모리를 할당한다.
	// 정수메모리는 임의의 값으로 채워보자.
	// main()이 실행되도록 X를 프로그램 해보자
	// 생성/소멸 관찰
	int main()
	{
		X a(20);	//20개의 int를 할당한다.
					//20개의 정수값은 uid(dre)로 채워라
		a.show();	//20개의 정수의 값을 출력한다.
		X b = a;	//b를 a와 같게 생성한다.(복사생성)
		b.show();	//b를 출력 a와 동일해야한다.
	
		if (isSame(a, b)) {
			cout << "a와 b가 동일" << endl;
		}
		else {
			cout << "불일치" << endl;
		}
		
		save();
	}





-----------------------------------
Thu Oct 18 10:41:08 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid(1,100);

class X {
	int n;
	int* p;
public:
	X(int a) : n(a) {
		if (n <= 0) {
			cout << "양의 정수만 가능합니다." << endl;
			n = 0;
		}
		else {
			p = new int[n];
			cout << "메모리 할당 완료" << endl;

			for (int i = 0; i < n; ++i) {
				p[i] = uid(dre);
			}
			cout << "값 할당 완료" << endl;

			cout << "생성 완료" << endl;
		}
	}
	X(const X& b) : n(b.n) {
		p = new int[b.n];
		cout << "메모리 할당 완료" << endl;
		//아래의 과정을 deep copy라고 한다.
		for (int i = 0; i < b.n; ++i) {
			p[i] = b.p[i];
		}
		cout << "복사 완료" << endl;

		cout << "생성 완료" << endl;
		
	}
	void show() const{
		for (int i = 0; i < n; ++i) {
			cout << i + 1 << "번째 - " << p[i] << endl;
		}
	}
	~X() {
		if (n != 0) {
			delete[] p;
		}
		else {
			cout << "소멸 완료" << endl; 
		}
	}
	int getN() const;
	int* getP() const;
};

int X::getN() const{
	return n;
}
int* X::getP() const {
	return p;
}
bool isSame(X& a, X& b);
bool isSame(X& a, X& b) {
	if (a.getN() == b.getN()) {
		return false;
	}
	for (int i = 0; i < a.getN(); ++i) {
		if (a.getP() != b.getP())
			return false;
	}
}

	// HEAP에서 자원을 할당하는 클래스
	// class X는 생성자의 인자로 정수를 받아 그 만큼 정수메모리를 할당한다.
	// 정수메모리는 임의의 값으로 채워보자.
	// main()이 실행되도록 X를 프로그램 해보자
	// 생성/소멸 관찰
	int main()
	{
		X a(20);	//20개의 int를 할당한다.
					//20개의 정수값은 uid(dre)로 채워라
		a.show();	//20개의 정수의 값을 출력한다.
		X b = a;	//b를 a와 같게 생성한다.(복사생성)
		b.show();	//b를 출력 a와 동일해야한다.
	
		if (isSame(a,b))
		{
			cout << "일치" << endl;
		}
		else {
			cout << "불일치" << endl;
		}
		save();
	}





-----------------------------------
Thu Oct 18 10:41:28 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

default_random_engine dre;
uniform_int_distribution<> uid(1,100);

class X {
	int n;
	int* p;
public:
	X(int a) : n(a) {
		if (n <= 0) {
			cout << "양의 정수만 가능합니다." << endl;
			n = 0;
		}
		else {
			p = new int[n];
			cout << "메모리 할당 완료" << endl;

			for (int i = 0; i < n; ++i) {
				p[i] = uid(dre);
			}
			cout << "값 할당 완료" << endl;

			cout << "생성 완료" << endl;
		}
	}
	X(const X& b) : n(b.n) {
		p = new int[b.n];
		cout << "메모리 할당 완료" << endl;
		//아래의 과정을 deep copy라고 한다.
		for (int i = 0; i < b.n; ++i) {
			p[i] = b.p[i];
		}
		cout << "복사 완료" << endl;

		cout << "생성 완료" << endl;
		
	}
	void show() const{
		for (int i = 0; i < n; ++i) {
			cout << i + 1 << "번째 - " << p[i] << endl;
		}
	}
	~X() {
		if (n != 0) {
			delete[] p;
		}
		else {
			cout << "소멸 완료" << endl; 
		}
	}
	int getN() const;
	int* getP() const;
};

int X::getN() const{
	return n;
}
int* X::getP() const {
	return p;
}
bool isSame(X& a, X& b);
bool isSame(X& a, X& b) {
	if (a.getN() != b.getN()) {
		return false;
	}
	for (int i = 0; i < a.getN(); ++i) {
		if (a.getP() != b.getP())
			return false;
	}
}

	// HEAP에서 자원을 할당하는 클래스
	// class X는 생성자의 인자로 정수를 받아 그 만큼 정수메모리를 할당한다.
	// 정수메모리는 임의의 값으로 채워보자.
	// main()이 실행되도록 X를 프로그램 해보자
	// 생성/소멸 관찰
	int main()
	{
		X a(20);	//20개의 int를 할당한다.
					//20개의 정수값은 uid(dre)로 채워라
		a.show();	//20개의 정수의 값을 출력한다.
		X b = a;	//b를 a와 같게 생성한다.(복사생성)
		b.show();	//b를 출력 a와 동일해야한다.
	
		if (isSame(a,b))
		{
			cout << "일치" << endl;
		}
		else {
			cout << "불일치" << endl;
		}
		save();
	}





-----------------------------------
Thu Oct 18 10:59:49 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

//2차원 게임을 만들고있다.
//크기는 1km x 1km 영역이다.
//내 게임에는 전부 Dog 만 나온다.
//Dog는 이름과 나이 그리고 게임상의위치(x,y좌표)를 멤버로 갖는다.
//x,y좌표는 m단위로(-500,500), y좌표 m단위로(-500,500) 사이의 값을 각각 갖는다.

default_random_engine dre;
uniform_int_distribution<> uid(-500, 500);
struct Point
{
	float x, y;
};
class Dog
{
	string name;
	int age;
	Point p;
public:
	Dog(int a , string b) : age(a) , name(b){
		cout << age << "--" << name;
		p.x = uid(dre);
		p.y = uid(dre);
		cout << '(' << p.x << ',' << p.y << ')' << endl;
	}
};
//다음요구조건을 따르는 프로그램을 작성하라
//1. Dog 1000마리를 생성하라
//	x,y좌표는 임의의 값으로 생성한다.
//2. 사용자로부터 좌표값을 하나 받아라(이 좌표는폭탄의 위치)
//3. 폭탄반경 50m의 Dog는 화면에 "아이고, 나죽네"라고 출력하라
//4. 몇마리의 개가 사망했는지 출력하라
int main()
{
	for (int i = 0; i < 1000; ++i) {
		Dog a(i,"dog");
	}
	save();
}





-----------------------------------
Thu Oct 18 11:01:52 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

//2차원 게임을 만들고있다.
//크기는 1km x 1km 영역이다.
//내 게임에는 전부 Dog 만 나온다.
//Dog는 이름과 나이 그리고 게임상의위치(x,y좌표)를 멤버로 갖는다.
//x,y좌표는 m단위로(-500,500), y좌표 m단위로(-500,500) 사이의 값을 각각 갖는다.

default_random_engine dre;
uniform_int_distribution<> uid(-500, 500);
struct Point
{
	float x, y;
};
class Dog
{
	string name;
	int age;
	Point p;
public:
	Dog(int a , string b) : age(a) , name(b){
		cout << age << "--" << name;
		p.x = uid(dre);
		p.y = uid(dre);
		cout << '(' << p.x << ',' << p.y << ')' << endl;
	}
};
//다음요구조건을 따르는 프로그램을 작성하라
//1. Dog 1000마리를 생성하라
//	x,y좌표는 임의의 값으로 생성한다.

//2. 사용자로부터 좌표값을 하나 받아라(이 좌표는폭탄의 위치)

//3. 폭탄반경 50m의 Dog는 화면에 "아이고, 나죽네"라고 출력하라
//4. 몇마리의 개가 사망했는지 출력하라
int main()
{
	for (int i = 0; i < 1000; ++i) {
		Dog a(i,"dog");
	}
	float x, y;
	cin >> x;
	cin >> y;


	save();
}





-----------------------------------
Thu Oct 18 11:02:06 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

//2차원 게임을 만들고있다.
//크기는 1km x 1km 영역이다.
//내 게임에는 전부 Dog 만 나온다.
//Dog는 이름과 나이 그리고 게임상의위치(x,y좌표)를 멤버로 갖는다.
//x,y좌표는 m단위로(-500,500), y좌표 m단위로(-500,500) 사이의 값을 각각 갖는다.

default_random_engine dre;
uniform_int_distribution<> uid(-500, 500);
struct Point
{
	float x, y;
};
class Dog
{
	string name;
	int age;
	Point p;
public:
	Dog(int a , string b) : age(a) , name(b){
		cout << age << "--" << name;
		p.x = uid(dre);
		p.y = uid(dre);
		cout << '(' << p.x << ',' << p.y << ')' << endl;
	}
};
//다음요구조건을 따르는 프로그램을 작성하라
//1. Dog 1000마리를 생성하라
//	x,y좌표는 임의의 값으로 생성한다.

//2. 사용자로부터 좌표값을 하나 받아라(이 좌표는폭탄의 위치)

//3. 폭탄반경 50m의 Dog는 화면에 "아이고, 나죽네"라고 출력하라
//4. 몇마리의 개가 사망했는지 출력하라
int main()
{
	for (int i = 0; i < 1000; ++i) {
		Dog a(i,"dog");
	}
	float x, y;
	cin >> x;
	cin >> y;


	save();
}





-----------------------------------
Thu Oct 18 11:03:55 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include <math.h>
#include "save.h"
using namespace std;

//2차원 게임을 만들고있다.
//크기는 1km x 1km 영역이다.
//내 게임에는 전부 Dog 만 나온다.
//Dog는 이름과 나이 그리고 게임상의위치(x,y좌표)를 멤버로 갖는다.
//x,y좌표는 m단위로(-500,500), y좌표 m단위로(-500,500) 사이의 값을 각각 갖는다.

default_random_engine dre;
uniform_int_distribution<> uid(-500, 500);
struct Point
{
	float x, y;
};
class Dog
{
	string name;
	int age;
	Point p;
public:
	Dog(int a , string b) : age(a+1) , name(b){
		cout << age << "--" << name;
		p.x = uid(dre);
		p.y = uid(dre);
		cout << '(' << p.x << ',' << p.y << ')' << endl;
	}
};
//다음요구조건을 따르는 프로그램을 작성하라
//1. Dog 1000마리를 생성하라
//	x,y좌표는 임의의 값으로 생성한다.

//2. 사용자로부터 좌표값을 하나 받아라(이 좌표는폭탄의 위치)

//3. 폭탄반경 50m의 Dog는 화면에 "아이고, 나죽네"라고 출력하라
//4. 몇마리의 개가 사망했는지 출력하라
int main()
{
	for (int i = 0; i < 1000; ++i) {
		Dog a(i,"dog");
	}
	float x, y;
	cin >> x;
	cin >> y;


	save();
}





-----------------------------------
Thu Oct 18 14:35:51 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include <math.h>
#include "save.h"
using namespace std;

//2차원 게임을 만들고있다.
//크기는 1km x 1km 영역이다.
//내 게임에는 전부 Dog 만 나온다.
//Dog는 이름과 나이 그리고 게임상의위치(x,y좌표)를 멤버로 갖는다.
//x,y좌표는 m단위로(-500,500), y좌표 m단위로(-500,500) 사이의 값을 각각 갖는다.

default_random_engine dre;
uniform_int_distribution<> uid(-500, 500);
struct Point
{
	float x, y;
};
class Dog
{
	string name;
	int age;
	Point p;
public:
	
	Dog() : age(0), name("?") {
		cout << age << "--" << name;
		p.x = uid(dre);
		p.y = uid(dre);
		cout << '(' << p.x << ',' << p.y << ')' << endl;
	}
	
	float getPx() const {
		return p.x;
	}
	float getPy() const {
		return p.y;
	}
	void KillDog() {
		cout << "아이고 나죽네" << endl;
	}
	~Dog() {

	}
};
//다음요구조건을 따르는 프로그램을 작성하라
//1. Dog 1000마리를 생성하라
//	x,y좌표는 임의의 값으로 생성한다.

//2. 사용자로부터 좌표값을 하나 받아라(이 좌표는폭탄의 위치)

//3. 폭탄반경 50m의 Dog는 화면에 "아이고, 나죽네"라고 출력하라
//4. 몇마리의 개가 사망했는지 출력하라
int main()
{
	Dog* dogs = new Dog[1000];
	Point bomb;
	cin >> bomb.x;
	cin >> bomb.y;
	int cnt = 0;
	for (int i = 0; i < 1000; ++i) {


		if (sqrt((bomb.x - dogs->getPx())*(bomb.x - dogs->getPx()) + (bomb.y - dogs->getPy())*(bomb.y - dogs->getPy())) <= 50) {
			dogs->KillDog();
			cnt++;
		}
	}
	delete[] dogs;
	save();
}





-----------------------------------
Thu Oct 18 14:44:11 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include <math.h>
#include "save.h"
using namespace std;

//2차원 게임을 만들고있다.
//크기는 1km x 1km 영역이다.
//내 게임에는 전부 Dog 만 나온다.
//Dog는 이름과 나이 그리고 게임상의위치(x,y좌표)를 멤버로 갖는다.
//x,y좌표는 m단위로(-500,500), y좌표 m단위로(-500,500) 사이의 값을 각각 갖는다.
int cnt = 0;
default_random_engine dre;
uniform_int_distribution<> uid(-500, 500);
struct Point
{
	float x, y;
};
class Dog
{
	string name;
	int age;
	Point p;
public:
	
	Dog() : age(0), name("?") {
		cout << age << "--" << name;
		p.x = uid(dre);
		p.y = uid(dre);
		cout << '(' << p.x << ',' << p.y << ')' << endl;
	}
	
	float getPx() const {
		return p.x;
	}
	float getPy() const {
		return p.y;
	}
	void KillDog(float x, float y) {
		if (sqrt((x - getPx())*(x - getPx()) + (y - getPy())*(y - getPy())) <= 50)
		cout << "아이고 나죽네" << endl;
		cnt++;
	}
	~Dog() {

	}
};
//다음요구조건을 따르는 프로그램을 작성하라
//1. Dog 1000마리를 생성하라
//	x,y좌표는 임의의 값으로 생성한다.

//2. 사용자로부터 좌표값을 하나 받아라(이 좌표는폭탄의 위치)

//3. 폭탄반경 50m의 Dog는 화면에 "아이고, 나죽네"라고 출력하라
//4. 몇마리의 개가 사망했는지 출력하라

int main()
{
	Dog* dogs = new Dog[1000];
	Point bomb;
	cin >> bomb.x;
	cin >> bomb.y;
	

	dogs->KillDog(bomb.x, bomb.y);

	
	cout << cnt << endl;
	delete[] dogs;
	save();
}





-----------------------------------
Thu Oct 18 14:44:56 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include <math.h>
#include "save.h"
using namespace std;

//2차원 게임을 만들고있다.
//크기는 1km x 1km 영역이다.
//내 게임에는 전부 Dog 만 나온다.
//Dog는 이름과 나이 그리고 게임상의위치(x,y좌표)를 멤버로 갖는다.
//x,y좌표는 m단위로(-500,500), y좌표 m단위로(-500,500) 사이의 값을 각각 갖는다.
int cnt = 0;
default_random_engine dre;
uniform_int_distribution<> uid(-500, 500);
struct Point
{
	float x, y;
};
class Dog
{
	string name;
	int age;
	Point p;
public:
	
	Dog() : age(0), name("?") {
		cout << age << "--" << name;
		p.x = uid(dre);
		p.y = uid(dre);
		cout << '(' << p.x << ',' << p.y << ')' << endl;
	}
	
	float getPx() const {
		return p.x;
	}
	float getPy() const {
		return p.y;
	}
	void KillDog(float x, float y) {
		if (sqrt((x - getPx())*(x - getPx()) + (y - getPy())*(y - getPy())) <= 50){
			cout << "아이고 나죽네" << endl;
			cnt++;
		}
	}
	~Dog() {

	}
};
//다음요구조건을 따르는 프로그램을 작성하라
//1. Dog 1000마리를 생성하라
//	x,y좌표는 임의의 값으로 생성한다.

//2. 사용자로부터 좌표값을 하나 받아라(이 좌표는폭탄의 위치)

//3. 폭탄반경 50m의 Dog는 화면에 "아이고, 나죽네"라고 출력하라
//4. 몇마리의 개가 사망했는지 출력하라

int main()
{
	Dog* dogs = new Dog[1000];
	Point bomb;
	cin >> bomb.x;
	cin >> bomb.y;
	

	dogs->KillDog(bomb.x, bomb.y);

	
	cout << cnt << endl;
	delete[] dogs;
	save();
}





-----------------------------------
Thu Oct 18 14:45:33 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include <math.h>
#include "save.h"
using namespace std;

//2차원 게임을 만들고있다.
//크기는 1km x 1km 영역이다.
//내 게임에는 전부 Dog 만 나온다.
//Dog는 이름과 나이 그리고 게임상의위치(x,y좌표)를 멤버로 갖는다.
//x,y좌표는 m단위로(-500,500), y좌표 m단위로(-500,500) 사이의 값을 각각 갖는다.
int cnt = 0;
default_random_engine dre;
uniform_int_distribution<> uid(-500, 500);
struct Point
{
	float x, y;
};
class Dog
{
	string name;
	int age;
	Point p;
public:
	
	Dog() : age(0), name("?") {
		cout << age << "--" << name;
		p.x = uid(dre);
		p.y = uid(dre);
		cout << '(' << p.x << ',' << p.y << ')' << endl;
	}
	
	float getPx() const {
		return p.x;
	}
	float getPy() const {
		return p.y;
	}
	void KillDog(float x, float y) {
		if (sqrt((x - getPx())*(x - getPx()) + (y - getPy())*(y - getPy())) <= 50){
			cout << "아이고 나죽네" << endl;
			cnt++;
		}
	}
	~Dog() {

	}
};
//다음요구조건을 따르는 프로그램을 작성하라
//1. Dog 1000마리를 생성하라
//	x,y좌표는 임의의 값으로 생성한다.

//2. 사용자로부터 좌표값을 하나 받아라(이 좌표는폭탄의 위치)

//3. 폭탄반경 50m의 Dog는 화면에 "아이고, 나죽네"라고 출력하라
//4. 몇마리의 개가 사망했는지 출력하라

int main()
{
	Dog* dogs = new Dog[1000];
	Point bomb;
	cin >> bomb.x;
	cin >> bomb.y;
	
	for (int i = 0; i < 1000; ++i) {
		dogs->KillDog(bomb.x, bomb.y);
	}
	
	cout << cnt << endl;
	delete[] dogs;
	save();
}





-----------------------------------
Thu Oct 18 14:49:00 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include <math.h>
#include "save.h"
using namespace std;

//2차원 게임을 만들고있다.
//크기는 1km x 1km 영역이다.
//내 게임에는 전부 Dog 만 나온다.
//Dog는 이름과 나이 그리고 게임상의위치(x,y좌표)를 멤버로 갖는다.
//x,y좌표는 m단위로(-500,500), y좌표 m단위로(-500,500) 사이의 값을 각각 갖는다.
int cnt = 0;
default_random_engine dre;
uniform_int_distribution<> uid(-500, 500);
struct Point
{
	float x, y;
};
class Dog
{
	string name;
	int age;
	Point p;
public:
	
	Dog() : age(0), name("?") {
		cout << age << "--" << name;
		p.x = uid(dre);
		p.y = uid(dre);
		cout << '(' << p.x << ',' << p.y << ')' << endl;
	}
	
	float getPx() const {
		return p.x;
	}
	float getPy() const {
		return p.y;
	}
	void KillDog(float x, float y) {
		if (sqrt((x - getPx())*(x - getPx()) + (y - getPy())*(y - getPy())) <= 50){
			cout << "아이고 나죽네" << endl;
			cnt++;
		}
	}
	~Dog() {

	}
};
//다음요구조건을 따르는 프로그램을 작성하라
//1. Dog 1000마리를 생성하라
//	x,y좌표는 임의의 값으로 생성한다.

//2. 사용자로부터 좌표값을 하나 받아라(이 좌표는폭탄의 위치)

//3. 폭탄반경 50m의 Dog는 화면에 "아이고, 나죽네"라고 출력하라
//4. 몇마리의 개가 사망했는지 출력하라

int main()
{
	Dog* dogs = new Dog[1000];
	Point bomb;
	cin >> bomb.x;
	cin >> bomb.y;
	
	for (int i = 0; i < 1000; ++i) {
		//	dogs->KillDog(bomb.x, bomb.y);
		//}
		if (sqrt((bomb.x - dogs[i].getPx())*(bomb.x - dogs[i].getPx()) + (bomb.y - dogs[i].getPy())*(bomb.y - dogs[i].getPy())) <= 50) {
			cout << "아이고 나죽네" << endl;
			cnt++;
		}
	}
	cout << cnt << endl;
	delete[] dogs;
	save();
}





-----------------------------------
Thu Oct 18 14:51:21 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include <math.h>
#include "save.h"
using namespace std;

//2차원 게임을 만들고있다.
//크기는 1km x 1km 영역이다.
//내 게임에는 전부 Dog 만 나온다.
//Dog는 이름과 나이 그리고 게임상의위치(x,y좌표)를 멤버로 갖는다.
//x,y좌표는 m단위로(-500,500), y좌표 m단위로(-500,500) 사이의 값을 각각 갖는다.
int cnt = 0;
default_random_engine dre;
uniform_int_distribution<> uid(-500, 500);
struct Point
{
	float x, y;
};
class Dog
{
	string name;
	int age;
	Point p;
public:
	
	Dog() : age(0), name("?") {
		cout << age << "--" << name;
		p.x = uid(dre);
		p.y = uid(dre);
		cout << '(' << p.x << ',' << p.y << ')' << endl;
	}
	
	float getPx() const {
		return p.x;
	}
	float getPy() const {
		return p.y;
	}
	~Dog() {

	}
};
//다음요구조건을 따르는 프로그램을 작성하라
//1. Dog 1000마리를 생성하라
//	x,y좌표는 임의의 값으로 생성한다.

//2. 사용자로부터 좌표값을 하나 받아라(이 좌표는폭탄의 위치)

//3. 폭탄반경 50m의 Dog는 화면에 "아이고, 나죽네"라고 출력하라
//4. 몇마리의 개가 사망했는지 출력하라

int main()
{
	Dog* dogs = new Dog[1000];
	Point bomb;
	cin >> bomb.x;
	cin >> bomb.y;
	
	for (int i = 0; i < 1000; ++i) {
		if (sqrt((bomb.x - dogs[i].getPx())*(bomb.x - dogs[i].getPx()) + (bomb.y - dogs[i].getPy())*(bomb.y - dogs[i].getPy())) <= 50) {
			cout << "아이고 나죽네" << endl;
			
			cnt++;
		}
	}
	cout << cnt << endl;
	delete[] dogs;
	save();
}





-----------------------------------
Thu Oct 18 14:51:39 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include <math.h>
#include "save.h"
using namespace std;

//2차원 게임을 만들고있다.
//크기는 1km x 1km 영역이다.
//내 게임에는 전부 Dog 만 나온다.
//Dog는 이름과 나이 그리고 게임상의위치(x,y좌표)를 멤버로 갖는다.
//x,y좌표는 m단위로(-500,500), y좌표 m단위로(-500,500) 사이의 값을 각각 갖는다.
int cnt = 0;
default_random_engine dre;
uniform_int_distribution<> uid(-500, 500);
struct Point
{
	float x, y;
};
class Dog
{
	string name;
	int age;
	Point p;
public:
	
	Dog() : age(0), name("?") {
		cout << age << "--" << name;
		p.x = uid(dre);
		p.y = uid(dre);
		cout << '(' << p.x << ',' << p.y << ')' << endl;
	}
	
	float getPx() const {
		return p.x;
	}
	float getPy() const {
		return p.y;
	}
	~Dog() {

	}
};
//다음요구조건을 따르는 프로그램을 작성하라
//1. Dog 1000마리를 생성하라
//	x,y좌표는 임의의 값으로 생성한다.

//2. 사용자로부터 좌표값을 하나 받아라(이 좌표는폭탄의 위치)

//3. 폭탄반경 50m의 Dog는 화면에 "아이고, 나죽네"라고 출력하라
//4. 몇마리의 개가 사망했는지 출력하라

int main()
{
	Dog* dogs = new Dog[1000];
	Point bomb;
	cin >> bomb.x;
	cin >> bomb.y;
	
	for (int i = 0; i < 1000; ++i) {
		if (sqrt((bomb.x - dogs[i].getPx())*(bomb.x - dogs[i].getPx()) + (bomb.y - dogs[i].getPy())*(bomb.y - dogs[i].getPy())) <= 50) {
			cout << "아이고 나죽네" << endl;
			
			cnt++;
		}
	}
	cout << cnt << endl;
	delete[] dogs;
	save();
}





-----------------------------------
Thu Oct 18 14:55:48 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include <math.h>
#include "save.h"
using namespace std;

//2차원 게임을 만들고있다.
//크기는 1km x 1km 영역이다.
//내 게임에는 전부 Dog 만 나온다.
//Dog는 이름과 나이 그리고 게임상의위치(x,y좌표)를 멤버로 갖는다.
//x,y좌표는 m단위로(-500,500), y좌표 m단위로(-500,500) 사이의 값을 각각 갖는다.
int cnt = 0;
default_random_engine dre;
uniform_int_distribution<> uid(-500, 500);
struct Point
{
	float x, y;
};
class Dog
{
	string name;
	int age;
	Point p;
public:
	
	Dog() : age(0), name("?") {
		cout << age << "--" << name;
		p.x = uid(dre);
		p.y = uid(dre);
		cout << '(' << p.x << ',' << p.y << ')' << endl;
	}
	
	float getPx() const {
		return p.x;
	}
	float getPy() const {
		return p.y;
	}
	~Dog() {

	}
};
//다음요구조건을 따르는 프로그램을 작성하라
//1. Dog 1000마리를 생성하라
//	x,y좌표는 임의의 값으로 생성한다.

//2. 사용자로부터 좌표값을 하나 받아라(이 좌표는폭탄의 위치)

//3. 폭탄반경 50m의 Dog는 화면에 "아이고, 나죽네"라고 출력하라
//4. 몇마리의 개가 사망했는지 출력하라


int main()
{
	Dog* dogs = new Dog[1000];
	Point bomb;
	cin >> bomb.x;
	cin >> bomb.y;
	
	for (int i = 0; i < 1000; ++i) {
		if (sqrt((bomb.x - dogs[i].getPx())*(bomb.x - dogs[i].getPx()) + (bomb.y - dogs[i].getPy())*(bomb.y - dogs[i].getPy())) <= 50) {
			cout << "아이고 나죽네" << endl;
			cnt++;
		}
	}
	cout << cnt << "마리 사망" << endl;
	delete[] dogs;
	save();
}



-----------------------------------
Mon Oct 22 13:31:14 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include <math.h>
#include "save.h"
using namespace std;

//2차원 게임을 만들고있다.
//크기는 1km x 1km 영역이다.
//내 게임에는 전부 Dog 만 나온다.
//Dog는 이름과 나이 그리고 게임상의위치(x,y좌표)를 멤버로 갖는다.
//x,y좌표는 m단위로(-500,500), y좌표 m단위로(-500,500) 사이의 값을 각각 갖는다.
int cnt = 0;
default_random_engine dre;
uniform_int_distribution<> uid(-500, 500);
struct Point
{
	float x, y;
};
class Dog
{
	string name;
	int age;
	Point p;
public:
	
	Dog() : age(0), name("?") {
		cout << age << "--" << name;
		p.x = uid(dre);
		p.y = uid(dre);
		cout << '(' << p.x << ',' << p.y << ')' << endl;
	}
	
	float getPx() const {
		return p.x;
	}
	float getPy() const {
		return p.y;
	}
	~Dog() {

	}
};
//다음요구조건을 따르는 프로그램을 작성하라
//1. Dog 1000마리를 생성하라
//	x,y좌표는 임의의 값으로 생성한다.

//2. 사용자로부터 좌표값을 하나 받아라(이 좌표는폭탄의 위치)

//3. 폭탄반경 50m의 Dog는 화면에 "아이고, 나죽네"라고 출력하라
//4. 몇마리의 개가 사망했는지 출력하라


int main()
{
	Dog* dogs = new Dog[1000];
	Point bomb;
	cin >> bomb.x;
	cin >> bomb.y;
	
	for (int i = 0; i < 1000; ++i) {
		if (sqrt((bomb.x - dogs[i].getPx())*(bomb.x - dogs[i].getPx()) + (bomb.y - dogs[i].getPy())*(bomb.y - dogs[i].getPy())) <= 50) {
			cout << "아이고 나죽네" << endl;
			cnt++;
		}
	}
	cout << cnt << "마리 사망" << endl;
	delete[] dogs;
	save();
}



-----------------------------------
Mon Oct 22 13:32:23 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include <math.h>
#include "save.h"
using namespace std;

//2차원 게임을 만들고있다.
//크기는 1km x 1km 영역이다.
//내 게임에는 전부 Dog 만 나온다.
//Dog는 이름과 나이 그리고 게임상의위치(x,y좌표)를 멤버로 갖는다.
//x,y좌표는 m단위로(-500,500), y좌표 m단위로(-500,500) 사이의 값을 각각 갖는다.
int cnt = 0;
default_random_engine dre;
uniform_int_distribution<> uid(-500, 500);
struct Point
{
	float x, y;
};
class Dog
{
	string name;
	int age;
	Point p;
public:
	
	Dog() : age(0), name("?") {
		cout << age << "--" << name;
		p.x = uid(dre);
		p.y = uid(dre);
		cout << '(' << p.x << ',' << p.y << ')' << endl;
	}
	
	float getPx() const {
		return p.x;
	}
	float getPy() const {
		return p.y;
	}
	~Dog() {

	}
};
//다음요구조건을 따르는 프로그램을 작성하라
//1. Dog 1000마리를 생성하라
//	x,y좌표는 임의의 값으로 생성한다.

//2. 사용자로부터 좌표값을 하나 받아라(이 좌표는폭탄의 위치)

//3. 폭탄반경 50m의 Dog는 화면에 "아이고, 나죽네"라고 출력하라
//4. 몇마리의 개가 사망했는지 출력하라


int main()
{
	Dog* dogs = new Dog[1000];
	Point bomb;
	cout << "폭탄 x 좌표 : " << endl;
	cin >> bomb.x;
	cout << "폭탄 y 좌표 : " << endl;
	cin >> bomb.y;
	
	for (int i = 0; i < 1000; ++i) {
		if (sqrt((bomb.x - dogs[i].getPx())*(bomb.x - dogs[i].getPx()) + (bomb.y - dogs[i].getPy())*(bomb.y - dogs[i].getPy())) <= 50) {
			cout << "아이고 나죽네" << endl;
			cnt++;
		}
	}
	cout << cnt << "마리 사망" << endl;
	delete[] dogs;
	save();
}



-----------------------------------
Mon Oct 22 13:32:48 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include <math.h>
#include "save.h"
using namespace std;

//2차원 게임을 만들고있다.
//크기는 1km x 1km 영역이다.
//내 게임에는 전부 Dog 만 나온다.
//Dog는 이름과 나이 그리고 게임상의위치(x,y좌표)를 멤버로 갖는다.
//x,y좌표는 m단위로(-500,500), y좌표 m단위로(-500,500) 사이의 값을 각각 갖는다.
int cnt = 0;
default_random_engine dre;
uniform_int_distribution<> uid(-500, 500);
struct Point
{
	float x, y;
};
class Dog
{
	string name;
	int age;
	Point p;
public:
	
	Dog() : age(0), name("?") {
		cout << age << "--" << name;
		p.x = uid(dre);
		p.y = uid(dre);
		cout << '(' << p.x << ',' << p.y << ')' << endl;
	}
	
	float getPx() const {
		return p.x;
	}
	float getPy() const {
		return p.y;
	}
	~Dog() {

	}
};
//다음요구조건을 따르는 프로그램을 작성하라
//1. Dog 1000마리를 생성하라
//	x,y좌표는 임의의 값으로 생성한다.

//2. 사용자로부터 좌표값을 하나 받아라(이 좌표는폭탄의 위치)

//3. 폭탄반경 50m의 Dog는 화면에 "아이고, 나죽네"라고 출력하라
//4. 몇마리의 개가 사망했는지 출력하라


int main()
{
	Dog* dogs = new Dog[1000];
	Point bomb;
	cout << "폭탄 x 좌표 : ";
	cin >> bomb.x;
	cout << "폭탄 y 좌표 : ";
	cin >> bomb.y;
	
	for (int i = 0; i < 1000; ++i) {
		if (sqrt((bomb.x - dogs[i].getPx())*(bomb.x - dogs[i].getPx()) + (bomb.y - dogs[i].getPy())*(bomb.y - dogs[i].getPy())) <= 50) {
			cout << "아이고 나죽네" << endl;
			cnt++;
		}
	}
	cout << cnt << "마리 사망" << endl;
	delete[] dogs;
	save();
}



-----------------------------------
Mon Oct 22 13:36:14 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

//2차원 게임을 만들고있다.
//크기는 1km x 1km 영역이다.
//내 게임에는 전부 Dog 만 나온다.
//Dog는 이름과 나이 그리고 게임상의위치(x,y좌표)를 멤버로 갖는다.
//x,y좌표는 m단위로(-500,500), y좌표 m단위로(-500,500) 사이의 값을 각각 갖는다.
int cnt = 0;
default_random_engine dre;
uniform_int_distribution<> uid(-500, 500);
struct Point
{
	float x, y;
};
class Dog
{
	string name;
	int age;
	Point p;
public:
	
	Dog() : age(0), name("?") {
		cout << age << "--" << name;
		p.x = uid(dre);
		p.y = uid(dre);
		cout << '(' << p.x << ',' << p.y << ')' << endl;
	}
	
	float getPx() const {
		return p.x;
	}
	float getPy() const {
		return p.y;
	}
	~Dog() {

	}
};
//다음요구조건을 따르는 프로그램을 작성하라
//1. Dog 1000마리를 생성하라
//	x,y좌표는 임의의 값으로 생성한다.

//2. 사용자로부터 좌표값을 하나 받아라(이 좌표는폭탄의 위치)

//3. 폭탄반경 50m의 Dog는 화면에 "아이고, 나죽네"라고 출력하라
//4. 몇마리의 개가 사망했는지 출력하라


int main()
{
	Dog* dogs = new Dog[1000];
	Point bomb;
	cout << "폭탄 x 좌표 : ";
	cin >> bomb.x;
	cout << "폭탄 y 좌표 : ";
	cin >> bomb.y;
	
	for (int i = 0; i < 1000; ++i) {
		if (sqrt((bomb.x - dogs[i].getPx())*(bomb.x - dogs[i].getPx()) + (bomb.y - dogs[i].getPy())*(bomb.y - dogs[i].getPy())) <= 50) {
			cout << "아이고 나죽네" << endl;
			cnt++;
		}
	}
	cout << cnt << "마리 사망" << endl;
	delete[] dogs;
	save();
}



-----------------------------------
Mon Oct 22 13:40:14 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

//2차원 게임을 만들고있다.
//크기는 1km x 1km 영역이다.
//내 게임에는 전부 Dog 만 나온다.
//Dog는 이름과 나이 그리고 게임상의위치(x,y좌표)를 멤버로 갖는다.
//x,y좌표는 m단위로(-500,500), y좌표 m단위로(-500,500) 사이의 값을 각각 갖는다.
int cnt = 0;
default_random_engine dre;
uniform_int_distribution<> uid(-500, 500);
struct Point
{
	float x, y;
};
class Dog
{
	string name;
	int age;
	Point p;
public:
	
	Dog() : age(0), name("?") {
	/*	cout << age << "--" << name;
		p.x = uid(dre);
		p.y = uid(dre);
		cout << '(' << p.x << ',' << p.y << ')' << endl;*/
	}
	
	float getPx() const {
		return p.x;
	}
	float getPy() const {
		return p.y;
	}
	~Dog() {

	}
};
//다음요구조건을 따르는 프로그램을 작성하라
//1. Dog 1000마리를 생성하라
//	x,y좌표는 임의의 값으로 생성한다.

//2. 사용자로부터 좌표값을 하나 받아라(이 좌표는폭탄의 위치)

//3. 폭탄반경 50m의 Dog는 화면에 "아이고, 나죽네"라고 출력하라
//4. 몇마리의 개가 사망했는지 출력하라


int main()
{
	Dog* dogs = new Dog[1000];
	Point bomb;
	cout << "폭탄 x 좌표 : ";
	cin >> bomb.x;
	cout << "폭탄 y 좌표 : ";
	cin >> bomb.y;
	
	for (int i = 0; i < 1000; ++i) {
		if (sqrt((bomb.x - dogs[i].getPx())*(bomb.x - dogs[i].getPx()) + (bomb.y - dogs[i].getPy())*(bomb.y - dogs[i].getPy())) <= 50) {
			cout << "아이고 나죽네" << endl;
			cnt++;
		}
	}
	cout << cnt << "마리 사망" << endl;
	delete[] dogs;
	save();
}



-----------------------------------
Mon Oct 22 13:44:06 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include <random>
#include "save.h"
using namespace std;

//2차원 게임을 만들고있다.
//크기는 1km x 1km 영역이다.
//내 게임에는 전부 Dog 만 나온다.
//Dog는 이름과 나이 그리고 게임상의위치(x,y좌표)를 멤버로 갖는다.
//x,y좌표는 m단위로(-500,500), y좌표 m단위로(-500,500) 사이의 값을 각각 갖는다.
int cnt = 0;
default_random_engine dre;
uniform_int_distribution<> uid(-500, 500);
struct Point
{
	float x, y;
};
class Dog
{
	string name;
	int age;
	Point p;
public:
	
	Dog() : age(0), name("?") {
	/*	cout << age << "--" << name;
		p.x = uid(dre);
		p.y = uid(dre);
		cout << '(' << p.x << ',' << p.y << ')' << endl;*/
	}
	
	float getPx() const {
		return p.x;
	}
	float getPy() const {
		return p.y;
	}
	~Dog() {

	}
};
//다음요구조건을 따르는 프로그램을 작성하라
//1. Dog 1000마리를 생성하라
//	x,y좌표는 임의의 값으로 생성한다.

//2. 사용자로부터 좌표값을 하나 받아라(이 좌표는폭탄의 위치)

//3. 폭탄반경 50m의 Dog는 화면에 "아이고, 나죽네"라고 출력하라
//4. 몇마리의 개가 사망했는지 출력하라


int main()
{
	Dog* dogs = new Dog[1000];
	Point bomb;
	cout << "폭탄 x 좌표 : ";
	cin >> bomb.x;
	cout << "폭탄 y 좌표 : ";
	cin >> bomb.y;
	
	for (int i = 0; i < 1000; ++i) {
		float dx = bomb.x - dogs[i].getPx();
		float dy = bomb.y - dogs[i].getPy();
		float d = sqrt(dx*dx + dy*dy);
		if (d<=50) {
			cout << "아이고 나죽네" << endl;
			cnt++;
		}
	}
	cout << cnt << "마리 사망" << endl;
	delete[] dogs;
	save();
}



-----------------------------------
Mon Oct 22 14:00:48 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>

#include "save.h"
using namespace std;
class Int {
	int val;
public :
	Int(int n) : val(n){};

	int operator+(Int rhs) const {
		return val + rhs.val;
	}
};

//내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)
int main()
{
	Int a = 10, b = 20;

	cout << a + b << endl;
	save();
}



-----------------------------------
Mon Oct 22 14:03:35 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>

#include "save.h"
using namespace std;
class Int {
	int val;
public :
	Int(int n) : val(n){};
	//int operator+(Int rhs) const {
	//	return val + rhs.val;
	//}
	int getVal() {
		return val;
	}
};
int operator+(Int a, Int b)
{
	return a.getVal() + b.getVal();
}
//내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)
int main()
{
	Int a = 10, b = 20;

	cout << a + b << endl;
	save();
}



-----------------------------------
Mon Oct 22 14:03:58 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>

#include "save.h"
using namespace std;
class Int {
	int val;
public :
	Int(int n) : val(n){};
	//int operator+(Int rhs) const {
	//	return val + rhs.val;
	//}
	int getVal() const {
		return val;
	}
};
int operator+(Int a, Int b)
{
	return a.getVal() + b.getVal();
}
//내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)
int main()
{
	Int a = 10, b = 20;

	cout << a + b << endl;


	save();
}



-----------------------------------
Mon Oct 22 14:17:12 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>

#include "save.h"
using namespace std;

class Int {
	int val;
public :
	Int(int n) : val(n) {}
	int operator+(int rhs) const{
		return val + rhs;
	}
	int operator-(int rhs) const {
		return val - rhs;
	}
	int getVal() const { return val; }
};
// 내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)

int operator+(int lhs,Int rhs) 
{
	return lhs + rhs.getVal();
}
// 의도한 대로 출력되도록 Int를 프로그램하라
int main()
{
	Int a(10);
	Int b(20);

	cout << a + 10 << endl;		//20이라고 출력
	cout << b - 20 << endl;		// 0이라고 출력
	cout << 100 + a << endl;	//110이라고 출력
	save();
}



-----------------------------------
Mon Oct 22 14:19:57 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>

#include "save.h"
using namespace std;

class Int {
	int val;
public :
	Int(int n) : val(n) {}
	int operator+(int rhs) const{
		return val + rhs;
	}
	int operator-(int rhs) const {
		return val - rhs;
	}
	int getVal() const { return val; }
};
// 내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)

int operator+(int lhs,Int rhs) 
{
	return lhs + rhs.getVal();
}
// 의도한 대로 출력되도록 Int를 프로그램하라
int main()
{
	Int a(10);
	Int b(20);

	cout << a + 10 << endl;		//20이라고 출력
	//a.val+(b)
	cout << b - 20 << endl;		// 0이라고 출력
	cout << 100 + a << endl;	//110이라고 출력
	save();
}



-----------------------------------
Mon Oct 22 14:32:04 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>

#include "save.h"
using namespace std;

class Int {
	int val;
public :
	Int(int n) : val(n) {}
	int operator+(int rhs) const{
		return val + rhs;
	}
	int operator-(int rhs) const {
		return val - rhs;
	}
	int getVal() const { return val; }
};
// 내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)

int operator+(int lhs,Int rhs) 
{
	return lhs + rhs.getVal();
}
// 의도한 대로 출력되도록 Int를 프로그램하라
int main()
{
	Int a(10);
	Int b(20);

	cout << a + 10 << endl;		//20이라고 출력
	cout << b - 20 << endl;		// 0이라고 출력
	cout << 100 + a << endl;	//110이라고 출력
	save();
}



-----------------------------------
Mon Oct 22 14:45:10 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>

#include "save.h"
using namespace std;

class Int {
	int val;
public:
	Int(int n) : val(n) {}

	int operator++() {
		return val++;
	}
	int getVal() const { return val; }
};
// 내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)

// 이항연산자
// 단항연산자
//

// 의도한 대로 출력되도록 필요한 부분을 프로그램하라

int main()
{
	Int n = 10;

	cout << ++n << endl; 
	cout << n.getVal() << endl;
	save();
}



-----------------------------------
Mon Oct 22 14:46:12 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>

#include "save.h"
using namespace std;

class Int {
	int val;
public:
	Int(int n) : val(n) {}

	int operator++() {
		return val++;
	}
	int getVal() const { return val; }
	~Int() { cout << val << endl; }
};
// 내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)

// 이항연산자
// 단항연산자
//

// 의도한 대로 출력되도록 필요한 부분을 프로그램하라

int main()
{
	Int n = 10;

	cout << ++n << endl; 
	cout << n.getVal() << endl;
	save();
}



-----------------------------------
Mon Oct 22 14:46:30 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>

#include "save.h"
using namespace std;

class Int {
	int val;
public:
	Int(int n) : val(n) {}

	int operator++() {
		return val++;
	}
	int getVal() const { return val; }
};
// 내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)

// 이항연산자
// 단항연산자
//

// 의도한 대로 출력되도록 필요한 부분을 프로그램하라

int main()
{
	Int n = 10;

	cout << ++n << endl; 
	cout << n.getVal() << endl;
	save();
}



-----------------------------------
Mon Oct 22 14:48:31 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>

#include "save.h"
using namespace std;

class Int {
	int val=0;
public:
	Int(int n) : val(n) {}

	int operator++() {
		return val++;
	}
	int getVal() const { return val; }
};
// 내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)

// 이항연산자
// 단항연산자
//

// 의도한 대로 출력되도록 필요한 부분을 프로그램하라

int main()
{
	Int n = 10;

	cout << ++n << endl; 
	cout << n.getVal() << endl;
	save();
}



-----------------------------------
Mon Oct 22 14:53:28 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>

#include "save.h"
using namespace std;

class Int {
	int val=0;
public:
	Int(int n) : val(n) {}

	int operator++() {//후위 증가
		int temp = val;
		// 내 이전상태를 복사해둔다
		val = val + 1;
		// 나의 값을 1증가한다.
		return temp;
		// 내 이전상태를 리턴한다.
	}
	int getVal() const { return val; }
};
// 내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)

// 이항연산자
// 단항연산자
//

// 의도한 대로 출력되도록 필요한 부분을 프로그램하라
int main()
{
	Int n = 10;

	cout << ++n << endl; 
	cout << n.getVal() << endl;
	save();
}



-----------------------------------
Mon Oct 22 14:56:11 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>

#include "save.h"
using namespace std;

class Int {
	int val=0;
public:
	Int(int n) : val(n) {}

	int operator++(int n) {//후위 증가
		int temp = val;
		// 내 이전상태를 복사해둔다
		val = val + 1;
		// 나의 값을 1증가한다.
		return temp;
		// 내 이전상태를 리턴한다.
	}
	int getVal() const { return val; }
};
// 내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)

// 이항연산자
// 단항연산자
//

// 의도한 대로 출력되도록 필요한 부분을 프로그램하라
int main()
{
	Int n = 10;

	cout << n++ << endl; 
	//cout << ++n << endl;
	save();
}



-----------------------------------
Mon Oct 22 14:57:20 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>

#include "save.h"
using namespace std;

class Int {
	int val=0;
public:
	Int(int n) : val(n) {}

	int operator++(int n) {//후위 증가
		int temp = val;
		// 내 이전상태를 복사해둔다
		val = val + 1;
		// 나의 값을 1증가한다.
		return temp;
		// 내 이전상태를 리턴한다.
	}
	int operator++() {
		val = val + 1;
		return val;
	}
	int getVal() const { return val; }
};
// 내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)

// 이항연산자
// 단항연산자
//

// 의도한 대로 출력되도록 필요한 부분을 프로그램하라
int main()
{
	Int n = 10;

	cout << n++ << endl; 
	cout << ++n << endl;
	save();
}



-----------------------------------
Mon Oct 22 15:21:12 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Point {
	int x, y;
	Point (int n1,int n2) : x(n1),y(n2){}
};
class Dog {
	Point p;
	string name;
public:
	Dog(Point n, string s) : p(n) , name(s) {}

	/*int operator++() {
		int tempX = p.x;
		int tempY = p.y;

		p.x = p.x + 1;
		p.y = p.y + 1;
	
		return tempX;
		return tempY;
	}*/
	int operator++() {
		p.x = p.x + 1;
		p.y = p.y + 1;

		return p.x;
		return p.y;
	}

	void show() {
		cout << p.x << ',' << p.y << endl;
	}
};
// 내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)

// 이항연산자
// 단항연산자
//

// 의도한 대로 출력되도록 필요한 부분을 프로그램하라


int main()
{
	Dog a(Point(10, 10), "해피");
	Dog b(Point(10, 10), "언해피");
	//Dog c = a++;		//c의 위치 11,11
	//Dog d = ++b;		//d의 위치 11,11
	
	//c.show();
	//d.show();
	//Dog e = ++++c;
	//e.show();			//12,12
	save();
}



-----------------------------------
Mon Oct 22 19:10:09 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Point {
	int x, y;
	Point (int n1,int n2) : x(n1),y(n2){}
};
class Dog {
	Point p;
	string name;
public:
	Dog(Point n, string s) : p(n) , name(s) {}

	Dog operator++(int n) {
		Dog d(Point(p.x, p.y), name);

		p.x = p.x + 1;
		p.y = p.y + 1;
		return d;
	}
	Dog operator++() {
		Dog d(Point(p.x, p.y), name);

		return d;
	}

	void show() {
		cout << p.x << ',' << p.y << endl;
	}
};
// 내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)

// 이항연산자
// 단항연산자
//

// 의도한 대로 출력되도록 필요한 부분을 프로그램하라


int main()
{
	Dog a(Point(10, 10), "해피");
	Dog b(Point(10, 10), "언해피");
	Dog c = a++;		//c의 위치 11,11
	Dog d = ++b;		//d의 위치 11,11
	
	c.show();
	d.show();
	Dog e = ++++c;
	e.show();			//12,12
	save();
}



-----------------------------------
Mon Oct 22 19:11:15 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Point {
	int x, y;
	Point (int n1,int n2) : x(n1),y(n2){}
};
class Dog {
	Point p;
	string name;
public:
	Dog(Point n, string s) : p(n) , name(s) {}

	Dog operator++(int n) {
		Dog d(Point(p.x, p.y), name);

		p.x = p.x + 1;
		p.y = p.y + 1;
		return d;
	}
	Dog operator++() {
		
		p.x = p.x + 1;
		p.y = p.y + 1;
		
		Dog d(Point(p.x, p.y), name);

		return d;
	}

	void show() {
		cout << p.x << ',' << p.y << endl;
	}
};
// 내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)

// 이항연산자
// 단항연산자
//

// 의도한 대로 출력되도록 필요한 부분을 프로그램하라


int main()
{
	Dog a(Point(10, 10), "해피");
	Dog b(Point(10, 10), "언해피");
	Dog c = a++;		//c의 위치 11,11
	Dog d = ++b;		//d의 위치 11,11
	
	c.show();
	d.show();
	Dog e = ++++c;
	e.show();			//12,12
	save();
}



-----------------------------------
Mon Oct 22 19:13:29 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Point {
	int x, y;
	Point (int n1,int n2) : x(n1),y(n2){}
};
class Dog {
	Point p;
	string name;
public:
	Dog(Point n, string s) : p(n) , name(s) {}

	Dog operator++(int n) {
		Dog d(Point(p.x, p.y), name);

		p.x = p.x + 1;
		p.y = p.y + 1;
		return d;
	}
	Dog operator++() {
		
		p.x = p.x + 1;
		p.y = p.y + 1;
		
		Dog d(Point(p.x, p.y), name);

		return d;
	}

	void show() {
		cout << p.x << ',' << p.y << endl;
	}
};
// 내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)

// 이항연산자
// 단항연산자
//

// 의도한 대로 출력되도록 필요한 부분을 프로그램하라


int main()
{
	Dog a(Point(10, 10), "해피");
	Dog b(Point(10, 10), "언해피");
	Dog c = a++;		//c의 위치 11,11
	Dog d = ++b;		//d의 위치 11,11
	
	c.show();
	d.show();
	Dog e = ++++c;
	e.show();			//12,12
	save();
}



-----------------------------------
Thu Oct 25 09:21:49 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Point {
	int x, y;
	Point (int n1,int n2) : x(n1),y(n2){}
};
class Dog {
	Point p;
	string name;
public:
	Dog(Point n, string s) : p(n) , name(s) {}

	Dog operator++(int n) {
		Dog d(Point(p.x, p.y), name);

		p.x = p.x + 1;
		p.y = p.y + 1;
		return d;
	}
	Dog operator++() {
		
		p.x = p.x + 1;
		p.y = p.y + 1;
		
		Dog d(Point(p.x, p.y), name);

		return d;
	}

	void show() {
		cout << p.x << ',' << p.y << endl;
	}
};
// 내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)

// 이항연산자
// 단항연산자
//

// 의도한 대로 출력되도록 필요한 부분을 프로그램하라


int main()
{
	Dog a(Point(10, 10), "해피");
	Dog b(Point(10, 10), "언해피");
	Dog c = a++;		//c의 위치 11,11
	Dog d = ++b;		//d의 위치 11,11
	
	c.show();
	d.show();
	Dog e = ++++c;
	e.show();			//12,12
	save();
}



-----------------------------------
Thu Oct 25 09:30:19 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (8주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Point {
	int x, y;
	Point (int n1,int n2) : x(n1),y(n2){}
};
class Dog {
	Point p;
	string name;
public:
	Dog(Point n, string s) : p(n) , name(s) {}

	Dog operator++(int n) {
		Dog d(Point(p.x, p.y), name);

		p.x = p.x + 1;
		p.y = p.y + 1;
		return d;
	}
	Dog operator++() {
		
		p.x = p.x + 1;
		p.y = p.y + 1;
		
		Dog d(Point(p.x, p.y), name);

		return d;
	}

	void show() {
		cout << p.x << ',' << p.y << endl;
	}
};
// 내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)

// 이항연산자
// 단항연산자
//

// 의도한 대로 출력되도록 필요한 부분을 프로그램하라


int main()
{
	Dog a(Point(10, 10), "해피");
	Dog b(Point(10, 10), "언해피");
	Dog c = a++;		//c의 위치 11,11
	Dog d = ++b;		//d의 위치 11,11
	
	c.show();
	d.show();
	Dog e = ++++c;
	e.show();			//12,12
	save();
}



-----------------------------------
Thu Oct 25 09:37:12 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Point {
	int x, y;
	Point (int n1,int n2) : x(n1),y(n2){}
};
class Dog {
	Point p;
	string name;
public:
	Dog(Point n, string s) : p(n) , name(s) {
		cout << "생성자" << endl;
	}

	Dog operator++(int n) {
		Dog d(Point(p.x, p.y), name);

		p.x = p.x + 1;
		p.y = p.y + 1;
		return d;
	}
	Dog operator++() {
		
		p.x = p.x + 1;
		p.y = p.y + 1;
		
		Dog d(Point(p.x, p.y), name);

		return d;
	}

	void show() {
		cout << p.x << ',' << p.y << endl;
	}
	~Dog(){
		cout << "소멸자 - " << name << endl;
	}
};
// 내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)

// 이항연산자
// 단항연산자
//

// 의도한 대로 출력되도록 필요한 부분을 프로그램하라


int main()
{
	Dog a(Point(10, 10), "해피");
	Dog b(Point(10, 10), "언해피");
	Dog c = a++;		//c의 위치 11,11
	Dog d = ++b;		//d의 위치 11,11
	
	c.show();
	d.show();
	Dog e = ++++c;
	e.show();			//12,12
	save();
}



-----------------------------------
Thu Oct 25 09:44:03 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Point {
	int x, y;
	Point (int n1,int n2) : x(n1),y(n2){}
};
class Dog {
	Point p;
	string name;
public:
	Dog(Point n, string s) : p(n) , name(s) {
		cout << "생성자" << endl;
	}

	Dog operator++(int) {
		Dog d(*this);
		++(*this);
		return d;
	}
	Dog operator++() {
		++p.x;
		++p.y;
		return *this;
	}

	void show() {
		cout << p.x << ',' << p.y << endl;
	}
	~Dog(){
		cout << "소멸자 - " << name << endl;
	}
};
// 내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)

// 이항연산자
// 단항연산자
//

// 의도한 대로 출력되도록 필요한 부분을 프로그램하라


int main()
{
	Dog a(Point(10, 10), "해피");
	Dog b(Point(10, 10), "언해피");
	Dog c = a++;		//c의 위치 11,11
//	Dog c = a.operator++(int); 위의 문장과 동일
	Dog d = ++b;		//d의 위치 11,11
	
	c.show();
	d.show();
	Dog e = ++++c;
	e.show();			//12,12
	save();
}



-----------------------------------
Thu Oct 25 09:45:35 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Point {
	int x, y;
	Point (int n1,int n2) : x(n1),y(n2){}
};
class Dog {
	Point p;
	string name;
public:
	Dog(Point n, string s) : p(n) , name(s) {
		cout << "생성자" << endl;
	}

	Dog operator++(int) {
		Dog d(*this);
		++(*this);
		return d;
	}
	Dog operator++() {
		++p.x;
		++p.y;
		return *this;
	}

	void show() const {
		cout << name << '(' << p.x << ',' << p.y << ')' << endl;
	}
	~Dog(){
		cout << "소멸자 - " << name << endl;
	}
};
// 내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)

// 이항연산자
// 단항연산자
//

// 의도한 대로 출력되도록 필요한 부분을 프로그램하라


int main()
{
	Dog a(Point(10, 10), "해피");
	Dog b(Point(10, 10), "언해피");
	Dog c = a++;		//c의 위치 11,11
//	Dog c = a.operator++(int); 위의 문장과 동일
	Dog d = ++b;		//d의 위치 11,11
	
	c.show();
	d.show();
	Dog e = ++++c;
	e.show();			//12,12
	save();
}



-----------------------------------
Thu Oct 25 09:47:59 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Point {
	int x, y;
	Point (int n1,int n2) : x(n1),y(n2){}
};
class Dog {
	Point p;
	string name;
public:
	Dog(Point n, string s) : p(n) , name(s) {
		cout << "생성자" << endl;
	}

	Dog(const Dog& other) : p(other.p) , name(other.name){
		cout << "복생" << endl;
	}

	Dog operator++(int) {
		Dog d(*this);
		++(*this);
		return d;
	}
	Dog operator++() {
		++p.x;
		++p.y;
		return *this;
	}

	void show() const {
		cout << name << '(' << p.x << ',' << p.y << ')' << endl;
	}
	~Dog(){
		cout << "소멸자 - " << name << endl;
	}
};
// 내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)

// 이항연산자
// 단항연산자
//

// 의도한 대로 출력되도록 필요한 부분을 프로그램하라


int main()
{
	Dog a(Point(10, 10), "해피");
	Dog b(Point(10, 10), "언해피");
	Dog c = a++;		//c의 위치 11,11
//	Dog c = a.operator++(int); 위의 문장과 동일
	Dog d = ++b;		//d의 위치 11,11
	
	c.show();
	d.show();
	Dog e = ++++c;
	e.show();			//12,12
	save();
}



-----------------------------------
Thu Oct 25 09:48:37 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Point {
	int x, y;
	Point (int n1,int n2) : x(n1),y(n2){}
};
class Dog {
	Point p;
	string name;
public:
	Dog(Point n, string s) : p(n) , name(s) {
		cout << "생성자" << endl;
	}

	Dog(const Dog& other) : p(other.p) , name(other.name){
		cout << "복생" << name << endl;
	}

	Dog operator++(int) {
		Dog d(*this);
		++(*this);
		return d;
	}
	Dog operator++() {
		++p.x;
		++p.y;
		return *this;
	}

	void show() const {
		cout << name << '(' << p.x << ',' << p.y << ')' << endl;
	}
	~Dog(){
		cout << "소멸자 - " << name << endl;
	}
};
// 내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)

// 이항연산자
// 단항연산자
//

// 의도한 대로 출력되도록 필요한 부분을 프로그램하라


int main()
{
	Dog a(Point(10, 10), "해피");
	Dog b(Point(10, 10), "언해피");
	Dog c = a++;		//c의 위치 11,11
//	Dog c = a.operator++(int); 위의 문장과 동일
	Dog d = ++b;		//d의 위치 11,11
	
	c.show();
	d.show();
	Dog e = ++++c;
	e.show();			//12,12
	save();
}



-----------------------------------
Thu Oct 25 09:51:29 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Point {
	int x, y;
	Point (int n1,int n2) : x(n1),y(n2){}
};
class Dog {
	Point p;
	string name;
public:
	Dog(Point n, string s) : p(n) , name(s) {
		cout << "생성자" << endl;
	}

	Dog(const Dog& other) : p(other.p) , name(other.name){
		cout << "복생" << name << endl;
	}

	Dog operator++(int) {
		cout << "후위증가 함수" << endl;
		Dog d(*this);
		++(*this);
		return d;
		cout << "후위증가 끝" << endl;
	}
	Dog operator++() {
		++p.x;
		++p.y;
		return *this;
	}

	void show() const {
		cout << name << '(' << p.x << ',' << p.y << ')' << endl;
	}
	~Dog(){
		cout << "소멸자 - " << name << endl;
	}
};
// 내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)

// 이항연산자
// 단항연산자
//

// 의도한 대로 출력되도록 필요한 부분을 프로그램하라


int main()
{
	Dog a(Point(10, 10), "해피");
	Dog b(Point(10, 10), "언해피");
	Dog c = a++;		//c의 위치 11,11
//	Dog c = a.operator++(int); 위의 문장과 동일
	Dog d = ++b;		//d의 위치 11,11
	
	c.show();
	d.show();
	Dog e = ++++c;
	e.show();			//12,12
	save();
}



-----------------------------------
Thu Oct 25 09:51:53 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Point {
	int x, y;
	Point (int n1,int n2) : x(n1),y(n2){}
};
class Dog {
	Point p;
	string name;
public:
	Dog(Point n, string s) : p(n) , name(s) {
		cout << "생성자" << endl;
	}

	Dog(const Dog& other) : p(other.p) , name(other.name){
		cout << "복생" << name << endl;
	}

	Dog operator++(int) {
		cout << "후위증가 함수" << endl;
		Dog d(*this);
		++(*this);
		cout << "후위증가 끝" << endl;
		return d;
		
	}
	Dog operator++() {
		++p.x;
		++p.y;
		return *this;
	}

	void show() const {
		cout << name << '(' << p.x << ',' << p.y << ')' << endl;
	}
	~Dog(){
		cout << "소멸자 - " << name << endl;
	}
};
// 내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)

// 이항연산자
// 단항연산자
//

// 의도한 대로 출력되도록 필요한 부분을 프로그램하라


int main()
{
	Dog a(Point(10, 10), "해피");
	Dog b(Point(10, 10), "언해피");
	Dog c = a++;		//c의 위치 11,11
//	Dog c = a.operator++(int); 위의 문장과 동일
	Dog d = ++b;		//d의 위치 11,11
	
	c.show();
	d.show();
	Dog e = ++++c;
	e.show();			//12,12
	save();
}



-----------------------------------
Thu Oct 25 09:54:07 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Point {
	int x, y;
	Point (int n1,int n2) : x(n1),y(n2){}
};
class Dog {
	Point p;
	string name;
public:
	Dog(Point n, string s) : p(n) , name(s) {
		cout << "생성자" << endl;
	}

	Dog(const Dog& other) : p(other.p) , name(other.name){
		cout << "복생" << name << endl;
	}

	Dog operator++(int) {
		cout << "후위증가 함수" << endl;
		Dog d(*this);
		++(*this);
		cout << "후위증가 끝" << endl;
		return d;
		
	}
	Dog operator++() {
		cout << "전위증가 함수" << endl;
		++p.x;
		++p.y;
		cout << "전위증가 끝" << endl;
		return *this;
	}

	void show() const {
		cout << name << '(' << p.x << ',' << p.y << ')' << endl;
	}
	~Dog(){
		cout << "소멸자 - " << name << endl;
	}
};
// 내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)

// 이항연산자
// 단항연산자
//

// 의도한 대로 출력되도록 필요한 부분을 프로그램하라


int main()
{
	Dog a(Point(10, 10), "해피");
	Dog b(Point(10, 10), "언해피");
	Dog c = a++;		//c의 위치 11,11
//	Dog c = a.operator++(int); 위의 문장과 동일
	Dog d = ++b;		//d의 위치 11,11
	
	c.show();
	d.show();
	Dog e = ++++c;
	e.show();			//12,12
	save();
}



-----------------------------------
Thu Oct 25 10:02:55 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Point {
	int x, y;
	Point (int n1,int n2) : x(n1),y(n2){}
};
class Dog {
	Point p;
	string name;
public:
	Dog(Point n, string s) : p(n) , name(s) {
		cout << "생성자" << endl;
	}

	Dog(const Dog& other) : p(other.p) , name(other.name){
		cout << "복생" << name << endl;
	}

	Dog operator++(int) {

		Dog d(*this);
		++(*this);
		
		return d;
		
	}
	Dog& operator++() {

		++p.x;
		++p.y;
		
		return *this;
	}

	void show() const {
		cout << name << '(' << p.x << ',' << p.y << ')' << endl;
	}
	~Dog(){
		cout << "소멸자 - " << name << endl;
	}
};
// 내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)

// 이항연산자
// 단항연산자
//

// 의도한 대로 출력되도록 필요한 부분을 프로그램하라


int main()
{
	Dog a(Point(10, 10), "해피");
	Dog b(Point(10, 10), "언해피");
	Dog c = a++;		//c의 위치 11,11
	Dog d = ++b;		//d의 위치 11,11
	
	c.show();
	d.show();
	Dog e = ++++c;
	e.show();	//12,12
	c.show();
	save();
}



-----------------------------------
Thu Oct 25 10:03:19 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

struct Point {
	int x, y;
	Point (int n1,int n2) : x(n1),y(n2){}
};
class Dog {
	Point p;
	string name;
public:
	Dog(Point n, string s) : p(n) , name(s) {
	
	}

	Dog(const Dog& other) : p(other.p) , name(other.name){
	
	}

	Dog operator++(int) {

		Dog d(*this);
		++(*this);
		
		return d;
		
	}
	Dog& operator++() {

		++p.x;
		++p.y;
		
		return *this;
	}

	void show() const {
		cout << name << '(' << p.x << ',' << p.y << ')' << endl;
	}
	~Dog(){
		
	}
};
// 내가 만든 객체가 기존의 객체(POD)와 같은 방식으로
// 프로그램할 수 있게 만들고 싶다. --> 연산자 오버로딩(operator)

// 이항연산자
// 단항연산자
//

// 의도한 대로 출력되도록 필요한 부분을 프로그램하라


int main()
{
	Dog a(Point(10, 10), "해피");
	Dog b(Point(10, 10), "언해피");
	Dog c = a++;		//c의 위치 11,11
	Dog d = ++b;		//d의 위치 11,11
	
	c.show();
	d.show();
	Dog e = ++++c;
	e.show();	//12,12

	save();
}



-----------------------------------
Thu Oct 25 10:13:22 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;


int main()
{
	string s("string은 문자열을 다루는 전문 클래스이다.");
	
	s += ",클래스니까 나도 만들 수 있다.";
	cout << s << endl;
	save();
}



-----------------------------------
Thu Oct 25 11:14:13 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class myString {
	char* p;
	int len;
public:
	myString(const char* s) {
		
		len = strlen(s);	//글자수를 센다

		p = new char[len];	//메모리를 잡는다
		
		memcpy(p, s, len);	//메모리에 글자를 저장한다
	}

	myString operator +=(const myString& rhs) {
		cout << rhs.len << endl;
		int num = len + rhs.len;	// 새 메모리의 크기를 결정하자
		char* tp = new char[num];	// HEAP에서 메모리를 할당받자
		memcpy(tp, p, len);			// 새 메모리에 이전 글자들을 복사하자
		memcpy(tp + len, rhs.p, rhs.len);// 이전글자에 이어서 현재 글자를 이어붙이자
		delete p;// 이전 메모리를 해제하자
		len = num;	//합한글자수
		p = tp;		//합한 글자가 있는 메모리는 여기
		
		return *this;
	}
};

int main()
{
	
	myString s("string은 문자열을 다루는 전문 클래스이다");
	s += ",클래스니까 나도 만들 수 있다.";
	
	
	//s.show();		//이 함수는 문자들을 화면에 출력할 수 잇어야 함.
	//cout << s << endl;

	save();
}



-----------------------------------
Thu Oct 25 11:17:04 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class myString {
	char* p;
	int len;
public:
	myString(const char* s) {
		
		len = strlen(s);	//글자수를 센다

		p = new char[len];	//메모리를 잡는다
		
		memcpy(p, s, len);	//메모리에 글자를 저장한다
	}

	myString operator +=(const myString& rhs) {
		int num = len + rhs.len;	// 새 메모리의 크기를 결정하자
		char* tp = new char[num];	// HEAP에서 메모리를 할당받자
		memcpy(tp, p, len);			// 새 메모리에 이전 글자들을 복사하자
		memcpy(tp + len, rhs.p, rhs.len);// 이전글자에 이어서 현재 글자를 이어붙이자
		delete p;// 이전 메모리를 해제하자
		len = num;	//합한글자수
		p = tp;		//합한 글자가 있는 메모리는 여기
		
		return *this;
	}
	void show(){
		cout << p << endl;
	}
};

int main()
{
	
	myString s("string은 문자열을 다루는 전문 클래스이다");
	s += ",클래스니까 나도 만들 수 있다.";
	
	
	//s.show();		//이 함수는 문자들을 화면에 출력할 수 잇어야 함.
	//cout << s << endl;

	save();
}



-----------------------------------
Thu Oct 25 11:17:10 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class myString {
	char* p;
	int len;
public:
	myString(const char* s) {
		
		len = strlen(s);	//글자수를 센다

		p = new char[len];	//메모리를 잡는다
		
		memcpy(p, s, len);	//메모리에 글자를 저장한다
	}

	myString operator +=(const myString& rhs) {
		int num = len + rhs.len;	// 새 메모리의 크기를 결정하자
		char* tp = new char[num];	// HEAP에서 메모리를 할당받자
		memcpy(tp, p, len);			// 새 메모리에 이전 글자들을 복사하자
		memcpy(tp + len, rhs.p, rhs.len);// 이전글자에 이어서 현재 글자를 이어붙이자
		delete p;// 이전 메모리를 해제하자
		len = num;	//합한글자수
		p = tp;		//합한 글자가 있는 메모리는 여기
		
		return *this;
	}
	void show(){
		cout << p << endl;
	}
};

int main()
{
	
	myString s("string은 문자열을 다루는 전문 클래스이다");
	s += ",클래스니까 나도 만들 수 있다.";
	
	
	s.show();		//이 함수는 문자들을 화면에 출력할 수 잇어야 함.
	//cout << s << endl;

	save();
}



-----------------------------------
Mon Oct 29 13:32:12 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class myString {
	char* p;
	int len;
public:
	myString(const char* s) {
		
		len = strlen(s);	//글자수를 센다

		p = new char[len];	//메모리를 잡는다
		
		memcpy(p, s, len);	//메모리에 글자를 저장한다
	}

	myString operator +=(const myString& rhs) {
		int num = len + rhs.len;	// 새 메모리의 크기를 결정하자
		char* tp = new char[num];	// HEAP에서 메모리를 할당받자
		memcpy(tp, p, len);			// 새 메모리에 이전 글자들을 복사하자
		memcpy(tp + len, rhs.p, rhs.len);// 이전글자에 이어서 현재 글자를 이어붙이자
		delete p;// 이전 메모리를 해제하자
		len = num;	//합한글자수
		p = tp;		//합한 글자가 있는 메모리는 여기
		
		return *this;
	}
	void show(){

		cout << p;
	}
};

int main()
{
	
	myString s("string은 문자열을 다루는 전문 클래스이다");
	s += ",클래스니까 나도 만들 수 있다.";
	
	
	s.show();		//이 함수는 문자들을 화면에 출력할 수 잇어야 함.
	//cout << s << endl;

	save();
}



-----------------------------------
Mon Oct 29 13:34:06 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class myString {
	char* p;
	int len;
public:
	myString(const char* s) {
		
		len = strlen(s);	//글자수를 센다

		p = new char[len];	//메모리를 잡는다
		
		memcpy(p, s, len);	//메모리에 글자를 저장한다
	}

	myString operator +=(const myString& rhs) {
		int num = len + rhs.len;	// 새 메모리의 크기를 결정하자
		char* tp = new char[num];	// HEAP에서 메모리를 할당받자
		memcpy(tp, p, len);			// 새 메모리에 이전 글자들을 복사하자
		memcpy(tp + len, rhs.p, rhs.len);// 이전글자에 이어서 현재 글자를 이어붙이자
		delete p;// 이전 메모리를 해제하자
		len = num;	//합한글자수
		p = tp;		//합한 글자가 있는 메모리는 여기
		
		return *this;
	}
	void show(){

		cout << p << endl;
	}
};

int main()
{
	
	myString s("string은 문자열을 다루는 전문 클래스이다");
	s += ",클래스니까 나도 만들 수 있다.";
	
	myString a = s;
	s.show();		//이 함수는 문자들을 화면에 출력할 수 잇어야 함.
	a.show();

	save();
}



-----------------------------------
Mon Oct 29 13:36:32 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class myString {
	char* p;
	int len;
public:
	myString(const char* s) {
		
		len = strlen(s);	//글자수를 센다

		p = new char[len];	//메모리를 잡는다
		
		memcpy(p, s, len);	//메모리에 글자를 저장한다
	}

	myString operator +=(const myString& rhs) {
		int num = len + rhs.len;	// 새 메모리의 크기를 결정하자
		char* tp = new char[num];	// HEAP에서 메모리를 할당받자
		memcpy(tp, p, len);			// 새 메모리에 이전 글자들을 복사하자
		memcpy(tp + len, rhs.p, rhs.len);// 이전글자에 이어서 현재 글자를 이어붙이자
		delete[] p;// 이전 메모리를 해제하자
		len = num;	//합한글자수
		p = tp;		//합한 글자가 있는 메모리는 여기
		
		return *this;
	}
	void show(){
		for (int i = 0; i < len; ++i)
			cout << *(p + 1)
			<< endl;
	}
};

int main()
{
	
	myString s("string은 문자열을 다루는 전문 클래스이다");
	s += ",클래스니까 나도 만들 수 있다.";
	
	myString a = s;
	s.show();		//이 함수는 문자들을 화면에 출력할 수 잇어야 함.
	a.show();

	save();
}



-----------------------------------
Mon Oct 29 13:37:20 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class myString {
	char* p;
	int len;
public:
	myString(const char* s) {
		
		len = strlen(s);	//글자수를 센다

		p = new char[len];	//메모리를 잡는다
		
		memcpy(p, s, len);	//메모리에 글자를 저장한다
	}

	myString operator +=(const myString& rhs) {
		int num = len + rhs.len;	// 새 메모리의 크기를 결정하자
		char* tp = new char[num];	// HEAP에서 메모리를 할당받자
		memcpy(tp, p, len);			// 새 메모리에 이전 글자들을 복사하자
		memcpy(tp + len, rhs.p, rhs.len);// 이전글자에 이어서 현재 글자를 이어붙이자
		delete[] p;// 이전 메모리를 해제하자
		len = num;	//합한글자수
		p = tp;		//합한 글자가 있는 메모리는 여기
		
		return *this;
	}
	void show(){
		for (int i = 0; i < len; ++i)
			cout << *(p + 1)
			<< endl;
	}
};

int main()
{
	
	myString s("string은 문자열을 다루는 전문 클래스이다");
	s += ",클래스니까 나도 만들 수 있다.";
	
	myString a = s;
	s.show();		//이 함수는 문자들을 화면에 출력할 수 잇어야 함.
	a.show();

	save();
}



-----------------------------------
Mon Oct 29 13:38:31 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class myString {
	char* p;
	int len;
public:
	myString(const char* s) {
		
		len = strlen(s);	//글자수를 센다

		p = new char[len];	//메모리를 잡는다
		
		memcpy(p, s, len);	//메모리에 글자를 저장한다
	}

	myString operator +=(const myString& rhs) {
		int num = len + rhs.len;	// 새 메모리의 크기를 결정하자
		char* tp = new char[num];	// HEAP에서 메모리를 할당받자
		memcpy(tp, p, len);			// 새 메모리에 이전 글자들을 복사하자
		memcpy(tp + len, rhs.p, rhs.len);// 이전글자에 이어서 현재 글자를 이어붙이자
		delete[] p;// 이전 메모리를 해제하자
		len = num;	//합한글자수
		p = tp;		//합한 글자가 있는 메모리는 여기
		
		return *this;
	}
	void show(){
		for (int i = 0; i < len; ++i)
			cout << *(p + i)
			<< endl;
	}
};

int main()
{
	
	myString s("string은 문자열을 다루는 전문 클래스이다");
	s += ",클래스니까 나도 만들 수 있다.";
	
	myString a = s;
	s.show();		//이 함수는 문자들을 화면에 출력할 수 잇어야 함.
	a.show();

	save();
}



-----------------------------------
Mon Oct 29 13:38:49 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class myString {
	char* p;
	int len;
public:
	myString(const char* s) {
		
		len = strlen(s);	//글자수를 센다

		p = new char[len];	//메모리를 잡는다
		
		memcpy(p, s, len);	//메모리에 글자를 저장한다
	}

	myString operator +=(const myString& rhs) {
		int num = len + rhs.len;	// 새 메모리의 크기를 결정하자
		char* tp = new char[num];	// HEAP에서 메모리를 할당받자
		memcpy(tp, p, len);			// 새 메모리에 이전 글자들을 복사하자
		memcpy(tp + len, rhs.p, rhs.len);// 이전글자에 이어서 현재 글자를 이어붙이자
		delete[] p;// 이전 메모리를 해제하자
		len = num;	//합한글자수
		p = tp;		//합한 글자가 있는 메모리는 여기
		
		return *this;
	}
	void show(){
		for (int i = 0; i < len; ++i)
			cout << *(p + i);
			cout << endl;
	}
};

int main()
{
	
	myString s("string은 문자열을 다루는 전문 클래스이다");
	s += ",클래스니까 나도 만들 수 있다.";
	
	myString a = s;
	s.show();		//이 함수는 문자들을 화면에 출력할 수 잇어야 함.
	a.show();

	save();
}



-----------------------------------
Mon Oct 29 13:43:20 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class myString {
	char* p;
	int len;
public:
	myString(const char* s) {
		
		len = strlen(s);	//글자수를 센다

		p = new char[len];	//메모리를 잡는다
		
		memcpy(p, s, len);	//메모리에 글자를 저장한다
	}

	myString operator +=(const myString& rhs) {
		int num = len + rhs.len;	// 새 메모리의 크기를 결정하자
		char* tp = new char[num];	// HEAP에서 메모리를 할당받자
		memcpy(tp, p, len);			// 새 메모리에 이전 글자들을 복사하자
		memcpy(tp + len, rhs.p, rhs.len);// 이전글자에 이어서 현재 글자를 이어붙이자
		delete[] p;// 이전 메모리를 해제하자
		len = num;	//합한글자수
		p = tp;		//합한 글자가 있는 메모리는 여기
		
		return *this;
	}
	~myString(){
		delete[] p;
	}
	void show(){
		for (int i = 0; i < len; ++i)
			cout << *(p + i);
			cout << endl;
	}
};

int main()
{
	
	myString s("string은 문자열을 다루는 전문 클래스이다");
	s += ",클래스니까 나도 만들 수 있다.";
	
	myString a = s;
	s.show();		//이 함수는 문자들을 화면에 출력할 수 잇어야 함.
	a.show();

	save();
}



-----------------------------------
Mon Oct 29 13:43:36 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class myString {
	char* p;
	int len;
public:
	myString(const char* s) {
		
		len = strlen(s);	//글자수를 센다

		p = new char[len];	//메모리를 잡는다
		
		memcpy(p, s, len);	//메모리에 글자를 저장한다
	}

	myString operator +=(const myString& rhs) {
		int num = len + rhs.len;	// 새 메모리의 크기를 결정하자
		char* tp = new char[num];	// HEAP에서 메모리를 할당받자
		memcpy(tp, p, len);			// 새 메모리에 이전 글자들을 복사하자
		memcpy(tp + len, rhs.p, rhs.len);// 이전글자에 이어서 현재 글자를 이어붙이자
		delete[] p;// 이전 메모리를 해제하자
		len = num;	//합한글자수
		p = tp;		//합한 글자가 있는 메모리는 여기
		
		return *this;
	}
	~myString(){
		delete[] p;
	}
	void show(){
		for (int i = 0; i < len; ++i)
			cout << *(p + i);
			cout << endl;
	}
};

int main()
{
	
	myString s("string은 문자열을 다루는 전문 클래스이다");
	s += ",클래스니까 나도 만들 수 있다.";
	
	//myString a = s;
	s.show();		//이 함수는 문자들을 화면에 출력할 수 잇어야 함.
	//a.show();

	save();
}



-----------------------------------
Mon Oct 29 13:44:39 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class myString {
	char* p;
	int len;
public:
	myString(const char* s) {
		
		len = strlen(s);	//글자수를 센다

		p = new char[len];	//메모리를 잡는다
		
		memcpy(p, s, len);	//메모리에 글자를 저장한다
	}

	myString operator +=(const myString& rhs) {
		int num = len + rhs.len;	// 새 메모리의 크기를 결정하자
		char* tp = new char[num];	// HEAP에서 메모리를 할당받자
		memcpy(tp, p, len);			// 새 메모리에 이전 글자들을 복사하자
		memcpy(tp + len, rhs.p, rhs.len);// 이전글자에 이어서 현재 글자를 이어붙이자
		delete[] p;// 이전 메모리를 해제하자
		len = num;	//합한글자수
		p = tp;		//합한 글자가 있는 메모리는 여기
		
		return *this;
	}
	~myString(){
		delete[] p;
	}
	void show(){
		for (int i = 0; i < len; ++i)
			cout << *(p + i);
			cout << endl;
	}
};

int main()
{
	
	myString s("string은 문자열을 다루는 전문 클래스이다");
	//s += ",클래스니까 나도 만들 수 있다.";
	
	//myString a = s;
	s.show();		//이 함수는 문자들을 화면에 출력할 수 잇어야 함.
	//a.show();

	save();
}



-----------------------------------
Mon Oct 29 13:50:58 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class myString {
	char* p;
	int len;
public:
	myString(const char* s) {
		
		len = strlen(s);	//글자수를 센다

		p = new char[len];	//메모리를 잡는다
		
		memcpy(p, s, len);	//메모리에 글자를 저장한다
	}

	myString operator +=(const myString& rhs) {
		int num = len + rhs.len;	// 새 메모리의 크기를 결정하자
		char* tp = new char[num];	// HEAP에서 메모리를 할당받자
		memcpy(tp, p, len);			// 새 메모리에 이전 글자들을 복사하자
		memcpy(tp + len, rhs.p, rhs.len);// 이전글자에 이어서 현재 글자를 이어붙이자
		delete[] p;// 이전 메모리를 해제하자
		len = num;	//합한글자수
		p = tp;		//합한 글자가 있는 메모리는 여기
		
		return *this;
	}
	~myString(){
		//delete[] p;
		cout << "소멸" << endl;
	}
	void show(){
		for (int i = 0; i < len; ++i)
			cout << *(p + i);
			cout << endl;
	}
};

int main()
{
	
	myString s("string은 문자열을 다루는 전문 클래스이다");
	s += ",클래스니까 나도 만들 수 있다.";
	
	//myString a = s;
	s.show();		//이 함수는 문자들을 화면에 출력할 수 잇어야 함.
	//a.show();

	save();
}



-----------------------------------
Mon Oct 29 13:51:10 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class myString {
	char* p;
	int len;
public:
	myString(const char* s) {
		
		len = strlen(s);	//글자수를 센다

		p = new char[len];	//메모리를 잡는다
		
		memcpy(p, s, len);	//메모리에 글자를 저장한다
	}

	myString operator +=(const myString& rhs) {
		int num = len + rhs.len;	// 새 메모리의 크기를 결정하자
		char* tp = new char[num];	// HEAP에서 메모리를 할당받자
		memcpy(tp, p, len);			// 새 메모리에 이전 글자들을 복사하자
		memcpy(tp + len, rhs.p, rhs.len);// 이전글자에 이어서 현재 글자를 이어붙이자
		delete[] p;// 이전 메모리를 해제하자
		len = num;	//합한글자수
		p = tp;		//합한 글자가 있는 메모리는 여기
		
		return *this;
	}
	~myString(){
		//delete[] p;
		cout << "소멸" << endl;
	}
	void show(){
		for (int i = 0; i < len; ++i)
			cout << *(p + i);
			cout << endl;
	}
};

int main()
{
	
	myString s("string은 문자열을 다루는 전문 클래스이다");
	s += ",클래스니까 나도 만들 수 있다.";
	
	//myString a = s;
	s.show();		//이 함수는 문자들을 화면에 출력할 수 잇어야 함.
	//a.show();

	save();
}



-----------------------------------
Mon Oct 29 13:54:23 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class myString {
	char* p;
	int len;
public:
	myString(const char* s) {
		
		len = strlen(s);	//글자수를 센다

		p = new char[len];	//메모리를 잡는다
		
		memcpy(p, s, len);	//메모리에 글자를 저장한다
		cout << "생성" << endl;
	}

	myString operator +=(const myString& rhs) {
		int num = len + rhs.len;	// 새 메모리의 크기를 결정하자
		char* tp = new char[num];	// HEAP에서 메모리를 할당받자
		memcpy(tp, p, len);			// 새 메모리에 이전 글자들을 복사하자
		memcpy(tp + len, rhs.p, rhs.len);// 이전글자에 이어서 현재 글자를 이어붙이자
		delete[] p;// 이전 메모리를 해제하자
		len = num;	//합한글자수
		p = tp;		//합한 글자가 있는 메모리는 여기
		
		return *this;
	}
	~myString(){
		cout << "소멸" << endl;
		//delete[] p;
	}
	void show(){
		for (int i = 0; i < len; ++i)
			cout << *(p + i);
			cout << endl;
	}
};

int main()
{
	
	myString s("string은 문자열을 다루는 전문 클래스이다");
	s += ",클래스니까 나도 만들 수 있다.";
	
	//myString a = s;
	s.show();		//이 함수는 문자들을 화면에 출력할 수 잇어야 함.
	//a.show();

	save();
}



-----------------------------------
Mon Oct 29 13:56:00 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class myString {
	char* p;
	int len;
public:
	myString(const char* s) {
		
		len = strlen(s);	//글자수를 센다

		p = new char[len];	//메모리를 잡는다
		
		memcpy(p, s, len);	//메모리에 글자를 저장한다
		cout << "생성" << endl;
	}

	myString operator +=(const myString& rhs) {
		int num = len + rhs.len;	// 새 메모리의 크기를 결정하자
		cout << "1" << endl;
		char* tp = new char[num];	// HEAP에서 메모리를 할당받자
		cout << "2" << endl;
		memcpy(tp, p, len);			// 새 메모리에 이전 글자들을 복사하자
		cout << "3" << endl;
		memcpy(tp + len, rhs.p, rhs.len);// 이전글자에 이어서 현재 글자를 이어붙이자
		cout << "4" << endl;
		delete[] p;// 이전 메모리를 해제하자
		cout << "5" << endl;
		len = num;	//합한글자수
		cout << "6" << endl;
		p = tp;		//합한 글자가 있는 메모리는 여기
		cout << "7" << endl;
		
		return *this;
	}
	~myString(){
		cout << "소멸" << endl;
		//delete[] p;
	}
	void show(){
		for (int i = 0; i < len; ++i)
			cout << *(p + i);
			cout << endl;
	}
};

int main()
{
	
	myString s("string은 문자열을 다루는 전문 클래스이다");
	s += ",클래스니까 나도 만들 수 있다.";
	
	//myString a = s;
	s.show();		//이 함수는 문자들을 화면에 출력할 수 잇어야 함.
	//a.show();

	save();
}



-----------------------------------
Mon Oct 29 13:58:36 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class myString {
	char* p;
	int len;
public:
	myString(const char* s) {
		
		len = strlen(s);	//글자수를 센다

		p = new char[len];	//메모리를 잡는다
		
		memcpy(p, s, len);	//메모리에 글자를 저장한다
		
	}
	myString& operator +=(const myString& rhs) {
		int num = len + rhs.len;	// 새 메모리의 크기를 결정하자
		char* tp = new char[num];	// HEAP에서 메모리를 할당받자
		memcpy(tp, p, len);			// 새 메모리에 이전 글자들을 복사하자
		memcpy(tp + len, rhs.p, rhs.len);// 이전글자에 이어서 현재 글자를 이어붙이자
		delete[] p;// 이전 메모리를 해제하자
		len = num;	//합한글자수
		p = tp;		//합한 글자가 있는 메모리는 여기
		return *this;
	}
	~myString(){
		delete[] p;
	}
	void show(){
		for (int i = 0; i < len; ++i)
			cout << *(p + i);
			cout << endl;
	}
};

int main()
{
	
	myString s("string은 문자열을 다루는 전문 클래스이다");
	s += ",클래스니까 나도 만들 수 있다.";
	
	//myString a = s;
	s.show();		//이 함수는 문자들을 화면에 출력할 수 잇어야 함.
	//a.show();

	save();
}



-----------------------------------
Mon Oct 29 14:03:09 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class myString {
	char* p;
	int len;
public:
	myString(const char* s) {
		
		len = strlen(s);	//글자수를 센다

		p = new char[len];	//메모리를 잡는다
		
		memcpy(p, s, len);	//메모리에 글자를 저장한다
		
	}
	myString(const myString& other) : len(other.len) {
		p = new char[len];

		
		memcpy(p, other.p, len);	//깊은복사
	}
	myString& operator +=(const myString& rhs) {
		int num = len + rhs.len;	// 새 메모리의 크기를 결정하자
		char* tp = new char[num];	// HEAP에서 메모리를 할당받자
		memcpy(tp, p, len);			// 새 메모리에 이전 글자들을 복사하자
		memcpy(tp + len, rhs.p, rhs.len);// 이전글자에 이어서 현재 글자를 이어붙이자
		delete[] p;// 이전 메모리를 해제하자
		len = num;	//합한글자수
		p = tp;		//합한 글자가 있는 메모리는 여기
		return *this;
	}
	~myString(){
		delete[] p;
	}
	void show(){
		for (int i = 0; i < len; ++i)
			cout << *(p + i);
			cout << endl;
	}
};

int main()
{
	
	myString s("string은 문자열을 다루는 전문 클래스이다");
	s += ",클래스니까 나도 만들 수 있다.";
	
	//myString a = s;
	s.show();		//이 함수는 문자들을 화면에 출력할 수 잇어야 함.
	//a.show();

	save();
}



-----------------------------------
Mon Oct 29 14:03:25 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.11		         월목     (9주 1일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class myString {
	char* p;
	int len;
public:
	myString(const char* s) {
		
		len = strlen(s);	//글자수를 센다

		p = new char[len];	//메모리를 잡는다
		
		memcpy(p, s, len);	//메모리에 글자를 저장한다
		
	}
	myString(const myString& other) : len(other.len) {
		p = new char[len];

		
		memcpy(p, other.p, len);	//깊은복사
	}
	myString operator +=(const myString& rhs) {
		int num = len + rhs.len;	// 새 메모리의 크기를 결정하자
		char* tp = new char[num];	// HEAP에서 메모리를 할당받자
		memcpy(tp, p, len);			// 새 메모리에 이전 글자들을 복사하자
		memcpy(tp + len, rhs.p, rhs.len);// 이전글자에 이어서 현재 글자를 이어붙이자
		delete[] p;// 이전 메모리를 해제하자
		len = num;	//합한글자수
		p = tp;		//합한 글자가 있는 메모리는 여기
		return *this;
	}
	~myString(){
		delete[] p;
	}
	void show(){
		for (int i = 0; i < len; ++i)
			cout << *(p + i);
			cout << endl;
	}
};

int main()
{
	
	myString s("string은 문자열을 다루는 전문 클래스이다");
	s += ",클래스니까 나도 만들 수 있다.";
	
	myString a = s;
	s.show();		//이 함수는 문자들을 화면에 출력할 수 잇어야 함.
	a.show();

	save();
}



-----------------------------------
Mon Oct 29 14:51:49 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.29		         월목     (9주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <fstream>
#include <string>
#include "save.h"
using namespace std;

class myString {
	char* p;
	int len;
public:
	myString(const char* s) {
		
		len = strlen(s);	//글자수를 센다

		p = new char[len];	//메모리를 잡는다
		
		memcpy(p, s, len);	//메모리에 글자를 저장한다
		
	}
	myString(const myString& other) : len(other.len) {
		p = new char[len];

		
		memcpy(p, other.p, len);	//깊은복사
	}
	myString operator +=(const myString& rhs) {
		int num = len + rhs.len;	// 새 메모리의 크기를 결정하자
		char* tp = new char[num];	// HEAP에서 메모리를 할당받자
		memcpy(tp, p, len);			// 새 메모리에 이전 글자들을 복사하자
		memcpy(tp + len, rhs.p, rhs.len);// 이전글자에 이어서 현재 글자를 이어붙이자
		delete[] p;// 이전 메모리를 해제하자
		len = num;	//합한글자수
		p = tp;		//합한 글자가 있는 메모리는 여기
		return *this;
	}
	myString operator <<(const myString& rhs) {

	}
	~myString(){
		delete[] p;
	}
	void show(){
		for (int i = 0; i < len; ++i)
			cout << *(p + i);
			cout << endl;
	}
	friend ostream& operator<<(ostream&, const myString&);
};


ostream& operator<<(ostream& os, const myString& s)
{
	char* p = new char[s.len +1];
	memcpy(p, s.p, s.len);
	*(p + s.len) = 0;
	os << p;
	delete[] p;

	return os;
}


int main()
{
	
	myString s="2018";
	s += "10월 29일";
	cout << s << endl;

	ofstream out("출력연산자오버로딩.txt");
	for (int i = 0; i < 10000; ++i)
		out << s << i + 1 << endl;
	save();
}



-----------------------------------
Mon Oct 29 15:14:11 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.10.29		         월목     (9주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 사용자 정의 자료형(class)
 1.class란?
 2.객체의 생성/소멸/복사/이동
	생성 -	객체를 프로그래머가 생성할 수는 없다.
			그러나 생성 후 원하는 동작을 프로그램할 수는 있다.
	소멸 -	객체를 프로그래머가 소멸할 수는 없다.
			그러나 소멸 전 원하는 동작을 프로그램할 수는 있다.
 3.연산자 오버로딩(11장)
 4.class간의 관계 - 상속 (6장)

 -----------------------------------------------
*/
#include <iostream>
#include <fstream>
#include <random>
#include <string>
#include "save.h"
using namespace std;
default_random_engine dre;
uniform_int_distribution<> uid(1, 15);

int ID = 1;
class Dog {
	int id;		//처음 Dog = 1, 다음 2.....
	int age;	//1~15 사이 랜덤
public:
	Dog() {
		id = ID++;
		age = uid(dre);
	}
	void setId(int n) {
		id = n;
	}
	void setAge(int a) {
		age = a;
	}
	int getAge() {
		return age;
	}
	friend ostream& operator<<(ostream&, const Dog&);
};
//ostream& operator<<(ostream& os, const Dog& d) {
//	char* p = new char[];
//	os << "ID - " << d.id << "\t나이 - " << d.age;
//}
int comp( Dog* p, Dog* q) {
	return p->getAge() - q->getAge();
}
int main()
{
	{
		Dog* dogs = new Dog[1000];
		ofstream out("개 1000마리.txt");
		//for (int i = 0; i < 1000; ++i)
		//	out << Dog[i] << endl;
		//qsort(dogs,1000,sizeof(Dog) , comp);
		delete dogs;
	}
	//[문제] 파일에서 1000마리 Dog를 읽어 나이 순으로 정렬 후 화면에 출력
	
	save();
}



-----------------------------------
Mon Nov  5 14:08:44 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.5	         월목     (10주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
----------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;



int main()
{
	string a;	//STACK 28바이트(24바이트)
	string b = "표준의 string 클래스 입니다.";
	a = b;		// copy assignment operator

	cout << a << endl;
	cout << b << endl;

	save();
}



-----------------------------------
Mon Nov  5 14:16:36 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.5	         월목     (10주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
----------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;



int main()
{
	string a;	//STACK 28바이트(24바이트)
	string b = "표준의 string 클래스 입니다.";
	a = move(b);		// copy assignment operator

	cout << a << endl;
	cout << b << endl;

	save();
}



-----------------------------------
Mon Nov  5 14:16:50 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.5	         월목     (10주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
----------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;



int main()
{
	string a;	//STACK 28바이트(24바이트)
	string b = "표준의 string 클래스 입니다.";
	a = move(b);		// copy assignment operator

	cout << a << endl;
	cout << b << endl;

	save();
}



-----------------------------------
Mon Nov  5 14:17:00 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.5	         월목     (10주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
----------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;



int main()
{
	string a;	//STACK 28바이트(24바이트)
	string b = "표준의 string 클래스 입니다.";
	a = move(b);		// copy assignment operator

	cout << a << endl;
	cout << b << endl;

	save();
}



-----------------------------------
Mon Nov  5 14:17:25 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.5	         월목     (10주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
----------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;



int main()
{
	string a;	//STACK 28바이트(24바이트)
	string b = "표준의 string 클래스 입니다.";
	a = move(b);		// copy assignment operator

	cout << ":" << a << endl;
	cout << ":" << b << endl;

	save();
}



-----------------------------------
Mon Nov  5 14:18:13 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.5	         월목     (10주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
----------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;



int main()
{
	string a;	//STACK 28바이트(24바이트)
	string b = "표준의 string 클래스 입니다.";
	a = (string&&)b;		// copy assignment operator

	cout << ":" << a << endl;
	cout << ":" << b << endl;

	save();
}



-----------------------------------
Mon Nov  5 14:37:10 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.5	         월목     (10주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
----------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;



int main()
{
	string a;	//STACK 28바이트(24바이트)
	string b = "표준의 string 클래스 입니다.";
	(string)a = (string&&)b;		// copy assignment operator

	cout << ":" << a << endl;
	cout << ":" << b << endl;

	save();
}



-----------------------------------
Mon Nov  5 14:45:38 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.5	         월목     (10주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
----------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;



int main()
{
//	string a;	//STACK 28바이트(24바이트)
//	string b = "표준의 string 클래스 입니다.";
//	a = (string&&)b;		// copy assignment operator		p302쪽
//	
	string a;
	cout << ":" << a << endl;
	//cout << ":" << b << endl;

	save();
}



-----------------------------------
Mon Nov  5 14:47:34 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.5	         월목     (10주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
----------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;



int main()
{
	string a;	//STACK 28바이트(24바이트)
	string b = "표준의 string 클래스 입니다.";
	a = (string&&)b;		// copy assignment operator		p295 쪽 ~

	
	cout << ":" << a << endl;
	cout << ":" << b << endl;

	save();
}



-----------------------------------
Mon Nov  5 14:49:48 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.5	         월목     (10주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
----------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;



int main()
{
	int a = 20;

	a = 5;	//prvalue

	save();
}



-----------------------------------
Mon Nov  5 14:51:42 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.5	         월목     (10주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
----------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;



int main()
{
	string a;	//STACK 28바이트(24바이트)
	string b = "표준의 string 클래스 입니다.";
	a = (string&&)b;		// copy assignment operator		p295 쪽 ~


	cout << ":" << a << endl;
	cout << ":" << b.c_str() << endl;

	save();
}



-----------------------------------
Mon Nov  5 15:17:30 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.5	         월목     (10주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template

 class 정리 : ★★★★★
 if(생성자에서 자원을 할당했다면 - new)
	1. 소멸자함수를 프로그램 한다.(자원을 해제)
	2. 복사생성자를 프로그램 한다.(copy constructor)
	3. 복사할당연산자를 프로그램한다.(copy assignment)
	----이동연산을 지원하는 클래스로 만들고 싶다면----
	4. 이동생성자를 프로그램한다.(move constructor)
	5. 이동할당연산자(move assignment operator)
 else
	아무것도 프로그램하지 않아도 된다.(디폴트로 만들어 지니까)
 ----------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class myString {
	int len = 0;
	char* p = nullptr;
public:
	myString() = default;
	myString(const char* s) {
		len = strlen(s);
		p = new char[len];
		memcpy(p, s, len);
	}
	~myString(){
		delete[] p;
	}

	// 이 연산자는 둘 다 생성된 이후 오른편이 확보한 자원을
	// 외편에게 양도하는 경우에 호출된다.
	void operator=(myString&& other) {
		//나를 나에게 이동하면 안되겠다.
		if (this == &other) {
			return;
		}
		delete[] p;// 내가 확보한 메모리를 지운다.
		len = other.len;
		p = other.p;// other의 메모리를 가져온다.
		other.p = nullptr;// other의 자원을 가리키는 포인터를 정리한다.
		other.len = 0;
	}
	friend ostream& operator<<(ostream&, const myString&);
};
ostream& operator<<(ostream& os, const myString& ms){
	char* p = new char[ms.len + 1];
	memcpy(p, ms.p, ms.len);
	*(p + ms.len) = 0;
	os << p;
	delete p;
	return os;
}
int main()
{
	myString a;	
	myString b = ("표준의 string 클래스 입니다.");
	a = move(b);	//a.operator=(myString&&)

	cout << "a :" << a << endl;
	cout << "b :" << b << endl;

	save();
}



-----------------------------------
Thu Nov  8 09:44:12 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.5	         월목     (10주 2일)

 11.1 - 시험!!!!


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template

 class 정리 : ★★★★★
 if(생성자에서 자원을 할당했다면 - new)
	1. 소멸자함수를 프로그램 한다.(자원을 해제)
	2. 복사생성자를 프로그램 한다.(copy constructor)
	3. 복사할당연산자를 프로그램한다.(copy assignment)
	----이동연산을 지원하는 클래스로 만들고 싶다면----
	4. 이동생성자를 프로그램한다.(move constructor)
	5. 이동할당연산자(move assignment operator)
 else
	아무것도 프로그램하지 않아도 된다.(디폴트로 만들어 지니까)
 ----------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class myString {
	int len = 0;
	char* p = nullptr;
public:
	myString() = default;
	myString(const char* s) {
		len = strlen(s);
		p = new char[len];
		memcpy(p, s, len);
	}
	myString(myString&& other) {
		//other가 할당한 자원을 넘겨받아 나를 생성한다.
		len = other.len;
		p = other.p;
		//원본인 other의 내용을 잘 정리해두자.
		other.len = 0;
		other.p = nullptr;	//other의 자원을 가리키는 포인터를 가르킨다.
		cout << "이동 생성자" << endl;
	}
	~myString(){
		delete[] p;
	}

	// 이 연산자는 둘 다 생성된 이후 오른편이 확보한 자원을
	// 외편에게 양도하는 경우에 호출된다.
	myString& operator=(myString&& other) {
		//나를 나에게 이동하면 안되겠다.
		if (this == &other) {
			return *this;
		}
		delete[] p;// 내가 확보한 메모리를 지운다.
		len = other.len;
		p = other.p;// other의 메모리를 가져온다.
		other.p = nullptr;// other의 자원을 가리키는 포인터를 정리한다.
		other.len = 0;
	}
	friend ostream& operator<<(ostream&, const myString&);
};
ostream& operator<<(ostream& os, const myString& ms){
	char* p = new char[ms.len + 1];
	memcpy(p, ms.p, ms.len);
	*(p + ms.len) = 0;
	os << p;
	delete p;
	return os;
}
int main()
{
	myString a;	
	myString b = ("표준의 string 클래스 입니다.");
	a = move(b);	// b를 이동하여 a를 생성

	cout << "a :" << a << endl;
	cout << "b :" << b << endl;
	
	

	save();
}



-----------------------------------
Thu Nov  8 10:39:45 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template

 class 정리 : ★★★★★
 if(생성자에서 자원을 할당했다면 - new)
	1. 소멸자함수를 프로그램 한다.(자원을 해제)
	2. 복사생성자를 프로그램 한다.(copy constructor)
	3. 복사할당연산자를 프로그램한다.(copy assignment)
	----이동연산을 지원하는 클래스로 만들고 싶다면----
	4. 이동생성자를 프로그램한다.(move constructor)
	5. 이동할당연산자(move assignment operator)
 else
	아무것도 프로그램하지 않아도 된다.(디폴트로 만들어 지니까)
 ----------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
// 배열(Array) - 동일한 자료를 여러개 담을 수 있는
//				자료구조(Data Structor)
//			-->	메모리가 붙어있다(연속),크기가 변경될 수 없다.
//				프로그램 실행전에 크기가 결정된다.
//			--> Safe Array 경계를 검사하여 잘못된 인덱스로 접근하는 시도에 적절한 대처하자.

class SafeIntArray {
	int num;
	int* p;
public:
	SafeIntArray(int n) : num(n){
		num = n;
		p = new int[num];
	}
	SafeIntArray(const SafeIntArray& other) {
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
	}
	SafeIntArray() {

	}
	~SafeIntArray() { delete[] p; }

	SafeIntArray& operator=(const SafeIntArray& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
		 
		return *this;
	}
	
	int& operator[](int idx) const {
		return p[idx];
	}
	size_t size() const{
		return num;
	}
};


int main()
{
	SafeIntArray a(10);		//정수 10개가 들어갈 공간 확보

	for (int i = 0; i < a.size(); ++i) {	//size()멤버는 갯수를 반환한다.
		a[i] = i;
	}
	cout << a[-1] << endl;	//잘못되었다 -> 어떻게 할까

	for (int i = 0; i < a.size(); ++i) {
		cout << a[i] << endl;
	}

	save();
}



-----------------------------------
Thu Nov  8 10:40:35 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template

 class 정리 : ★★★★★
 if(생성자에서 자원을 할당했다면 - new)
	1. 소멸자함수를 프로그램 한다.(자원을 해제)
	2. 복사생성자를 프로그램 한다.(copy constructor)
	3. 복사할당연산자를 프로그램한다.(copy assignment)
	----이동연산을 지원하는 클래스로 만들고 싶다면----
	4. 이동생성자를 프로그램한다.(move constructor)
	5. 이동할당연산자(move assignment operator)
 else
	아무것도 프로그램하지 않아도 된다.(디폴트로 만들어 지니까)
 ----------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
// 배열(Array) - 동일한 자료를 여러개 담을 수 있는
//				자료구조(Data Structor)
//			-->	메모리가 붙어있다(연속),크기가 변경될 수 없다.
//				프로그램 실행전에 크기가 결정된다.
//			--> Safe Array 경계를 검사하여 잘못된 인덱스로 접근하는 시도에 적절한 대처하자.

class SafeIntArray {
	int num;
	int* p;
public:
	SafeIntArray(int n) : num(n){
		num = n;
		p = new int[num];
	}
	SafeIntArray(const SafeIntArray& other) {
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
	}
	~SafeIntArray() { delete[] p; }

	SafeIntArray& operator=(const SafeIntArray& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
		 
		return *this;
	}
	
	int& operator[](int idx) const {
		return p[idx];
	}
	size_t size() const{
		return num;
	}
};


int main()
{
	SafeIntArray a(10);		//정수 10개가 들어갈 공간 확보

	for (int i = 0; i < a.size(); ++i) {	//size()멤버는 갯수를 반환한다.
		a[i] = i;
	}
	cout << a[-1] << endl;	//잘못되었다 -> 어떻게 할까

	for (int i = 0; i < a.size(); ++i) {
		cout << a[i] << endl;
	}

	save();
}



-----------------------------------
Thu Nov  8 10:41:30 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template

 class 정리 : ★★★★★
 if(생성자에서 자원을 할당했다면 - new)
	1. 소멸자함수를 프로그램 한다.(자원을 해제)
	2. 복사생성자를 프로그램 한다.(copy constructor)
	3. 복사할당연산자를 프로그램한다.(copy assignment)
	----이동연산을 지원하는 클래스로 만들고 싶다면----
	4. 이동생성자를 프로그램한다.(move constructor)
	5. 이동할당연산자(move assignment operator)
 else
	아무것도 프로그램하지 않아도 된다.(디폴트로 만들어 지니까)
 ----------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
// 배열(Array) - 동일한 자료를 여러개 담을 수 있는
//				자료구조(Data Structor)
//			-->	메모리가 붙어있다(연속),크기가 변경될 수 없다.
//				프로그램 실행전에 크기가 결정된다.
//			--> Safe Array 경계를 검사하여 잘못된 인덱스로 접근하는 시도에 적절한 대처하자.

class SafeIntArray {
	int num;
	int* p;
public:
	SafeIntArray(int n) : num(n){
		num = n;
		p = new int[num];
	}
	SafeIntArray(const SafeIntArray& other) {
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
	}
	~SafeIntArray() { delete[] p; }

	SafeIntArray& operator=(const SafeIntArray& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
		cout << "yo" << endl;
		return *this;
	}
	
	int& operator[](int idx) const {
		return p[idx];
	}
	size_t size() const{
		return num;
	}
};


int main()
{
	SafeIntArray a(10);		//정수 10개가 들어갈 공간 확보

	for (int i = 0; i < a.size(); ++i) {	//size()멤버는 갯수를 반환한다.
		a[i] = i;
	}
	cout << a[-1] << endl;	//잘못되었다 -> 어떻게 할까

	for (int i = 0; i < a.size(); ++i) {
		cout << a[i] << endl;
	}

	save();
}



-----------------------------------
Thu Nov  8 10:42:04 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template

 class 정리 : ★★★★★
 if(생성자에서 자원을 할당했다면 - new)
	1. 소멸자함수를 프로그램 한다.(자원을 해제)
	2. 복사생성자를 프로그램 한다.(copy constructor)
	3. 복사할당연산자를 프로그램한다.(copy assignment)
	----이동연산을 지원하는 클래스로 만들고 싶다면----
	4. 이동생성자를 프로그램한다.(move constructor)
	5. 이동할당연산자(move assignment operator)
 else
	아무것도 프로그램하지 않아도 된다.(디폴트로 만들어 지니까)
 ----------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
// 배열(Array) - 동일한 자료를 여러개 담을 수 있는
//				자료구조(Data Structor)
//			-->	메모리가 붙어있다(연속),크기가 변경될 수 없다.
//				프로그램 실행전에 크기가 결정된다.
//			--> Safe Array 경계를 검사하여 잘못된 인덱스로 접근하는 시도에 적절한 대처하자.

class SafeIntArray {
	int num;
	int* p;
public:
	SafeIntArray(int n) : num(n){
		num = n;
		p = new int[num];
	}
	SafeIntArray(const SafeIntArray& other) {
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
		cout << " yo" << endl;
	}
	~SafeIntArray() { delete[] p; }

	SafeIntArray& operator=(const SafeIntArray& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
		return *this;
	}
	
	int& operator[](int idx) const {
		return p[idx];
	}
	size_t size() const{
		return num;
	}
};


int main()
{
	SafeIntArray a(10);		//정수 10개가 들어갈 공간 확보

	for (int i = 0; i < a.size(); ++i) {	//size()멤버는 갯수를 반환한다.
		a[i] = i;
	}
	cout << a[-1] << endl;	//잘못되었다 -> 어떻게 할까

	for (int i = 0; i < a.size(); ++i) {
		cout << a[i] << endl;
	}

	save();
}



-----------------------------------
Thu Nov  8 10:55:12 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template

 class 정리 : ★★★★★
 if(생성자에서 자원을 할당했다면 - new)
	1. 소멸자함수를 프로그램 한다.(자원을 해제)
	2. 복사생성자를 프로그램 한다.(copy constructor)
	3. 복사할당연산자를 프로그램한다.(copy assignment)
	----이동연산을 지원하는 클래스로 만들고 싶다면----
	4. 이동생성자를 프로그램한다.(move constructor)
	5. 이동할당연산자(move assignment operator)
 else
	아무것도 프로그램하지 않아도 된다.(디폴트로 만들어 지니까)
 ----------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
// 배열(Array) - 동일한 자료를 여러개 담을 수 있는
//				자료구조(Data Structor)
//			-->	메모리가 붙어있다(연속),크기가 변경될 수 없다.
//				프로그램 실행전에 크기가 결정된다.
//			--> Safe Array 경계를 검사하여 잘못된 인덱스로 접근하는 시도에 적절한 대처하자.

class SafeIntArray {
	int num;
	int* p;
public:
	SafeIntArray(int n) : num(n){
		num = n;
		p = new int[num];
	}
	SafeIntArray(const SafeIntArray& other) {
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
	}
	~SafeIntArray() { delete[] p; }

	SafeIntArray& operator=(const SafeIntArray& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
		return *this;
	}
	
	int& operator[](int idx) const {
		if (0 <= idx && idx < num)
			return p[idx];
		else 
			throw 1;
		
	}
	size_t size() const{
		return num;
	}
};


int main()
{
	SafeIntArray a(10);		//정수 10개가 들어갈 공간 확보

	for (int i = 0; i < a.size(); ++i) {	//size()멤버는 갯수를 반환한다.
		a[i] = i;
	}
	try {
		cout << a[-1] << endl;	//잘못되었다 -> 어떻게 할까
	}
	catch ( ... ) {
		cout << "잘못되었습니다." << endl;
	}
	for (int i = 0; i < a.size(); ++i) {
		cout << a[i] << endl;
	}

	save();
}



-----------------------------------
Thu Nov  8 10:57:04 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template

 class 정리 : ★★★★★
 if(생성자에서 자원을 할당했다면 - new)
	1. 소멸자함수를 프로그램 한다.(자원을 해제)
	2. 복사생성자를 프로그램 한다.(copy constructor)
	3. 복사할당연산자를 프로그램한다.(copy assignment)
	----이동연산을 지원하는 클래스로 만들고 싶다면----
	4. 이동생성자를 프로그램한다.(move constructor)
	5. 이동할당연산자(move assignment operator)
 else
	아무것도 프로그램하지 않아도 된다.(디폴트로 만들어 지니까)
 ----------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
// 배열(Array) - 동일한 자료를 여러개 담을 수 있는
//				자료구조(Data Structor)
//			-->	메모리가 붙어있다(연속),크기가 변경될 수 없다.
//				프로그램 실행전에 크기가 결정된다.
//			--> Safe Array 경계를 검사하여 잘못된 인덱스로 접근하는 시도에 적절한 대처하자.

class SafeIntArray {
	int num;
	int* p;
public:
	SafeIntArray(int n) : num(n){
		num = n;
		p = new int[num];
	}
	SafeIntArray(const SafeIntArray& other) {
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
	}
	~SafeIntArray() { delete[] p; }

	SafeIntArray& operator=(const SafeIntArray& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
		return *this;
	}
	
	int& operator[](int idx) const {
		if (0 <= idx && idx < num)
			return p[idx];
		else 
			throw 1;
		
	}
	size_t size() const{
		return num;
	}
};


int main()
{
	SafeIntArray a(10);		//정수 10개가 들어갈 공간 확보

	for (int i = 0; i < a.size(); ++i) {	//size()멤버는 갯수를 반환한다.
		a[i] = i;
	}
	try {
		cout << a[-1] << endl;	//잘못되었다 -> 어떻게 할까
	}
	catch ( ... ) {	//모든 예외를 받음
		cout << "잘못되었습니다." << endl;
	}
	for (int i = 0; i < a.size(); ++i) {
		cout << a[i] << endl;
	}

	save();
}



-----------------------------------
Thu Nov  8 11:05:18 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template

 class 정리 : ★★★★★
 if(생성자에서 자원을 할당했다면 - new)
	1. 소멸자함수를 프로그램 한다.(자원을 해제)
	2. 복사생성자를 프로그램 한다.(copy constructor)
	3. 복사할당연산자를 프로그램한다.(copy assignment)
	----이동연산을 지원하는 클래스로 만들고 싶다면----
	4. 이동생성자를 프로그램한다.(move constructor)
	5. 이동할당연산자(move assignment operator)
 else
	아무것도 프로그램하지 않아도 된다.(디폴트로 만들어 지니까)
 ----------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
// 배열(Array) - 동일한 자료를 여러개 담을 수 있는
//				자료구조(Data Structor)
//			-->	메모리가 붙어있다(연속),크기가 변경될 수 없다.
//				프로그램 실행전에 크기가 결정된다.
//			--> Safe Array 경계를 검사하여 잘못된 인덱스로 접근하는 시도에 적절한 대처하자.

class SafeIntArray {
	int num;
	int* p;
public:
	SafeIntArray(int n) : num(n){
		num = n;
		p = new int[num];
	}
	SafeIntArray(const SafeIntArray& other) {
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
	}
	~SafeIntArray() { delete[] p; }

	SafeIntArray& operator=(const SafeIntArray& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
		return *this;
	}
	int& operator[](int idx) const {
			return p[idx];
	}
	size_t size() const{
		return num;
	}
	int* begin() {
		return p;
	}
	int* end() {
		return p+num;
	}
};


int main()
{
	SafeIntArray a(10);		//정수 10개가 들어갈 공간 확보

	for (int i = 0; i < a.size(); ++i) {	//size()멤버는 갯수를 반환한다.
		a[i] = i;
	}
	
	for (int d : a) {
		cout << d << endl;
	}

	save();
}



-----------------------------------
Thu Nov  8 11:05:53 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template

 class 정리 : ★★★★★
 if(생성자에서 자원을 할당했다면 - new)
	1. 소멸자함수를 프로그램 한다.(자원을 해제)
	2. 복사생성자를 프로그램 한다.(copy constructor)
	3. 복사할당연산자를 프로그램한다.(copy assignment)
	----이동연산을 지원하는 클래스로 만들고 싶다면----
	4. 이동생성자를 프로그램한다.(move constructor)
	5. 이동할당연산자(move assignment operator)
 else
	아무것도 프로그램하지 않아도 된다.(디폴트로 만들어 지니까)
 ----------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
// 배열(Array) - 동일한 자료를 여러개 담을 수 있는
//				자료구조(Data Structor)
//			-->	메모리가 붙어있다(연속),크기가 변경될 수 없다.
//				프로그램 실행전에 크기가 결정된다.
//			--> Safe Array 경계를 검사하여 잘못된 인덱스로 접근하는 시도에 적절한 대처하자.

class SafeIntArray {
	int num;
	int* p;
public:
	SafeIntArray(int n) : num(n){
		num = n;
		p = new int[num];
	}
	SafeIntArray(const SafeIntArray& other) {
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
	}
	~SafeIntArray() { delete[] p; }

	SafeIntArray& operator=(const SafeIntArray& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
		return *this;
	}
	int& operator[](int idx) const {
			return p[idx];
	}
	size_t size() const{
		return num;
	}
	int* begin() {
		return p;
	}
	int* end() {
		return p+num;
	}
};


int main()
{
	SafeIntArray a(10);		//정수 10개가 들어갈 공간 확보

	for (int d : a) {	//size()멤버는 갯수를 반환한다.
		d = d;
	}
	
	for (int d : a) {
		cout << d << endl;
	}

	save();
}



-----------------------------------
Thu Nov  8 11:07:01 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template

 class 정리 : ★★★★★
 if(생성자에서 자원을 할당했다면 - new)
	1. 소멸자함수를 프로그램 한다.(자원을 해제)
	2. 복사생성자를 프로그램 한다.(copy constructor)
	3. 복사할당연산자를 프로그램한다.(copy assignment)
	----이동연산을 지원하는 클래스로 만들고 싶다면----
	4. 이동생성자를 프로그램한다.(move constructor)
	5. 이동할당연산자(move assignment operator)
 else
	아무것도 프로그램하지 않아도 된다.(디폴트로 만들어 지니까)
 ----------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
// 배열(Array) - 동일한 자료를 여러개 담을 수 있는
//				자료구조(Data Structor)
//			-->	메모리가 붙어있다(연속),크기가 변경될 수 없다.
//				프로그램 실행전에 크기가 결정된다.
//			--> Safe Array 경계를 검사하여 잘못된 인덱스로 접근하는 시도에 적절한 대처하자.

class SafeIntArray {
	int num;
	int* p;
public:
	SafeIntArray(int n) : num(n){
		num = n;
		p = new int[num];
	}
	SafeIntArray(const SafeIntArray& other) {
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
	}
	~SafeIntArray() { delete[] p; }

	SafeIntArray& operator=(const SafeIntArray& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
		return *this;
	}
	int& operator[](int idx) const {
			return p[idx];
	}
	size_t size() const{
		return num;
	}
	int* begin() {
		return p;
	}
	int* end() {
		return p+num;
	}
};


int main()
{
	SafeIntArray a(10);		//정수 10개가 들어갈 공간 확보
	int i = 0;
	for (int& d : a) {	//size()멤버는 갯수를 반환한다.
		d = i++;
	}
	
	for (int d : a) {
		cout << d << endl;
	}

	save();
}



-----------------------------------
Thu Nov  8 11:10:37 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template

 class 정리 : ★★★★★
 if(생성자에서 자원을 할당했다면 - new)
	1. 소멸자함수를 프로그램 한다.(자원을 해제)
	2. 복사생성자를 프로그램 한다.(copy constructor)
	3. 복사할당연산자를 프로그램한다.(copy assignment)
	----이동연산을 지원하는 클래스로 만들고 싶다면----
	4. 이동생성자를 프로그램한다.(move constructor)
	5. 이동할당연산자(move assignment operator)
 else
	아무것도 프로그램하지 않아도 된다.(디폴트로 만들어 지니까)
 ----------------------------------
*/
#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;
// 배열(Array) - 동일한 자료를 여러개 담을 수 있는
//				자료구조(Data Structor)
//			-->	메모리가 붙어있다(연속),크기가 변경될 수 없다.
//				프로그램 실행전에 크기가 결정된다.
//			--> Safe Array 경계를 검사하여 잘못된 인덱스로 접근하는 시도에 적절한 대처하자.

class SafeIntArray {
	int num;
	int* p;
public:
	SafeIntArray(int n) : num(n){
		num = n;
		p = new int[num];
	}
	SafeIntArray(const SafeIntArray& other) {
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
	}
	~SafeIntArray() { delete[] p; }

	SafeIntArray& operator=(const SafeIntArray& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
		return *this;
	}
	int& operator[](int idx) const {
			return p[idx];
	}
	size_t size() const{
		return num;
	}
	int* begin() {
		return p;
	}
	int* end() {
		return p+num;
	}
};


int main()
{
	SafeIntArray a(10000);		//정수 10개가 들어갈 공간 확보
	
	uniform_int_distribution<> uid(0, 100000);
	default_random_engine dre;

	for (int& d : a)
		d = uid(dre);
	for (int d : a)
		cout << d << '\t';
	cout << endl;
	save();
}



-----------------------------------
Thu Nov  8 11:11:11 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template

 class 정리 : ★★★★★
 if(생성자에서 자원을 할당했다면 - new)
	1. 소멸자함수를 프로그램 한다.(자원을 해제)
	2. 복사생성자를 프로그램 한다.(copy constructor)
	3. 복사할당연산자를 프로그램한다.(copy assignment)
	----이동연산을 지원하는 클래스로 만들고 싶다면----
	4. 이동생성자를 프로그램한다.(move constructor)
	5. 이동할당연산자(move assignment operator)
 else
	아무것도 프로그램하지 않아도 된다.(디폴트로 만들어 지니까)
 ----------------------------------
*/
#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;
// 배열(Array) - 동일한 자료를 여러개 담을 수 있는
//				자료구조(Data Structor)
//			-->	메모리가 붙어있다(연속),크기가 변경될 수 없다.
//				프로그램 실행전에 크기가 결정된다.
//			--> Safe Array 경계를 검사하여 잘못된 인덱스로 접근하는 시도에 적절한 대처하자.

class SafeIntArray {
	int num;
	int* p;
public:
	SafeIntArray(int n) : num(n){
		num = n;
		p = new int[num];
	}
	SafeIntArray(const SafeIntArray& other) {
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
	}
	~SafeIntArray() { delete[] p; }

	SafeIntArray& operator=(const SafeIntArray& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
		return *this;
	}
	int& operator[](int idx) const {
			return p[idx];
	}
	size_t size() const{
		return num;
	}
	int* begin() {
		return p;
	}
	int* end() {
		return p+num;
	}
};


int main()
{
	SafeIntArray a(10000);		//정수 10개가 들어갈 공간 확보
	
	uniform_int_distribution<> uid(0, 100000);
	default_random_engine dre;

	sort(a.begin(), a.end());

	for (int& d : a)
		d = uid(dre);
	for (int d : a)
		cout << d << '\t';
	cout << endl;
	save();
}



-----------------------------------
Thu Nov  8 11:11:32 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template

 class 정리 : ★★★★★
 if(생성자에서 자원을 할당했다면 - new)
	1. 소멸자함수를 프로그램 한다.(자원을 해제)
	2. 복사생성자를 프로그램 한다.(copy constructor)
	3. 복사할당연산자를 프로그램한다.(copy assignment)
	----이동연산을 지원하는 클래스로 만들고 싶다면----
	4. 이동생성자를 프로그램한다.(move constructor)
	5. 이동할당연산자(move assignment operator)
 else
	아무것도 프로그램하지 않아도 된다.(디폴트로 만들어 지니까)
 ----------------------------------
*/
#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;
// 배열(Array) - 동일한 자료를 여러개 담을 수 있는
//				자료구조(Data Structor)
//			-->	메모리가 붙어있다(연속),크기가 변경될 수 없다.
//				프로그램 실행전에 크기가 결정된다.
//			--> Safe Array 경계를 검사하여 잘못된 인덱스로 접근하는 시도에 적절한 대처하자.

class SafeIntArray {
	int num;
	int* p;
public:
	SafeIntArray(int n) : num(n){
		num = n;
		p = new int[num];
	}
	SafeIntArray(const SafeIntArray& other) {
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
	}
	~SafeIntArray() { delete[] p; }

	SafeIntArray& operator=(const SafeIntArray& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
		return *this;
	}
	int& operator[](int idx) const {
			return p[idx];
	}
	size_t size() const{
		return num;
	}
	int* begin() {
		return p;
	}
	int* end() {
		return p+num;
	}
};


int main()
{
	SafeIntArray a(10000);		//정수 10개가 들어갈 공간 확보
	
	uniform_int_distribution<> uid(0, 100000);
	default_random_engine dre;

	
	for (int& d : a)
		d = uid(dre);
	sort(a.begin(), a.end());

	for (int d : a)
		cout << d << '\t';
	cout << endl;
	save();
}



-----------------------------------
Thu Nov  8 11:12:37 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template

 class 정리 : ★★★★★
 if(생성자에서 자원을 할당했다면 - new)
	1. 소멸자함수를 프로그램 한다.(자원을 해제)
	2. 복사생성자를 프로그램 한다.(copy constructor)
	3. 복사할당연산자를 프로그램한다.(copy assignment)
	----이동연산을 지원하는 클래스로 만들고 싶다면----
	4. 이동생성자를 프로그램한다.(move constructor)
	5. 이동할당연산자(move assignment operator)
 else
	아무것도 프로그램하지 않아도 된다.(디폴트로 만들어 지니까)
 ----------------------------------
*/
#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;
// 배열(Array) - 동일한 자료를 여러개 담을 수 있는
//				자료구조(Data Structor)
//			-->	메모리가 붙어있다(연속),크기가 변경될 수 없다.
//				프로그램 실행전에 크기가 결정된다.
//			--> Safe Array 경계를 검사하여 잘못된 인덱스로 접근하는 시도에 적절한 대처하자.

class SafeIntArray {
	int num;
	int* p;
public:
	SafeIntArray(int n) : num(n){
		num = n;
		p = new int[num];
	}
	SafeIntArray(const SafeIntArray& other) {
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
	}
	~SafeIntArray() { delete[] p; }

	SafeIntArray& operator=(const SafeIntArray& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
		return *this;
	}
	int& operator[](int idx) const {
			return p[idx];
	}
	size_t size() const{
		return num;
	}
	int* begin() {
		return p;
	}
	int* end() {
		return p+num;
	}
};


int main()
{
	SafeIntArray a(10000);		//정수 10개가 들어갈 공간 확보
	
	uniform_int_distribution<> uid(0, 100000);
	default_random_engine dre;

	
	for (int& d : a)
		d = uid(dre);
	sort(a.begin(), a.end(), [](int a, int b) {
		return a > b;
	});

	for (int d : a)
		cout << d << '\t';
	cout << endl;
	save();
}



-----------------------------------
Thu Nov  8 11:12:46 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template

 class 정리 : ★★★★★
 if(생성자에서 자원을 할당했다면 - new)
	1. 소멸자함수를 프로그램 한다.(자원을 해제)
	2. 복사생성자를 프로그램 한다.(copy constructor)
	3. 복사할당연산자를 프로그램한다.(copy assignment)
	----이동연산을 지원하는 클래스로 만들고 싶다면----
	4. 이동생성자를 프로그램한다.(move constructor)
	5. 이동할당연산자(move assignment operator)
 else
	아무것도 프로그램하지 않아도 된다.(디폴트로 만들어 지니까)
 ----------------------------------
*/
#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;
// 배열(Array) - 동일한 자료를 여러개 담을 수 있는
//				자료구조(Data Structor)
//			-->	메모리가 붙어있다(연속),크기가 변경될 수 없다.
//				프로그램 실행전에 크기가 결정된다.
//			--> Safe Array 경계를 검사하여 잘못된 인덱스로 접근하는 시도에 적절한 대처하자.

class SafeIntArray {
	int num;
	int* p;
public:
	SafeIntArray(int n) : num(n){
		num = n;
		p = new int[num];
	}
	SafeIntArray(const SafeIntArray& other) {
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
	}
	~SafeIntArray() { delete[] p; }

	SafeIntArray& operator=(const SafeIntArray& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
		return *this;
	}
	int& operator[](int idx) const {
			return p[idx];
	}
	size_t size() const{
		return num;
	}
	int* begin() {
		return p;
	}
	int* end() {
		return p+num;
	}
};


int main()
{
	SafeIntArray a(10000);		//정수 10개가 들어갈 공간 확보
	
	uniform_int_distribution<> uid(0, 100000);
	default_random_engine dre;

	
	for (int& d : a)
		d = uid(dre);
	sort(a.begin(), a.end(), [](int a, int b) {
		return a < b;
	});

	for (int d : a)
		cout << d << '\t';
	cout << endl;
	save();
}



-----------------------------------
Thu Nov  8 11:13:04 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template

 class 정리 : ★★★★★
 if(생성자에서 자원을 할당했다면 - new)
	1. 소멸자함수를 프로그램 한다.(자원을 해제)
	2. 복사생성자를 프로그램 한다.(copy constructor)
	3. 복사할당연산자를 프로그램한다.(copy assignment)
	----이동연산을 지원하는 클래스로 만들고 싶다면----
	4. 이동생성자를 프로그램한다.(move constructor)
	5. 이동할당연산자(move assignment operator)
 else
	아무것도 프로그램하지 않아도 된다.(디폴트로 만들어 지니까)
 ----------------------------------
*/
#include <iostream>
#include <random>
#include <algorithm>
#include "save.h"
using namespace std;
// 배열(Array) - 동일한 자료를 여러개 담을 수 있는
//				자료구조(Data Structor)
//			-->	메모리가 붙어있다(연속),크기가 변경될 수 없다.
//				프로그램 실행전에 크기가 결정된다.
//			--> Safe Array 경계를 검사하여 잘못된 인덱스로 접근하는 시도에 적절한 대처하자.

class SafeIntArray {
	int num;
	int* p;
public:
	SafeIntArray(int n) : num(n){
		num = n;
		p = new int[num];
	}
	SafeIntArray(const SafeIntArray& other) {
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
	}
	~SafeIntArray() { delete[] p; }

	SafeIntArray& operator=(const SafeIntArray& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new int[num];
		memcpy(p, other.p, num * sizeof(int));
		return *this;
	}
	int& operator[](int idx) const {
			return p[idx];
	}
	size_t size() const{
		return num;
	}
	int* begin() {
		return p;
	}
	int* end() {
		return p+num;
	}
};


int main()
{
	SafeIntArray a(10000);		//정수 10개가 들어갈 공간 확보
	
	uniform_int_distribution<> uid(0, 100000);
	default_random_engine dre;

	
	for (int& d : a)
		d = uid(dre);
	sort(a.begin(), a.end(), [](int a, int b) {
		return a > b;
	});

	for (int d : a)
		cout << d << '\t';
	cout << endl;
	save();
}



-----------------------------------
Mon Nov 12 13:51:49 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제
 ----------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

class Animal {		//조상 클래스
	int a;
};

class Bird : Animal {//자식 클래스
	
};

int main()
{
	cout << sizeof(Bird);
	save();
}



-----------------------------------
Mon Nov 12 13:53:20 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제
 ----------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

class Animal {			//조상 클래스
	int a;
};

class Bird : Animal {	//자식 클래스
	int b;
};

int main()
{
	cout << sizeof(Bird);
	save();
}



-----------------------------------
Mon Nov 12 13:58:45 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제
 ----------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

class Animal {			//조상 클래스
	int a;
public:
	Animal() { cout << "Animal 생성" << endl; }
	~Animal() { cout << "Animal 소멸" << endl; }
};

class Bird : Animal {	//자식 클래스
	int b;
public:
	Bird() { cout << "Bird 생성" << endl; }
	~Bird() { cout << "Bird 소멸" << endl; }
};

int main()
{
	Bird a;		//이때 생성자와 소멸자가 어떻게 호출되는지 관찰

	
	save();
}



-----------------------------------
Mon Nov 12 13:59:26 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제
 ----------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

class Animal {			//조상 클래스
	int a;
public:
	Animal() { cout << "Animal 생성" << endl; }
	~Animal() { cout << "Animal 소멸" << endl; }
};

class Bird : Animal {	//자식 클래스
	int b;
public:
	Bird() { cout << "Bird 생성" << endl; }
	~Bird() { cout << "Bird 소멸" << endl; }
};

int main()
{
	Animal b;
	Bird a;		//이때 생성자와 소멸자가 어떻게 호출되는지 관찰

	
	save();
}



-----------------------------------
Mon Nov 12 14:07:56 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제
 ----------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

class Animal {			//조상 클래스
	int a;
public:
	Animal() { cout << "Animal 생성" << endl; }
	Animal(int n ) : a(n){
		cout << "Animal int 생성 - " << a <<  endl;
	}
	~Animal() { cout << "Animal 소멸" << endl; }
};

class Bird : Animal {	//자식 클래스
	int b;
public:
	Bird() { cout << "Bird 생성" << endl; }
	Bird(int n) : b(n), Animal(n*2) {
		cout << "Bird int 생성 - " << b << endl;
	}
	~Bird() { cout << "Bird 소멸" << endl; }
};

int main()
{
	// Bird를 생성할때 정수 하나를 인자로 받는다
	// Bird는 Animal을 상속받은 거니까 Animal의 메모리도 포함된다.
	// Bird는 자기가 받은 인자를 x2해서 조상의 메모리에 써보자.
	Bird a(10);		//Bird는 10 Animal는 20

	
	save();
}



-----------------------------------
Mon Nov 12 14:29:24 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제
 ----------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

class Animal {			//조상 클래스
	int a;
public:
	Animal() { cout << "Animal 생성" << endl; }
	Animal(int n ) : a(n){
		cout << "Animal int 생성" << endl;
	}
	~Animal() { cout << "Animal 소멸" << endl; }
	int getA() const { return a; }
};

class Bird : Animal {	//자식 클래스
	int b;
public:
	Bird() { cout << "Bird 생성" << endl; }
	Bird(int n) : b(n), Animal(n*2) {
		cout << "Bird int 생성"<< endl;
	}
	~Bird() { cout << "Bird 소멸" << endl; }

	friend ostream& operator<<(ostream&, const Bird&);
};
ostream& operator<<(ostream& os, const Bird& b) {
	os << "Animal - " << b.getA() << "Bird - " << b.b << endl;
	return os;
}
int main()
{
	// Bird를 생성할때 정수 하나를 인자로 받는다
	// Bird는 Animal을 상속받은 거니까 Animal의 메모리도 포함된다.
	// Bird는 자기가 받은 인자를 x2해서 조상의 메모리에 써보자.
	Bird a(10);		//Bird는 10 Animal는 20

	cout << a << endl;
	
	save();
}



-----------------------------------
Mon Nov 12 14:29:39 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제
 ----------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

class Animal {			//조상 클래스
	int a;
public:
	Animal() { cout << "Animal 생성" << endl; }
	Animal(int n ) : a(n){
		cout << "Animal int 생성" << endl;
	}
	~Animal() { cout << "Animal 소멸" << endl; }
	int getA() const { return a; }
};

class Bird : Animal {	//자식 클래스
	int b;
public:
	Bird() { cout << "Bird 생성" << endl; }
	Bird(int n) : b(n), Animal(n*2) {
		cout << "Bird int 생성"<< endl;
	}
	~Bird() { cout << "Bird 소멸" << endl; }

	friend ostream& operator<<(ostream&, const Bird&);
};
ostream& operator<<(ostream& os, const Bird& b) {
	os << "Animal - " << b.getA() << " Bird - " << b.b << endl;
	return os;
}
int main()
{
	// Bird를 생성할때 정수 하나를 인자로 받는다
	// Bird는 Animal을 상속받은 거니까 Animal의 메모리도 포함된다.
	// Bird는 자기가 받은 인자를 x2해서 조상의 메모리에 써보자.
	Bird a(10);		//Bird는 10 Animal는 20

	cout << a << endl;
	
	save();
}



-----------------------------------
Mon Nov 12 14:29:55 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제
 ----------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

class Animal {			//조상 클래스
	int a;
public:
	Animal() { cout << "Animal 생성" << endl; }
	Animal(int n ) : a(n){
		cout << "Animal int 생성" << endl;
	}
	~Animal() { cout << "Animal 소멸" << endl; }
	int getA() const { return a; }
};

class Bird : Animal {	//자식 클래스
	int b;
public:
	Bird() { cout << "Bird 생성" << endl; }
	Bird(int n) : b(n), Animal(n*2) {
		cout << "Bird int 생성"<< endl;
	}
	~Bird() { cout << "Bird 소멸" << endl; }

	friend ostream& operator<<(ostream&, const Bird&);
};
ostream& operator<<(ostream& os, const Bird& b) {
	os << "Animal - " << b.getA() << " Bird - " << b.b;
	return os;
}
int main()
{
	// Bird를 생성할때 정수 하나를 인자로 받는다
	// Bird는 Animal을 상속받은 거니까 Animal의 메모리도 포함된다.
	// Bird는 자기가 받은 인자를 x2해서 조상의 메모리에 써보자.
	Bird a(10);		//Bird는 10 Animal는 20

	cout << a << endl;
	
	save();
}



-----------------------------------
Mon Nov 12 14:45:21 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Animal {
	string name;
	int age;
public :
	Animal(string s, int n) : name(s), age(n) {

	}
	string getName() {
		return name;
	}
	int getAge() {
		return age;
	}
};
class Dog : Animal {
public:
	Dog(string s, int n) : Animal(s,n) {

	}
	void run() {
		cout << getName() << ',' << getAge() << "이 움직인다." << endl;
	}
};

int main()
{
	Dog a("구글", 10);
	a.run();		//"구글,10살이 움직인다."라고 출력해보자
	save();
}



-----------------------------------
Mon Nov 12 14:46:17 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Animal {
	string name;
	int age;
public :
	Animal(string s, int n) : name(s), age(n) {

	}
	string getName() {
		return name;
	}
	int getAge() {
		return age;
	}
};
class Dog : Animal {
public:
	Dog(string s, int n) : Animal(s,n) {

	}
	void run() {
		cout << getName() << ',' << getAge() << "살이 움직인다." << endl;
	}
};

int main()
{
	Dog a("구글", 10);
	a.run();		//"구글,10살이 움직인다."라고 출력해보자
	save();
}



-----------------------------------
Mon Nov 12 14:53:29 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Animal {
	string name;
	int age;
public :
	Animal(string s, int n) : name(s), age(n) {

	}
	void run() const{
		cout << name << ',' << age << "살이 움직인다." << endl;
	}
};
class Dog : public Animal {
public:
	Dog(string s, int n) : Animal(s,n) {

	}
	
};

int main()
{
	Dog a("구글", 10);
	a.run();		//"구글,10살이 움직인다."라고 출력해보자
	save();
}



-----------------------------------
Mon Nov 12 14:55:34 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Animal {
	string name;
	int age;
public :
	Animal(string s, int n) : name(s), age(n) {

	}
	void run() const{
		cout << name << ',' << age << "살이 움직인다." << endl;
	}
};
class Dog : public Animal {
public:
	Dog(string s, int n) : Animal(s,n) {

	}
	void run() const {
		cout << "개 - ";
	}
	
};

int main()
{
	Dog a("구글", 10);
	a.run();		//"개 - 구글,10살이 움직인다."라고 출력해보자
	save();
}



-----------------------------------
Mon Nov 12 14:59:50 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Animal {
	string name;
	int age;
public :
	Animal(string s, int n) : name(s), age(n) {

	}
	void run() const{
		cout << name << ',' << age << "살이 움직인다." << endl;
	}
};
class Dog : public Animal {
public:
	Dog(string s, int n) : Animal(s,n) {

	}
	void run() const {
		cout << "개 - "; Animal::run();
	}
};

int main()
{
	Dog a("구글", 10);
	a.run();		//"개 - 구글,10살이 움직인다."라고 출력해보자
	save();
}



-----------------------------------
Mon Nov 12 15:09:51 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Animal {
	string name;
	int age;
public :
	Animal(string s, int n) : name(s), age(n) {

	}
	virtual void run() const{
		cout << name << ',' << age << "살이 움직인다." << endl;
	}
};
class Dog : public Animal {
public:
	Dog(string s, int n) : Animal(s,n) {

	}
	void run() const override final{		//조상의 run을 덮어 썼다. -> 멤버함수를 override 함
		cout << "개 - "; Animal::run();
	}
};

int main()
{
	Dog a("구글", 10);
	a.run();		//"개 - 구글,10살이 움직인다."라고 출력해보자
	save();
}



-----------------------------------
Tue Nov 13 22:30:40 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Animal {
	string name;
	int age;
public:
	Animal(string name,int age) : name(name),age(age){}

	virtual void move(){
		cout << age << "살" << name << "이(가)" << endl;
	}
};
class Dog : public Animal{
public:
	Dog(string s, int n) : Animal(s, n) {}

	void move()override{
		Animal::move();
		cout << "달린다." << endl;
	}
};
class Bird : public Animal{
public:
	Bird(string s, int n) : Animal(s, n) {}
};
int main()
{
	Dog a{ "구글",10 };
	Bird b{ "코딩", 5 };

	a.move();		//10살 개 구글이(가) 달린다.
	b.move();		//5살 새 코딩이(가) 난다.
	save();
}



-----------------------------------
Tue Nov 13 22:31:19 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Animal {
	string name;
	int age;
public:
	Animal(string name,int age) : name(name),age(age){}

	virtual void move(){
		cout << age << "살" << name << "이(가)";
	}
};
class Dog : public Animal{
public:
	Dog(string s, int n) : Animal(s, n) {}

	void move()override{
		Animal::move();
		cout << "달린다." << endl;
	}
};
class Bird : public Animal{
public:
	Bird(string s, int n) : Animal(s, n) {}
	void move()override {
		Animal::move();
		cout << "달린다." << endl;
	}
};
int main()
{
	Dog a{ "구글",10 };
	Bird b{ "코딩", 5 };

	a.move();		//10살 개 구글이(가) 달린다.
	b.move();		//5살 새 코딩이(가) 난다.
	save();
}



-----------------------------------
Thu Nov 15 09:41:06 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Animal {
	string name;
	int age;
public:
	Animal(string name,int age) : name(name),age(age){}

	virtual void move()const {
		//cout << age << "살" << name << "이(가)";
	}
	int getAge() const { return age; }
	string getName() const{ return name; }
};
class Dog : public Animal{
public:
	Dog(string s, int n) : Animal(s, n) {}

	virtual void move() const override {
		//Animal::move();
		cout << getAge() <<"살 개 " << getName() << "이(가)달린다." << endl;
	}
};
class Bird : public Animal{
public:
	Bird(string s, int n) : Animal(s, n) {}
	virtual void move() const override{
		//Animal::move();
		cout << getAge() << "살 개 " << getName() << "이(가)달린다." << endl;
	}
};
int main()
{
	Dog a{ "구글",10 };
	Bird b{ "코딩", 5 };

	a.move();		//10살 개 구글이(가) 달린다.
	b.move();		//5살 새 코딩이(가) 난다.

	save();
}



-----------------------------------
Thu Nov 15 09:50:34 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//상속
//		Animal
//
//	Dog			Bird

class Animal{
	string name;
public:
	Animal(string s) : name(s) {

	}
	virtual void move() const {
		cout << name << "이가";
	}
};
class Dog : public Animal {
public:
	Dog(string s) : Animal(s){}
	virtual void move() const override{
		Animal::move();
		cout << "달린다.";
	}
};
class Bird : public Animal {
public:
	Bird(string s) : Animal(s){}
	virtual void move() const override {
		Animal::move();
		cout << "난다.";
	}
};


int main()
{
	// Dog와 Bird의 조상은 Animal이다.
	// Animal은 name 멤버를 갖는다.
	// Animal의 공통 동작은 move()이다.
	Dog a("수능");
	Bird b("만점");

	a.move();		//수능이가 달린다.
	a.move();		//만점이가 난다.

	save();
}



-----------------------------------
Thu Nov 15 09:51:04 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//상속
//		Animal
//
//	Dog			Bird

class Animal{
	string name;
public:
	Animal(string s) : name(s) {

	}
	virtual void move() const {
		cout << name << "이가";
	}
};
class Dog : public Animal {
public:
	Dog(string s) : Animal(s){}
	virtual void move() const override{
		Animal::move();
		cout << "달린다." << endl;
	}
};
class Bird : public Animal {
public:
	Bird(string s) : Animal(s){}
	virtual void move() const override {
		Animal::move();
		cout << "난다." << endl;
	}
};


int main()
{
	// Dog와 Bird의 조상은 Animal이다.
	// Animal은 name 멤버를 갖는다.
	// Animal의 공통 동작은 move()이다.
	Dog a("수능");
	Bird b("만점");

	a.move();		//수능이가 달린다.
	b.move();		//만점이가 난다.

	save();
}



-----------------------------------
Thu Nov 15 09:51:15 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//상속
//		Animal
//
//	Dog			Bird

class Animal{
	string name;
public:
	Animal(string s) : name(s) {

	}
	virtual void move() const {
		cout << name << "이가 ";
	}
};
class Dog : public Animal {
public:
	Dog(string s) : Animal(s){}
	virtual void move() const override{
		Animal::move();
		cout << "달린다." << endl;
	}
};
class Bird : public Animal {
public:
	Bird(string s) : Animal(s){}
	virtual void move() const override {
		Animal::move();
		cout << "난다." << endl;
	}
};


int main()
{
	// Dog와 Bird의 조상은 Animal이다.
	// Animal은 name 멤버를 갖는다.
	// Animal의 공통 동작은 move()이다.
	Dog a("수능");
	Bird b("만점");

	a.move();		//수능이가 달린다.
	b.move();		//만점이가 난다.

	save();
}



-----------------------------------
Thu Nov 15 09:58:32 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//상속
//		Animal
//
//	Dog			Bird

class Animal{
	string name;
public:
	Animal(string s) : name(s) {

	}
	virtual void move() const {
		cout << name << "이가 ";
	}
};
class Dog : public Animal {
public:
	Dog(string s) : Animal(s){}
	virtual void move() const override{
		Animal::move();
		cout << "달린다." << endl;
	}
};
class Bird : public Animal {
public:
	Bird(string s) : Animal(s){}
	virtual void move() const override {
		Animal::move();
		cout << "난다." << endl;
	}
};


int main()
{
	// Dog와 Bird의 조상은 Animal이다.
	// Animal은 name 멤버를 갖는다.
	// Animal의 공통 동작은 move()이다.
	Dog a("수능");
	Bird b("만점");

	a.move();		//수능이가 달린다.
	b.move();		//만점이가 난다.

	save();
}



-----------------------------------
Thu Nov 15 10:10:22 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//상속
//		Animal
//
//	Dog			Bird

class Animal{
	
public:
	string name;
	Animal(string s) : name(s) {

	}
	virtual void move() const {
		
	}
};
class Dog : public Animal {
public:
	Dog(string s) : Animal(s){}
	virtual void move() const override{
		
		cout << name << "이가 달린다." << endl;
	}
};
class Bird : public Animal {
public:
	Bird(string s) : Animal(s){}
	virtual void move() const override {
		Animal::move();
		cout << name << "이가 난다." << endl;
	}
};


int main()
{
	// Dog와 Bird의 조상은 Animal이다.
	// Animal은 name 멤버를 갖는다.
	// Animal의 공통 동작은 move()이다.
	Dog a("수능");
	Bird b("만점");

	a.move();		//수능이가 달린다.
	b.move();		//만점이가 난다.

	save();
}



-----------------------------------
Thu Nov 15 10:14:05 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//상속
//		Animal
//
//	Dog			Bird

class Animal{
protected:
	string name;
public:
	
	Animal(string s) : name(s) {

	}
	virtual void move() const {
		
	}
};
class Dog : public Animal {
public:
	Dog(string s) : Animal(s){}
	virtual void move() const override{
		
		cout << name << "이가 달린다." << endl;
	}
};
class Bird : public Animal {
public:
	Bird(string s) : Animal(s){}
	virtual void move() const override {
		Animal::move();
		cout << name << "이가 난다." << endl;
	}
};


int main()
{
	// Dog와 Bird의 조상은 Animal이다.
	// Animal은 name 멤버를 갖는다.
	// Animal의 공통 동작은 move()이다.
	Dog a("수능");
	Bird b("만점");
	a.move();		//수능이가 달린다.
	b.move();		//만점이가 난다.

	save();
}



-----------------------------------
Thu Nov 15 11:02:55 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Animal{
protected:
	string name;
public:
	Animal(){}
	Animal(string s) : name(s){}
	
};

class Dog : public Animal {
public:
	Dog() : Animal(){}
	Dog(string s) : Animal(){}
};
class Bird : public Animal {
public:
	Bird() : Animal() {}
	Bird(string s) : Animal(){}
};

int main()
{
	// 동물의 호텔이다.
	// 손님은 개와 새만 투숙가능다.
	// 객실은 모두 100개가 있다.
	
	// 1호실 부터 물어보자 투숙할 손님이 개인지 고양이인지?
	// 이름도 물어서 기록하자.
	// 그만할때까지 기록하자.
	Animal* hotel[100]; // 동물 100마리를 가리킬 수 있다.
	for (int i = 0; i < 100; ++i) {
		int sel;
		cout << i + 1 << "번 방 숙박 가능합니다." << endl;
		cout << "손님은 개(0)인가요 새(1)인가요? 끝내려면(2)";
		cin >> sel;
		string name;
		switch (sel)
		{
		case 0:
			
			cout << "이름은 무엇인가요?" << endl;
			cin >> name;
			hotel[i] = new Dog(name);
			break;
		case 1:
			
			cout << "이름은 무엇인가요?" << endl;
			cin >> name;
			hotel[i] = new Bird(name);
			break;
		case 2:
			break;
		}
		if (sel == 2)
			break;
	}
		
	save();
}



-----------------------------------
Thu Nov 15 11:06:50 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Animal{
protected:
	string name;
public:
	Animal(){}
	Animal(string s) : name(s){}
	
};

class Dog : public Animal {
public:
	Dog() : Animal(){}
	Dog(string s) : Animal(){}
};
class Bird : public Animal {
public:
	Bird() : Animal() {}
	Bird(string s) : Animal(){}
};

int guestNum = 0;

int main()
{
	// 동물의 호텔이다.
	// 손님은 개와 새만 투숙가능다.
	// 객실은 모두 100개가 있다.
	
	// 1호실 부터 물어보자 투숙할 손님이 개인지 고양이인지?
	// 이름도 물어서 기록하자.
	// 그만할때까지 기록하자.
	Animal* hotel[100]; // 동물 100마리를 가리킬 수 있다.
	for (int i = 0; i < 100; ++i) {
		int sel;
		cout << i + 1 << "번 방 숙박 가능합니다." << endl;
		cout << "손님은 개(0)인가요 새(1)인가요? 끝내려면(2)";
		cin >> sel;
		string name;
		switch (sel)
		{
		case 0:
			
			cout << "이름은 무엇인가요?" << endl;
			cin >> name;
			hotel[i] = new Dog(name);
			break;
			++guestNum;
		case 1:
			
			cout << "이름은 무엇인가요?" << endl;
			cin >> name;
			hotel[i] = new Bird(name);
			break;
		}
		if (sel == 2)
			break;

		// 명단 출력
		cout << "전체 손님수 : " << guestNum << endl;
		for (int i = 0; i < guestNum; ++i) {
			
		}
	}
		
	save();
}



-----------------------------------
Thu Nov 15 11:07:15 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Animal{
protected:
	string name;
public:
	Animal(){}
	Animal(string s) : name(s){}
	
};

class Dog : public Animal {
public:
	Dog() : Animal(){}
	Dog(string s) : Animal(){}
};
class Bird : public Animal {
public:
	Bird() : Animal() {}
	Bird(string s) : Animal(){}
};

int guestNum = 0;

int main()
{
	// 동물의 호텔이다.
	// 손님은 개와 새만 투숙가능다.
	// 객실은 모두 100개가 있다.
	
	// 1호실 부터 물어보자 투숙할 손님이 개인지 고양이인지?
	// 이름도 물어서 기록하자.
	// 그만할때까지 기록하자.
	Animal* hotel[100]; // 동물 100마리를 가리킬 수 있다.
	for (int i = 0; i < 100; ++i) {
		int sel;
		cout << i + 1 << "번 방 숙박 가능합니다." << endl;
		cout << "손님은 개(0)인가요 새(1)인가요? 끝내려면(2)";
		cin >> sel;
		string name;
		switch (sel)
		{
		case 0:
			
			cout << "이름은 무엇인가요?" << endl;
			cin >> name;
			hotel[i] = new Dog(name);
			break;
			++guestNum;
		case 1:
			
			cout << "이름은 무엇인가요?" << endl;
			cin >> name;
			hotel[i] = new Bird(name);
			break;
		}
		if (sel == 2)
			break;

		
	}
	// 명단 출력
	cout << "전체 손님수 : " << guestNum << endl;
	for (int i = 0; i < guestNum; ++i) {
		
	}
		
	save();
}



-----------------------------------
Thu Nov 15 11:07:23 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Animal{
protected:
	string name;
public:
	Animal(){}
	Animal(string s) : name(s){}
	
};

class Dog : public Animal {
public:
	Dog() : Animal(){}
	Dog(string s) : Animal(){}
};
class Bird : public Animal {
public:
	Bird() : Animal() {}
	Bird(string s) : Animal(){}
};

int guestNum = 0;

int main()
{
	// 동물의 호텔이다.
	// 손님은 개와 새만 투숙가능다.
	// 객실은 모두 100개가 있다.
	
	// 1호실 부터 물어보자 투숙할 손님이 개인지 고양이인지?
	// 이름도 물어서 기록하자.
	// 그만할때까지 기록하자.
	Animal* hotel[100]; // 동물 100마리를 가리킬 수 있다.
	for (int i = 0; i < 100; ++i) {
		int sel;
		cout << i + 1 << "번 방 숙박 가능합니다." << endl;
		cout << "손님은 개(0)인가요 새(1)인가요? 끝내려면(2)";
		cin >> sel;
		string name;
		switch (sel)
		{
		case 0:
			
			cout << "이름은 무엇인가요?" << endl;
			cin >> name;
			hotel[i] = new Dog(name);
			break;
			++guestNum;
		case 1:
			
			cout << "이름은 무엇인가요?" << endl;
			cin >> name;
			hotel[i] = new Bird(name);
			break;
		}
		if (sel == 2)
			break;

		
	}
	// 명단 출력
	cout << "전체 손님수 : " << guestNum << endl;
	for (int i = 0; i < guestNum; ++i) {
		
	}
		
	save();
}



-----------------------------------
Thu Nov 15 11:08:16 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Animal{
protected:
	string name;
public:
	Animal(){}
	Animal(string s) : name(s){}
	
};

class Dog : public Animal {
public:
	Dog() : Animal(){}
	Dog(string s) : Animal(){}
};
class Bird : public Animal {
public:
	Bird() : Animal() {}
	Bird(string s) : Animal(){}
};

int guestNum = 0;

int main()
{
	// 동물의 호텔이다.
	// 손님은 개와 새만 투숙가능다.
	// 객실은 모두 100개가 있다.
	
	// 1호실 부터 물어보자 투숙할 손님이 개인지 고양이인지?
	// 이름도 물어서 기록하자.
	// 그만할때까지 기록하자.
	Animal* hotel[100]; // 동물 100마리를 가리킬 수 있다.
	for (int i = 0; i < 100; ++i) {
		int sel;
		cout << i + 1 << "번 방 숙박 가능합니다." << endl;
		cout << "손님은 개(0)인가요 새(1)인가요? 끝내려면(2)";
		cin >> sel;
		string name;
		switch (sel)
		{
		case 0:
			
			cout << "이름은 무엇인가요?" << endl;
			cin >> name;
			hotel[i] = new Dog(name);
			break;
			++guestNum;
		case 1:
			
			cout << "이름은 무엇인가요?" << endl;
			cin >> name;
			hotel[i] = new Bird(name);
			break;
			++guestNum;
		}
		if (sel == 2)
			break;

		
	}
	// 명단 출력
	cout << "전체 손님수 : " << guestNum << endl;
	for (int i = 0; i < guestNum; ++i) {
		
	}
		
	save();
}



-----------------------------------
Thu Nov 15 11:08:50 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Animal{
protected:
	string name;
public:
	Animal(){}
	Animal(string s) : name(s){}
	
};

class Dog : public Animal {
public:
	Dog() : Animal(){}
	Dog(string s) : Animal(){}
};
class Bird : public Animal {
public:
	Bird() : Animal() {}
	Bird(string s) : Animal(){}
};

int guestNum = 0;

int main()
{
	// 동물의 호텔이다.
	// 손님은 개와 새만 투숙가능다.
	// 객실은 모두 100개가 있다.
	
	// 1호실 부터 물어보자 투숙할 손님이 개인지 고양이인지?
	// 이름도 물어서 기록하자.
	// 그만할때까지 기록하자.
	Animal* hotel[100]; // 동물 100마리를 가리킬 수 있다.
	for (int i = 0; i < 100; ++i) {
		int sel;
		cout << i + 1 << "번 방 숙박 가능합니다." << endl;
		cout << "손님은 개(0)인가요 새(1)인가요? 끝내려면(2)";
		cin >> sel;
		string name;
		switch (sel)
		{
		case 0:
			
			cout << "이름은 무엇인가요?" << endl;
			cin >> name;
			hotel[i] = new Dog(name);
			++guestNum;
			break;
			
		case 1:
			
			cout << "이름은 무엇인가요?" << endl;
			cin >> name;
			hotel[i] = new Bird(name);
			++guestNum;
			break;
		}
		if (sel == 2)
			break;

		
	}
	// 명단 출력
	cout << "전체 손님수 : " << guestNum << endl;
	for (int i = 0; i < guestNum; ++i) {
		
	}
		
	save();
}



-----------------------------------
Thu Nov 15 11:17:40 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Animal{
protected:
	string name;
public:
	Animal(){}
	Animal(string s) : name(s){}
	virtual void inform() const {	// 이 함수는 자식에서 오버로딩 할거다.

	}
};

class Dog : public Animal {
public:
	Dog() : Animal(){}
	Dog(string s) : Animal(){}
	void inform() const override final{
		cout << "개 : " << name ;
	}
};
class Bird : public Animal {
public:
	Bird() : Animal() {}
	Bird(string s) : Animal(){}
	void inform() const override final{
		cout << "새 : " << name ;
	}
};

int guestNum = 0;

int main()
{
	// 동물의 호텔이다.
	// 손님은 개와 새만 투숙가능다.
	// 객실은 모두 100개가 있다.
	
	// 1호실 부터 물어보자 투숙할 손님이 개인지 고양이인지?
	// 이름도 물어서 기록하자.
	// 그만할때까지 기록하자.
	Animal* hotel[100]; // 동물 100마리를 가리킬 수 있다.
	for (int i = 0; i < 100; ++i) {
		int sel;
		cout << i + 1 << "번 방 숙박 가능합니다." << endl;
		cout << "손님은 개(0)인가요 새(1)인가요? 끝내려면(2)";
		cin >> sel;
		string name;
		switch (sel)
		{
		case 0:
			
			cout << "이름은 무엇인가요?" << endl;
			cin >> name;
			hotel[i] = (Animal*)((Dog*)new Dog(name));
			++guestNum;
			break;
			
		case 1:
			
			cout << "이름은 무엇인가요?" << endl;
			cin >> name;
			hotel[i] =(Animal*)((Dog*)new Bird(name));
			++guestNum;
			break;
		}
		if (sel == 2)
			break;

		
	}
	// 명단 출력
	cout << "전체 손님수 : " << guestNum << endl;

	for (int i = 0; i < guestNum; ++i) {
		hotel[i]->inform();
		cout << i << "호실";
	}
		
	save();
}



-----------------------------------
Thu Nov 15 11:18:13 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Animal{
protected:
	string name;
public:
	Animal(){}
	Animal(string s) : name(s){}
	virtual void inform() const {	// 이 함수는 자식에서 오버로딩 할거다.

	}
};

class Dog : public Animal {
public:
	Dog() : Animal(){}
	Dog(string s) : Animal(){}
	void inform() const override final{
		cout << "개 : " << name ;
	}
};
class Bird : public Animal {
public:
	Bird() : Animal() {}
	Bird(string s) : Animal(){}
	void inform() const override final{
		cout << "새 : " << name ;
	}
};

int guestNum = 0;

int main()
{
	// 동물의 호텔이다.
	// 손님은 개와 새만 투숙가능다.
	// 객실은 모두 100개가 있다.
	
	// 1호실 부터 물어보자 투숙할 손님이 개인지 고양이인지?
	// 이름도 물어서 기록하자.
	// 그만할때까지 기록하자.
	Animal* hotel[100]; // 동물 100마리를 가리킬 수 있다.
	for (int i = 0; i < 100; ++i) {
		int sel;
		cout << i + 1 << "번 방 숙박 가능합니다." << endl;
		cout << "손님은 개(0)인가요 새(1)인가요? 끝내려면(2)";
		cin >> sel;
		string name;
		switch (sel)
		{
		case 0:
			
			cout << "이름은 무엇인가요?" << endl;
			cin >> name;
			hotel[i] = (Animal*)((Dog*)new Dog(name));
			++guestNum;
			break;
			
		case 1:
			
			cout << "이름은 무엇인가요?" << endl;
			cin >> name;
			hotel[i] =(Animal*)((Dog*)new Bird(name));
			++guestNum;
			break;
		}
		if (sel == 2)
			break;

		
	}
	// 명단 출력
	cout << "전체 손님수 : " << guestNum << endl;

	for (int i = 0; i < guestNum; ++i) {
		hotel[i]->inform();
		cout << i << "호실" << endl;
	}
		
	save();
}



-----------------------------------
Mon Nov 19 13:54:44 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

class Animal{
protected:
	string name;
public:
	Animal(){}
	Animal(string s) : name(s){}
	virtual void inform() const {	// 이 함수는 자식에서 오버로딩 할거다.

	}
};

class Dog : public Animal {
public:
	Dog() : Animal(){}
	Dog(string s) : Animal(){}
	void inform() const override final{
		cout << "개 : " << name ;
	}
};
class Bird : public Animal {
public:
	Bird() : Animal() {}
	Bird(string s) : Animal(){}
	void inform() const override final{
		cout << "새 : " << name ;
	}
};


int main()
{
	// 동물의 호텔이다.
	// 손님은 개와 새만 투숙가능하다.
	// 객실은 모두 100개가 있다.
	
	// 1호실 부터 물어보자 투숙할 손님이 개인지 새인지?
	// 이름도 물어서 기록하자.
	// 그만할때까지 기록하자.

	Animal* hotel[100]; // 동물 100마리를 가리킬 수 있다.
	int guestNum = 0;


	int sel;
	for (int i = 0; i < 100; ++i) {

		cout << i + 1 << "번 방 숙박 가능합니다." << endl;
		cout << "손님은 개(0)인가요 새(1)인가요? 끝내려면(2)";
		cin >> sel;
		string name;
		switch (sel)
	{
		case 0:

			cout << "이름은 무엇인가요?" << endl;
			cin >> name;
			hotel[i] = (Animal*)((Dog*)new Dog(name));
			++guestNum;
			break;

		case 1:
			
			cout << "이름은 무엇인가요?" << endl;
			cin >> name;
			hotel[i] = (Animal*)((Dog*)new Bird(name));
			++guestNum;
			break;
		}
		if (sel == 2)
			break;

	}
		
	
	// 명단 출력
	cout << "전체 손님수 : " << guestNum << endl;

	//i번 방의 손님이 Dog인지 Bird인지 모르지만 inform()해라

	for (int i = 0; i < guestNum; ++i) {
		hotel[i]->inform();
		cout << i << "호실" << endl;
	}
	for (int i = 0; i < guestNum; ++i) {
		delete hotel[i];
	}
	
	save();
}



-----------------------------------
Mon Nov 19 14:02:28 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//	GameObject
//
//Player	Monster
//
// GameObject는 render() 함수를 갖는다.
// Player의 render() --> "플레이어를 그린다."
// Monster의 render() --> "몬스터를 그린다."

class GameObject {
	
public:
	void render() {

	}
};
class Player : public GameObject {
public:
	void render() {
		cout << "플레이어를 그린다." << endl;
	}
};
class Monster : public GameObject {
public:
	void render() {
		cout << "몬스터를 그린다." << endl;
	}
};





int main()
{
	GameObject* game[2];

	game[0] = new Player();
	game[1] = new Monster();

	for (GameObject* d : game)
		d->render();
	save();
}



-----------------------------------
Mon Nov 19 14:04:28 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//	GameObject
//
//Player	Monster
//
// GameObject는 render() 함수를 갖는다.
// Player의 render() --> "플레이어를 그린다."
// Monster의 render() --> "몬스터를 그린다."

class GameObject {
	
public:
	virtual void render() const {

	}
};
class Player : public GameObject {
public:
	void render() const override {
		cout << "플레이어를 그린다." << endl;
	}
};
class Monster : public GameObject {
public:
	void render() const override{
		cout << "몬스터를 그린다." << endl;
	}
};





int main()
{
	GameObject* game[2];

	game[0] = new Player();
	game[1] = new Monster();

	for (GameObject* d : game)
		d->render();
	save();
}



-----------------------------------
Mon Nov 19 14:05:35 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//	GameObject
//
//Player	Monster
//
// GameObject는 render() 함수를 갖는다.
// Player의 render() --> "플레이어를 그린다."
// Monster의 render() --> "몬스터를 그린다."

class GameObject {
	
public:
	virtual void render() const {

	}
};
class Player : public GameObject {
public:
	void render() const override {
		cout << "플레이어를 그린다." << endl;
	}
};
class Monster : public GameObject {
public:
	void render() const override {
		cout << "몬스터를 그린다." << endl;
	}
};





int main()
{
	GameObject* game[2];

	game[0] = new Player();
	game[1] = new Monster();

	for (GameObject* d : game)
		d->render();
	save();
}



-----------------------------------
Mon Nov 19 14:05:56 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//	GameObject
//
//Player	Monster
//
// GameObject는 render() 함수를 갖는다.
// Player의 render() --> "플레이어를 그린다."
// Monster의 render() --> "몬스터를 그린다."

class GameObject {
	
public:
	virtual void render() const {

	}
};
class Player : public GameObject {
public:
	void render() const override {
		cout << "플레이어를 그린다." << endl;
	}
};
class Monster : public GameObject {
public:
	void render() const override {
		cout << "몬스터를 그린다." << endl;
	}
};





int main()
{
	GameObject* game[2];

	game[0] = new Player();
	game[1] = new Monster();

	for (GameObject* d : game)
		d->render();
	for (GameObject* d : game)
		delete d;
	save();
}



-----------------------------------
Mon Nov 19 14:06:01 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//	GameObject
//
//Player	Monster
//
// GameObject는 render() 함수를 갖는다.
// Player의 render() --> "플레이어를 그린다."
// Monster의 render() --> "몬스터를 그린다."

class GameObject {
	
public:
	virtual void render() const {

	}
};
class Player : public GameObject {
public:
	void render() const override {
		cout << "플레이어를 그린다." << endl;
	}
};
class Monster : public GameObject {
public:
	void render() const override {
		cout << "몬스터를 그린다." << endl;
	}
};





int main()
{
	GameObject* game[2];

	game[0] = new Player();
	game[1] = new Monster();

	for (GameObject* d : game)
		d->render();
	for (GameObject* d : game)
		delete d;
	save();
}



-----------------------------------
Mon Nov 19 14:34:48 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//	GameObject
//
//Player	Monster
//
// GameObject는 render() 함수를 갖는다.
// Player의 render() --> "플레이어를 그린다."
// Monster의 render() --> "몬스터를 그린다."

class GameObject {
	
public:
	GameObject() { cout << "GameObject C" << endl; }
	virtual void render() const {

	}
	~GameObject() { cout << "GameObject D" << endl; }
};
class Player : public GameObject {
public:
	Player() { cout << "Plyaer C" << endl; }
	void render() const override {
		cout << "플레이어를 그린다." << endl;
	}
	~Player() { cout << "Plyaer D" << endl; }
};
class Monster : public GameObject {
public:
	Monster() { cout << "Monst C" << endl; }
	void render() const override {
		cout << "몬스터를 그린다." << endl;
	}
	~Monster() { cout << "Monster D" << endl; }
};





int main()
{
	GameObject* game[2];

	game[0] = new Player();
	game[1] = new Monster();

	for (GameObject* d : game)
		d->render();
	for (GameObject* d : game)
		delete d;
	save();
}



-----------------------------------
Mon Nov 19 14:41:23 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//	GameObject
//
//Player	Monster
//
// GameObject는 render() 함수를 갖는다.
// Player의 render() --> "플레이어를 그린다."
// Monster의 render() --> "몬스터를 그린다."

class GameObject {
	
public:
	GameObject() { cout << "GameObject C" << endl; }
	virtual void render() const {// 진짜함수를 찾아가라

	}
	~GameObject() { cout << "GameObject D" << endl; }
};
class Player : public GameObject {
public:
	Player() { cout << "Plyaer C" << endl; }
	virtual void render() const override {
		cout << "플레이어를 그린다." << endl;
	}
	~Player() { cout << "Plyaer D" << endl; }
};
class Monster : public GameObject {
public:
	Monster() { cout << "Monst C" << endl; }
	virtual void render() const override {
		cout << "몬스터를 그린다." << endl;
	}
	~Monster() { cout << "Monster D" << endl; }
};





int main()
{
	GameObject* game[2];

	game[0] = new Player();
	game[1] = new Monster();

	for (GameObject* d : game)
		d->render();
	for (GameObject* d : game)
		delete d;
	save();
}



-----------------------------------
Mon Nov 19 14:43:24 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//	GameObject
//
//Player	Monster
//
// GameObject는 render() 함수를 갖는다.
// Player의 render() --> "플레이어를 그린다."
// Monster의 render() --> "몬스터를 그린다."

class GameObject {
	
public:
	GameObject() { cout << "GameObject C" << endl; }
	virtual void render() const {// 진짜함수를 찾아가라

	}
	~GameObject() { cout << "GameObject D" << endl; }
};
class Player : public GameObject {
public:
	Player() { cout << "Plyaer C" << endl; }
	virtual void render() const override {
		cout << "플레이어를 그린다." << endl;
	}
	~Player() { cout << "Plyaer D" << endl; }
};
class Monster : public GameObject {
public:
	Monster() { cout << "Monst C" << endl; }
	virtual void render() const override {
		cout << "몬스터를 그린다." << endl;
	}
	~Monster() { cout << "Monster D" << endl; }
};





int main()
{
	GameObject* game[2];

	game[0] = new Player();
	game[1] = new Monster();

	for (GameObject* d : game)
		d->render();
	delete game[0];
	delete game[1];
	save();
}



-----------------------------------
Mon Nov 19 14:46:09 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//	GameObject
//
//Player	Monster
//
// GameObject는 render() 함수를 갖는다.
// Player의 render() --> "플레이어를 그린다."
// Monster의 render() --> "몬스터를 그린다."

class GameObject {
	
public:
	GameObject() { cout << "GameObject C" << endl; }
	virtual void render() const {// 진짜함수를 찾아가라

	}
	virtual ~GameObject() { cout << "GameObject D" << endl; }
};
class Player : public GameObject {
public:
	Player() { cout << "Plyaer C" << endl; }
	virtual void render() const override {
		cout << "플레이어를 그린다." << endl;
	}
	virtual ~Player() { cout << "Plyaer D" << endl; }
};
class Monster : public GameObject {
public:
	Monster() { cout << "Monst C" << endl; }
	virtual void render() const override {
		cout << "몬스터를 그린다." << endl;
	}
	virtual ~Monster() { cout << "Monster D" << endl; }
};





int main()
{
	GameObject* game[2];

	game[0] = new Player();
	game[1] = new Monster();

	for (GameObject* d : game)
		d->render();
	delete game[0];
	delete game[1];
	save();
}



-----------------------------------
Mon Nov 19 14:54:16 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//	GameObject
//
//Player	Monster
//
// GameObject는 render() 함수를 갖는다.
// Player의 render() --> "플레이어를 그린다."
// Monster의 render() --> "몬스터를 그린다."

class GameObject {
	
public:
	
	virtual void render() const {// 진짜함수를 찾아가라

	}
	
};
class Player : public GameObject {
public:
	virtual void render() const override {
		cout << "플레이어를 그린다." << endl;
	}
};
class Monster : public GameObject {
public:
	virtual void render() const override {
		cout << "몬스터를 그린다." << endl;
	}
};





int main()
{
	GameObject* game[2];

	game[0] = new Player();
	game[1] = new Monster();

	for (GameObject* d : game)
		d->render();
	delete game[0];
	delete game[1];
	save();
}



-----------------------------------
Mon Nov 19 15:09:09 2018

-----------------------------------
/*
 -----------------------------------------------
 2018.11.8	         월목     (11주 1일)


 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 소문자든 대문자든 문자열을 생성자의 인자로 받아
 항상 대문자로 바꿔 저장하는 String class를 만들어라.
 String class는 표준 string을 sub-classing하여 작성하라

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//	GameObject
//
//Player	Monster
//
// GameObject는 render() 함수를 갖는다.
// Player의 render() --> "플레이어를 그린다."
// Monster의 render() --> "몬스터를 그린다."

//Animal은 abstract class 이다.
class Animal {
	
public:
	virtual void move() = 0;		//순수가상함수
									// pure virtual function
};
class Dog : public Animal {
public:
	virtual void move() {
		cout << "개가 달린다," << endl;
	}
};


int main()
{
	Dog a;
	save();
}



-----------------------------------
Mon Nov 19 15:09:59 2018

-----------------------------------
/*
 -----------------------------------------------

 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

//	GameObject
//
//Player	Monster
//
// GameObject는 render() 함수를 갖는다.
// Player의 render() --> "플레이어를 그린다."
// Monster의 render() --> "몬스터를 그린다."

//Animal은 abstract class 이다.
class Animal {
	
public:
	virtual void move() = 0;		//순수가상함수
									// pure virtual function
};
class Dog : public Animal {
public:
	virtual void move() {
		cout << "개가 달린다," << endl;
	}
};


int main()
{
	Dog a;
	save();
}



-----------------------------------
Thu Nov 29 10:07:12 2018

-----------------------------------
/*
 -----------------------------------------------

 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;
void change(int& a, int& b) {

	int t = a;
	a = b;
	b = t;
}
int main()
{
	int a = 10;
	int b = 20;
	change(a, b);
	cout << a << "," << b << endl;
	save();
}



-----------------------------------
Thu Nov 29 10:07:31 2018

-----------------------------------
/*
 -----------------------------------------------

 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;
void change(int& a, int& b) {

	int t = a;
	a = b;
	b = t;
}
int main()
{
	int a{ 10 }, b{ 20 };
	change(a, b);
	cout << a << "," << b << endl;
	save();
}



-----------------------------------
Thu Nov 29 10:10:39 2018

-----------------------------------
/*
 -----------------------------------------------

 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include "save.h"
using namespace std;

class Dog {
	int n;
public:
	Dog() {}
	Dog(int n) : n(n) {}

	operator int() {
		return n;
	}

};
void change(Dog&, Dog&);
void change(Dog& a, Dog& b) {
	Dog t = a;
	a = b;
	b = t;
}
int main()
{
	Dog a{ 10 }, b{ 20 };
	change(a, b);
	cout << a << "," << b << endl;
	save();
}



-----------------------------------
Thu Nov 29 10:45:28 2018

-----------------------------------
/*
 -----------------------------------------------

 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 232쪽
 ------------------------------------------------
*/
#include <iostream>
//#include <string>
#include "save.h"
using namespace std;

// C++자료형의 갯수는 무한이다.
// 자료형이 같다면 같은 기능의 함수를 오버로딩 할 수 있다.
// --> 유사함수를 무한개 만들어야 할 수도 있다.
// --> 컴퓨터가 자동으로 코드를 만들어내면 해결 할 수 있다?

template <class T>
void change(T&, T&);

template <class T>
void change(T& a, T& b) {
	T t = a;
	a = b;
	b = t;
}


int main()
{
	int a{ 10 }, b{ 20 };

	change(a, b);
	
	string a1{ "11월" }, b1{ "29일" };
	change(a1, b1);
	save();
}



-----------------------------------
Thu Nov 29 10:48:11 2018

-----------------------------------
/*
 -----------------------------------------------

 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// C++자료형의 갯수는 무한이다.
// 자료형이 같다면 같은 기능의 함수를 오버로딩 할 수 있다.
// --> 유사함수를 무한개 만들어야 할 수도 있다.
// --> 컴퓨터가 자동으로 코드를 만들어내면 해결 할 수 있다?

template <class T>
void change(T&, T&);

template <class T>
void change(T& a, T& b) {
	T t = a;
	a = b;
	b = t;
}
class Dog {
	int n;
public:
	Dog() {}
	Dog(int n) : n(n) {}
	int getN() {
		return n;
	}
};

int main()
{
	int a{ 10 }, b{ 20 };

	change(a, b);
	
	string a1{ "11월" }, b1{ "29일" };
	change(a1, b1);

	Dog a2{ 10 }, b2{ 20 };
	cout << a << "," << b << endl;
	cout << a1 << "," << b1 << endl;
	cout << a2.getN() << "," << b2.getN() << endl;
	save();
}



-----------------------------------
Thu Nov 29 10:48:43 2018

-----------------------------------
/*
 -----------------------------------------------

 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// C++자료형의 갯수는 무한이다.
// 자료형이 같다면 같은 기능의 함수를 오버로딩 할 수 있다.
// --> 유사함수를 무한개 만들어야 할 수도 있다.
// --> 컴퓨터가 자동으로 코드를 만들어내면 해결 할 수 있다?

template <class T>
void change(T&, T&);

template <class T>
void change(T& a, T& b) {
	T t = a;
	a = b;
	b = t;
}
class Dog {
	int n;
public:
	Dog() {}
	Dog(int n) : n(n) {}
	int getN() {
		return n;
	}
};

int main()
{
	int a{ 10 }, b{ 20 };

	change(a, b);
	
	string a1{ "11월" }, b1{ "29일" };
	change(a1, b1);

	Dog a2{ 10 }, b2{ 20 };

	cout << a << "," << b << endl;
	cout << a1 << "," << b1 << endl;
	cout << a2.getN() << "," << b2.getN() << endl;
	save();
}



-----------------------------------
Thu Nov 29 10:55:47 2018

-----------------------------------
/*
 -----------------------------------------------

 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// C++자료형의 갯수는 무한이다.
// 자료형이 같다면 같은 기능의 함수를 오버로딩 할 수 있다.
// --> 유사함수를 무한개 만들어야 할 수도 있다.
// --> 컴퓨터가 자동으로 코드를 만들어내면 해결 할 수 있다?

template <class T>
void change(T&, T&);

template <class T>
void change(T& a, T& b) {
	T t = a;
	a = b;
	b = t;
}
class Dog {
	int n;
public:
	Dog() {}
	Dog(int n) : n(n) {}
	operator int() {
		return n;
	}
};

int main()
{
	int a{ 10 }, b{ 20 };

	change(a, b);
	
	string a1{ "11월" }, b1{ "29일" };
	change(a1, b1);

	Dog a2{ 10 }, b2{ 20 };

	cout << a << "," << b << endl;
	cout << a1 << "," << b1 << endl;
	cout << a2 << "," << b2 << endl;
	save();
}



-----------------------------------
Thu Nov 29 10:57:17 2018

-----------------------------------
/*
 -----------------------------------------------

 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// C++자료형의 갯수는 무한이다.
// 자료형이 같다면 같은 기능의 함수를 오버로딩 할 수 있다.
// --> 유사함수를 무한개 만들어야 할 수도 있다.
// --> 컴퓨터가 자동으로 코드를 만들어내면 해결 할 수 있다?

template <class T>
void change(T&, T&);

template <class T>
void change(T& a, T& b) {
	T t = a;
	a = b;
	b = t;
}
class Dog {
	int n;
public:
	Dog() {}
	Dog(int n) : n(n) {}
	operator int() {
		return n;
	}
};

int main()
{
	int a{ 10 }, b{ 20 };

	change(a, b);
	
	string a1{ "11월" }, b1{ "29일" };
	change(a1, b1);

	Dog a2{ 10 }, b2{ 20 };
	change(a2, b2);
	cout << a << "," << b << endl;
	cout << a1 << "," << b1 << endl;
	cout << a2 << "," << b2 << endl;
	save();
}



-----------------------------------
Thu Nov 29 11:06:09 2018

-----------------------------------
/*
 -----------------------------------------------

 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// C++자료형의 갯수는 무한이다.
// 자료형이 같다면 같은 기능의 함수를 오버로딩 할 수 있다.
// --> 유사함수를 무한개 만들어야 할 수도 있다.
// --> 컴퓨터가 자동으로 코드를 만들어내면 해결 할 수 있다?

template <class T>
void change(T&, T&);

template <class T>
void change(T& a, T& b) {
	T t = a;
	a = b;
	b = t;
}
class Dog {
	int n;
public:
	Dog() {}
	Dog(int n) : n(n) {}
	operator int() {
		return n;
	}
};

int main()
{
	int a{ 10 }, b{ 20 };
	int* p;
	int* q;

	change(p, q);

	cout << a << "," << b << endl;
	save();
}



-----------------------------------
Thu Nov 29 11:20:39 2018

-----------------------------------
/*
 -----------------------------------------------

 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// C++자료형의 갯수는 무한이다.
// 자료형이 같다면 같은 기능의 함수를 오버로딩 할 수 있다.
// --> 유사함수를 무한개 만들어야 할 수도 있다.
// --> 컴퓨터가 자동으로 코드를 만들어내면 해결 할 수 있다?

template <class T>
void change(T&, T&);

template <class T>
void change(T& a, T& b) {
	T t = a;
	a = b;
	b = t;
}
void change(int*&, int*&);
void change(int*& a, int*& b) {

	int t = *a;
	*a = *b;
	*b = t;

}
class Dog {
	int n;
public:
	Dog() {}
	Dog(int n) : n(n) {}
	operator int() {
		return n;
	}
};

int main()
{
	int a{ 10 }, b{ 20 };
	int* p = &a;
	int* q = &b;
	change(p,q);
	cout << a << ","  << b << endl;
	save();
}



-----------------------------------
Mon Dec  3 13:39:13 2018

-----------------------------------
/*
 -----------------------------------------------

 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// C++자료형의 갯수는 무한이다.
// 자료형이 같다면 같은 기능의 함수를 오버로딩 할 수 있다.
// --> 유사함수를 무한개 만들어야 할 수도 있다.
// --> 컴퓨터가 자동으로 코드를 만들어내면 해결 할 수 있다?

//Gerneric Programming
template <class T>
void change(T&, T&);

template <class T>
void change(T& a, T& b) {
	T t = a;
	a = b;
	b = t;
}
void change(int*&, int*&);
void change(int*& a, int*& b) {

	int t = *a;
	*a = *b;
	*b = t;

}
class Dog {
	int n;
public:
	Dog() {}
	Dog(int n) : n(n) {}
	operator int() {
		return n;
	}
};

int main()
{
	int a{ 10 }, b{ 20 };
	int* p = &a;
	int* q = &b;
	change(p,q);
	cout << a << ","  << b << endl;
	save();
}


/*
기본 자료형		Procedual Programming int
확장 자료형		Object Oriented Programming(OOP) Dog
관계											Animal - Dog

자료형과 무관	Gerneric Programming - template
*/
-----------------------------------
Mon Dec  3 13:40:13 2018

-----------------------------------
/*
 -----------------------------------------------

 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// C++자료형의 갯수는 무한이다.
// 자료형이 같다면 같은 기능의 함수를 오버로딩 할 수 있다.
// --> 유사함수를 무한개 만들어야 할 수도 있다.
// --> 컴퓨터가 자동으로 코드를 만들어내면 해결 할 수 있다?

//함수 템플릿
template <class T>
void change(T&, T&);

template <class T>
void change(T& a, T& b) {
	T t = a;
	a = b;
	b = t;
}
void change(int*&, int*&);
void change(int*& a, int*& b) {

	int t = *a;
	*a = *b;
	*b = t;

}
class Dog {
	int n;
public:
	Dog() {}
	Dog(int n) : n(n) {}
	operator int() {
		return n;
	}
};

int main()
{
	int a{ 10 }, b{ 20 };
	int* p = &a;
	int* q = &b;
	change(p,q);	// --> 함수 템플릿은 이함수를 보고
					// 실제 함수를 찍어낸다.
					// 템플릿 함수 라고 부른다.
	cout << a << ","  << b << endl;
	save();
}


/*
기본 자료형		Procedual Programming int
확장 자료형		Object Oriented Programming(OOP) Dog
관계											Animal - Dog

자료형과 무관	Gerneric Programming - template
*/
-----------------------------------
Mon Dec  3 13:41:23 2018

-----------------------------------
/*
 -----------------------------------------------

 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;

// C++자료형의 갯수는 무한이다.
// 자료형이 같다면 같은 기능의 함수를 오버로딩 할 수 있다.
// --> 유사함수를 무한개 만들어야 할 수도 있다.
// --> 컴퓨터가 자동으로 코드를 만들어내면 해결 할 수 있다?

//함수 템플릿	메타 프로그래밍
template <class T>
void change(T&, T&);

template <class T>
void change(T& a, T& b) {
	T t = a;
	a = b;
	b = t;
}
void change(int*&, int*&);
void change(int*& a, int*& b) {

	int t = *a;
	*a = *b;
	*b = t;

}
class Dog {
	int n;
public:
	Dog() {}
	Dog(int n) : n(n) {}
	operator int() {
		return n;
	}
};

int main()
{
	int a{ 10 }, b{ 20 };
	int* p = &a;
	int* q = &b;
	change(p,q);	// --> 함수 템플릿은 이함수를 보고
					// 실제 함수를 찍어낸다.
					// 템플릿 함수 라고 부른다.
	cout << a << ","  << b << endl;
	save();
}


/*
기본 자료형		Procedual Programming int
확장 자료형		Object Oriented Programming(OOP) Dog
관계											Animal - Dog

자료형과 무관	Gerneric Programming - template
*/
-----------------------------------
Mon Dec  3 14:35:17 2018

-----------------------------------
/*
 -----------------------------------------------

 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include "save.h"
using namespace std;
// 정수를 담는 안전배열을 만들어라
// 다음 main()이 수정없이 실행되도록 하자
template<class T>
class Array{
	size_t num;
	T* p;
public:
	Array(int n) : num(n) {
		p = new T[num];
	}
	Array(const Array& other) : num(other.num){
		p = new T[num];
		memcpy(p, other.p, num * sizeof(T));
	}
	Array() {}
	~Array() { delete[] p; }
	
	int& operator[](int idx) const {
		if (idx >= 0 && idx < num)
			return p[idx];
		else
			throw 1;
	}
	Array& operator=(const Array& other) {
		if (this == &other)
			return *this;
		delete[] p;
		num = other.num;
		p = new T[num];
		memcpy(p, other.p, num * sizeof(T));
	}

	T* begin() {
		return &p[0];
	}
	T* end() {
		return &p[num];
	}

	size_t size() const {
		return num;
	}
};

int main()
{
	Array<int> a(10);

	for (int i = 0; i < a.size(); ++i)
		a[i] = i;
	for (int d : a)
		cout << d << ' ';
	cout << endl;

	try {
		cout << a[-1] << endl;
	} 
	catch( int n ){
		cout << "범위 예외가 발생함" << endl;
	}
	save();
}



-----------------------------------
Mon Dec  3 14:44:38 2018

-----------------------------------
/*
 -----------------------------------------------

 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template
 
 상속 - 왜 좋은가?
 215쪽의 다른 관계들과 상속은 어떻게 다른가?

 C++에서 상속은 어떻게 코딩하나?
 상속시 메모리는 어떻게 관리되나?
 조상의 코드를 자식에서 어떻게 활용할 수 있나?

 상속을 사용하서 하고자 하는 것은 무엇인가?
		--- 다형성(polymorphism)을 구현하려고 사용한다.
			추상클래스/ 가상함수/ 인터페이스 강제

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <array>
#include "save.h"
using namespace std;
// 정수를 담는 안전배열을 만들어라
// 다음 main()이 수정없이 실행되도록 하자

int main()
{
	array < int, 10> a;
	for (int i = 0; i < 10; ++i) {
		a[i] = i;
	}
	for (int d : a) {
		cout << d << ' ';
	}
	cout << endl;
	save();
}



-----------------------------------
Mon Dec  3 15:01:25 2018

-----------------------------------
/*
 -----------------------------------------------

 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include <array>
#include "save.h"
using namespace std;
// 정수를 담는 안전배열을 만들어라
// 다음 main()이 수정없이 실행되도록 하자
class Dog {
	string name;
	int age;
public:
	Dog(string s, int n) :name(s), age(n) {}
	Dog() {}

	void run() const {
		cout << name << "," << age << "살 달린다." << endl;
	}

};
int main()
{ 
	array < Dog, 10> a{
		Dog("댕댕이", 1),
		{ "댕댕이",1 },
		{ "댕댕이",1 },
		{ "댕댕이",1 },
		{ "댕댕이",1 },
		{ "댕댕이",1 },
		{ "댕댕이",1 },
		{ "댕댕이",1 },
		{ "댕댕이",1 },
		{ "댕댕이",1 },
	};
	for (int i = 0; i < a.size(); ++i)
		a[i].run();
	save();
}



-----------------------------------
Mon Dec  3 15:01:56 2018

-----------------------------------
/*
 -----------------------------------------------

 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include <array>
#include "save.h"
using namespace std;
// 정수를 담는 안전배열을 만들어라
// 다음 main()이 수정없이 실행되도록 하자
class Dog {
	string name;
	int age;
public:
	Dog(string s, int n) :name(s), age(n) {}
	Dog() {}

	void run() const {
		cout << name << "," << age << "살 달린다." << endl;
	}

};
int main()
{ 
	array < Dog, 10> a{
		Dog("댕댕이", 1),
		{ "댕댕이",3 },
		{ "댕댕이",5 },
		{ "댕댕이",7 },
		{ "댕댕이",9 },
		{ "댕댕이",11 },
		{ "댕댕이",13 },
		{ "댕댕이",15 },
		{ "댕댕이",17 },
		{ "댕댕이",19 },
	};
	for (int i = 0; i < a.size(); ++i)
		a[i].run();
	save();
}



-----------------------------------
Mon Dec  3 15:09:46 2018

-----------------------------------
/*
 -----------------------------------------------

 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include <algorithm>
#include <array>
#include "save.h"
using namespace std;
// 정수를 담는 안전배열을 만들어라
// 다음 main()이 수정없이 실행되도록 하자
class Dog {
	string name;
	int age;
public:
	Dog(string s, int n) :name(s), age(n) {}
	Dog() {}

	void run() const {
		cout << name << "," << age << "살 달린다." << endl;
	}

	int get() const {
		return age;
	}
};
int main()
{ 
	array < Dog, 10> a{
		Dog("댕댕이", 1),
		{ "댕댕이",3 },
		{ "댕댕이",5 },
		{ "댕댕이",7 },
		{ "댕댕이",9 },
		{ "댕댕이",11 },
		{ "댕댕이",13 },
		{ "댕댕이",15 },
		{ "댕댕이",17 },
		{ "댕댕이",19 },
	};

	sort(a.begin(), a.end(), [](const Dog& a, const Dog& b) {
		return a.get() > b.get();
	});
	for (int i = 0; i < a.size(); ++i)
		a[i].run();
	save();
}



-----------------------------------
Mon Sep 30 18:08:29 2019

-----------------------------------
/*
 -----------------------------------------------

 class(5장,10장,11장,8장)

 class 이동
 Inheritance
 Template

 232쪽
 ------------------------------------------------
*/
#include <iostream>
#include <string>
#include <algorithm>
#include <array>
#include "save.h"
using namespace std;
// 기본자료형			- POD
// 사용자 정의 자료형	- class로 만듦 (무한개)
// 제네릭				- 자료형과 무관 - template
//		험수
//		클래스
int main()
{ 

	save();
}



